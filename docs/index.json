[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "src/JSON.d.ts",
    "content": "export type JSONPrimitive = string | number | boolean | null\nexport type JSONValue = JSONPrimitive | JSONObject | JSONArray\nexport interface JSONObject {\n  [member: string]: JSONValue\n}\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface JSONArray extends Array<JSONValue> {}\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/src/JSON.d.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "file",
    "name": "src/StreamWalker.ts",
    "content": "/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/explicit-function-return-type */\nimport {Event} from './event'\nimport * as eventstoreError from './errors'\n/**\n * Stream walker\n */\nexport class StreamWalker {\n  /** iterable  */\n  protected iterable: AsyncIterableIterator<Event | null>\n\n  /**\n   * Creates an instance of stream walker.\n   */\n  public constructor(iterable: AsyncIterableIterator<Event | null>) {\n    this.iterable = iterable\n  }\n\n  /** standard async iterable function */\n  public async *[Symbol.asyncIterator]() {\n    for await (const value of this.iterable) {\n      yield value\n    }\n  }\n\n  /**\n   * The map() method creates a new iterator with the results of calling a provided function on every element in the calling iterator\n   */\n  public map(fn: Function, thisArg?: Function): StreamWalker {\n    if (typeof fn !== 'function') {\n      throw eventstoreError.newImplementationError(fn + 'is not a function')\n    }\n\n    const a = async function*(iterable: AsyncIterable<Event | null>) {\n      for await (const value of iterable) {\n        yield await fn.call(thisArg, value)\n      }\n    }\n    return new StreamWalker(a(this.iterable))\n  }\n\n  /**\n   * The filter() method creates a new iterator with all elements that pass the test implemented by the provided function\n   */\n  public filter(fn: Function, thisArg?: Function): StreamWalker {\n    if (typeof fn !== 'function') {\n      throw eventstoreError.newImplementationError(fn + 'is not a function')\n    }\n\n    const iterable = this.iterable\n    const b = async function*(fn: Function, thisArg?: Function) {\n      for await (const value of iterable) {\n        if (await fn.call(thisArg, value)) {\n          yield value\n        }\n      }\n    }\n\n    return new StreamWalker(b(fn, thisArg))\n  }\n\n  /**\n   * The forEach() method executes a provided function once for each iterator element\n   */\n  public async forEach(fn: Function, thisArg?: Function, ...args: any[]): Promise<void> {\n    if (typeof fn !== 'function') {\n      throw eventstoreError.newImplementationError(fn + 'is not a function')\n    }\n    const iterable = this.iterable\n    for await (const value of iterable) {\n      await fn.call(thisArg, value, ...args)\n    }\n  }\n\n  /**\n   * The reduce() method applies a function against an accumulator and each element in the iterator (from left to right) to reduce it to a single value\n   */\n  public async reduce(\n    accumulatorFunction: Function,\n    initialValue: any = null,\n    thisArg?: Function\n  ): Promise<any> {\n    if (typeof accumulatorFunction !== 'function') {\n      throw eventstoreError.newImplementationError(accumulatorFunction + 'is not a function')\n    }\n    const iterable = this.iterable\n    let returnValue = initialValue\n    for await (const value of iterable) {\n      returnValue = await accumulatorFunction.call(thisArg, returnValue, value)\n    }\n    return returnValue\n  }\n\n  /**\n   * Converts an iterator to an array.\n   * The returned array will contain all single elements of iterator\n   */\n  public async toArray(): Promise<(Event | null)[]> {\n    const iterable = this.iterable\n    const arrayValue = []\n    for await (const value of iterable) {\n      arrayValue.push(value)\n    }\n    return arrayValue\n  }\n\n  /**\n   * The every() method tests whether all elements in the iterator pass the test implemented by the provided function\n   */\n  public async every(fn: Function, thisArg?: Function): Promise<boolean> {\n    if (typeof fn !== 'function') {\n      throw eventstoreError.newImplementationError(fn + 'is not a function')\n    }\n    const iterable = this.iterable\n    for await (const value of iterable) {\n      if ((await fn.call(thisArg, value)) === false) {\n        return false\n      }\n    }\n    return true\n  }\n}\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/src/StreamWalker.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 50,
    "kind": "class",
    "name": "StreamWalker",
    "memberof": "src/StreamWalker.ts",
    "static": true,
    "longname": "src/StreamWalker.ts~StreamWalker",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/StreamWalker.ts",
    "importStyle": "{StreamWalker}",
    "description": "Stream walker",
    "lineNumber": 8,
    "interface": false
  },
  {
    "__docId__": 51,
    "kind": "member",
    "name": "iterable",
    "memberof": "src/StreamWalker.ts~StreamWalker",
    "static": false,
    "longname": "src/StreamWalker.ts~StreamWalker#iterable",
    "access": "protected",
    "description": "iterable",
    "lineNumber": 10,
    "type": {
      "types": [
        "AsyncIterableIterator"
      ]
    }
  },
  {
    "__docId__": 52,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/StreamWalker.ts~StreamWalker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/StreamWalker.ts~StreamWalker#constructor",
    "access": "public",
    "description": "Creates an instance of stream walker.",
    "lineNumber": 15
  },
  {
    "__docId__": 54,
    "kind": "method",
    "name": "[Symbol.asyncIterator]",
    "memberof": "src/StreamWalker.ts~StreamWalker",
    "generator": true,
    "async": true,
    "static": false,
    "longname": "src/StreamWalker.ts~StreamWalker#[Symbol.asyncIterator]",
    "access": "public",
    "description": "standard async iterable function",
    "lineNumber": 20,
    "params": [],
    "type": null
  },
  {
    "__docId__": 55,
    "kind": "method",
    "name": "map",
    "memberof": "src/StreamWalker.ts~StreamWalker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/StreamWalker.ts~StreamWalker#map",
    "access": "public",
    "description": "The map() method creates a new iterator with the results of calling a provided function on every element in the calling iterator",
    "lineNumber": 29,
    "params": [
      {
        "types": [
          "Function"
        ],
        "name": "fn"
      },
      {
        "types": [
          "Function"
        ],
        "name": "thisArg"
      }
    ],
    "type": {
      "types": [
        "StreamWalker"
      ]
    }
  },
  {
    "__docId__": 56,
    "kind": "method",
    "name": "filter",
    "memberof": "src/StreamWalker.ts~StreamWalker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/StreamWalker.ts~StreamWalker#filter",
    "access": "public",
    "description": "The filter() method creates a new iterator with all elements that pass the test implemented by the provided function",
    "lineNumber": 45,
    "params": [
      {
        "types": [
          "Function"
        ],
        "name": "fn"
      },
      {
        "types": [
          "Function"
        ],
        "name": "thisArg"
      }
    ],
    "type": {
      "types": [
        "StreamWalker"
      ]
    }
  },
  {
    "__docId__": 57,
    "kind": "method",
    "name": "forEach",
    "memberof": "src/StreamWalker.ts~StreamWalker",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/StreamWalker.ts~StreamWalker#forEach",
    "access": "public",
    "description": "The forEach() method executes a provided function once for each iterator element",
    "lineNumber": 65,
    "params": [
      {
        "types": [
          "Function"
        ],
        "name": "fn"
      },
      {
        "types": [
          "Function"
        ],
        "name": "thisArg"
      },
      {
        "types": [
          "...*"
        ],
        "name": "args",
        "spread": true
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 58,
    "kind": "method",
    "name": "reduce",
    "memberof": "src/StreamWalker.ts~StreamWalker",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/StreamWalker.ts~StreamWalker#reduce",
    "access": "public",
    "description": "The reduce() method applies a function against an accumulator and each element in the iterator (from left to right) to reduce it to a single value",
    "lineNumber": 78,
    "params": [
      {
        "types": [
          "Function"
        ],
        "name": "accumulatorFunction"
      },
      {
        "types": [],
        "name": "initialValue",
        "optional": true,
        "defaultRaw": null,
        "defaultValue": "null"
      },
      {
        "types": [
          "Function"
        ],
        "name": "thisArg"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 59,
    "kind": "method",
    "name": "toArray",
    "memberof": "src/StreamWalker.ts~StreamWalker",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/StreamWalker.ts~StreamWalker#toArray",
    "access": "public",
    "description": "Converts an iterator to an array.\nThe returned array will contain all single elements of iterator",
    "lineNumber": 98,
    "params": [],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 60,
    "kind": "method",
    "name": "every",
    "memberof": "src/StreamWalker.ts~StreamWalker",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/StreamWalker.ts~StreamWalker#every",
    "access": "public",
    "description": "The every() method tests whether all elements in the iterator pass the test implemented by the provided function",
    "lineNumber": 110,
    "params": [
      {
        "types": [
          "Function"
        ],
        "name": "fn"
      },
      {
        "types": [
          "Function"
        ],
        "name": "thisArg"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 61,
    "kind": "file",
    "name": "src/errors/EventstoreError.ts",
    "content": "/**\n * Eventstore error base class\n */\nexport class EventstoreError extends Error {\n  /** @type {Error|null} */\n  public rootCause: Error | null = null\n\n  /**\n   * Creates new instance of EventstoreError\n   */\n  public constructor(\n    message: string,\n    name: string = 'EventstoreError',\n    rootCause: Error | null = null\n  ) {\n    super(message)\n\n    /** Set name of error */\n    this.name = name\n    this.rootCause = rootCause\n  }\n}\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/src/errors/EventstoreError.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 62,
    "kind": "class",
    "name": "EventstoreError",
    "memberof": "src/errors/EventstoreError.ts",
    "static": true,
    "longname": "src/errors/EventstoreError.ts~EventstoreError",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/errors/EventstoreError.ts",
    "importStyle": "{EventstoreError}",
    "description": "Eventstore error base class",
    "lineNumber": 4,
    "interface": false,
    "extends": [
      "Error"
    ]
  },
  {
    "__docId__": 63,
    "kind": "member",
    "name": "rootCause",
    "memberof": "src/errors/EventstoreError.ts~EventstoreError",
    "static": false,
    "longname": "src/errors/EventstoreError.ts~EventstoreError#rootCause",
    "access": "public",
    "description": null,
    "lineNumber": 6,
    "type": {
      "types": [
        "Error",
        "null"
      ]
    }
  },
  {
    "__docId__": 64,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/errors/EventstoreError.ts~EventstoreError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/errors/EventstoreError.ts~EventstoreError#constructor",
    "access": "public",
    "description": "Creates new instance of EventstoreError",
    "lineNumber": 11
  },
  {
    "__docId__": 65,
    "kind": "member",
    "name": "name",
    "memberof": "src/errors/EventstoreError.ts~EventstoreError",
    "static": false,
    "longname": "src/errors/EventstoreError.ts~EventstoreError#name",
    "access": "public",
    "description": "Set name of error",
    "lineNumber": 19,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 67,
    "kind": "file",
    "name": "src/errors/index.ts",
    "content": "import {EventstoreError} from './EventstoreError'\n\n/**\n * Returns new EventstoreError type of EventstoreConnectionError\n */\nfunction newConnectionError(message: string, rootCause: Error | null = null): EventstoreError {\n  return new EventstoreError(message, 'EventstoreConnectionError', rootCause)\n}\n\n/**\n * Returns new EventstoreError type of EventstoreProtocolError\n */\nfunction newProtocolError(message: string, rootCause: Error | null = null): EventstoreError {\n  return new EventstoreError(message, 'EventstoreProtocolError', rootCause)\n}\n\n/**\n * Returns new EventstoreError type of EventstoreBadRequestError\n */\nfunction newBadRequestError(\n  message: string = 'Bad Request',\n  rootCause: Error | null = null\n): EventstoreError {\n  return new EventstoreError(message, 'EventstoreBadRequestError', rootCause)\n}\n\n/**\n * Returns new EventstoreError type of EventstoreNotAuthenticatedError\n */\nfunction newNotAuthenticatedError(\n  message: string = 'Not Authenticated',\n  rootCause: Error | null = null\n): EventstoreError {\n  return new EventstoreError(message, 'EventstoreNotAuthenticatedError', rootCause)\n}\n\n/**\n * Returns new EventstoreError type of EventstoreNotHandledError\n */\nfunction newNotHandledError(message: string, rootCause: Error | null = null): EventstoreError {\n  return new EventstoreError(`Not handled ${message}`, 'EventstoreNotHandledError', rootCause)\n}\n\n/**\n * Returns new EventstoreError type of EventstorePrepareTimeoutError\n */\nfunction newPrepareTimeoutError(message: string, rootCause: Error | null = null): EventstoreError {\n  return new EventstoreError(\n    `Prepare timeout error ${message}`,\n    'EventstorePrepareTimeoutError',\n    rootCause\n  )\n}\n\n/**\n * Returns new EventstoreError type of EventstoreCommitTimeoutError\n */\nfunction newCommitTimeoutError(message: string, rootCause: Error | null = null): EventstoreError {\n  return new EventstoreError(`Commit timeout ${message}`, 'EventstoreCommitTimeoutError', rootCause)\n}\n\n/**\n * Returns new EventstoreError type of EventstoreForwardTimeoutError\n */\nfunction newForwardTimeoutError(message: string, rootCause: Error | null = null): EventstoreError {\n  return new EventstoreError(\n    `Forward timeout ${message}`,\n    'EventstoreForwardTimeoutError',\n    rootCause\n  )\n}\n\n/**\n * Returns new EventstoreError type of EventstoreWrongExpectedVersionError\n */\nfunction newWrongExpectedVersionError(\n  message: string,\n  rootCause: Error | null = null\n): EventstoreError {\n  return new EventstoreError(\n    `Wrong expected version ${message}`,\n    'EventstoreWrongExpectedVersionError',\n    rootCause\n  )\n}\n\n/**\n * Returns new EventstoreError type of EventstoreStreamDeletedError\n */\nfunction newStreamDeletedError(message: string, rootCause: Error | null = null): EventstoreError {\n  return new EventstoreError(`Stream deleted ${message}`, 'EventstoreStreamDeletedError', rootCause)\n}\n\n/**\n * Returns new EventstoreError type of EventstoreInvalidTransactionError\n */\nfunction newInvalidTransactionError(\n  message: string,\n  rootCause: Error | null = null\n): EventstoreError {\n  return new EventstoreError(\n    `Invalid transaction ${message}`,\n    'EventstoreInvalidTransactionError',\n    rootCause\n  )\n}\n\n/**\n * Returns new EventstoreError type of EventstoreAccessDeniedError\n */\nfunction newAccessDeniedError(message: string, rootCause: Error | null = null): EventstoreError {\n  return new EventstoreError(`Access denied ${message}`, 'EventstoreAccessDeniedError', rootCause)\n}\n\n/**\n * Returns new EventstoreError type of EventstoreNotFoundError\n */\nfunction newNotFoundError(message: string, rootCause: Error | null = null): EventstoreError {\n  return new EventstoreError(`Not found ${message}`, 'EventstoreNotFoundError', rootCause)\n}\n\n/**\n * Returns new EventstoreError type of EventstoreNoStreamError\n */\nfunction newNoStreamError(message: string, rootCause: Error | null = null): EventstoreError {\n  return new EventstoreError(`No stream ${message}`, 'EventstoreNoStreamError', rootCause)\n}\n\n/**\n * Returns new EventstoreError type of EventstoreNotModifiedError\n */\nfunction newNotModifiedError(message: string, rootCause: Error | null = null): EventstoreError {\n  return new EventstoreError(`Not modified ${message}`, 'EventstoreNotModifiedError', rootCause)\n}\n\n/**\n * Returns new EventstoreError type of EventstoreUnspecificError\n */\nfunction newUnspecificError(message: string = '', rootCause: Error | null = null): EventstoreError {\n  return new EventstoreError(\n    `Unspecified error: ${message}`,\n    'EventstoreUnspecificError',\n    rootCause\n  )\n}\n\n/**\n * Returns new EventstoreError type of EventstoreImplementationError\n */\nfunction newImplementationError(\n  message: string = '',\n  rootCause: Error | null = null\n): EventstoreError {\n  return new EventstoreError(\n    `Implementation error: ${message}`,\n    'EventstoreImplementationError',\n    rootCause\n  )\n}\n\n/**\n * Returns new EventstoreError type of EventstoreDoesNotExistError\n */\nfunction newDoesNotExistError(\n  message: string = 'Does not exist',\n  rootCause: Error | null = null\n): EventstoreError {\n  return new EventstoreError(`${message}`, 'EventstoreDoesNotExistError', rootCause)\n}\n\n/**\n * Returns new EventstoreError type of EventstoreAlreadyExistError\n */\nfunction newAlreadyExistError(\n  message: string = 'Already exists',\n  rootCause: Error | null = null\n): EventstoreError {\n  return new EventstoreError(`${message}`, 'EventstoreAlreadyExistError', rootCause)\n}\n\n/**\n * Returns new EventstoreError type of EventstoreTimeoutError\n */\nfunction newTimeoutError(message: string = '', rootCause: Error | null = null): EventstoreError {\n  return new EventstoreError(`Timeout error: ${message}`, 'EventstoreTimeoutError', rootCause)\n}\n\n/**\n * Returns new EventstoreError type of EventstoreOperationError\n */\nfunction newOperationError(message: string = '', rootCause: Error | null = null): EventstoreError {\n  return new EventstoreError(`Operation error: ${message}`, 'EventstoreOperationError', rootCause)\n}\n\nexport {\n  EventstoreError,\n  newConnectionError,\n  newProtocolError,\n  newBadRequestError,\n  newNotAuthenticatedError,\n  newNotHandledError,\n  newPrepareTimeoutError,\n  newCommitTimeoutError,\n  newForwardTimeoutError,\n  newWrongExpectedVersionError,\n  newStreamDeletedError,\n  newInvalidTransactionError,\n  newAccessDeniedError,\n  newNotFoundError,\n  newNoStreamError,\n  newNotModifiedError,\n  newUnspecificError,\n  newDoesNotExistError,\n  newAlreadyExistError,\n  newImplementationError,\n  newTimeoutError,\n  newOperationError\n}\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/src/errors/index.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 68,
    "kind": "function",
    "name": "newConnectionError",
    "memberof": "src/errors/index.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/errors/index.ts~newConnectionError",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/errors/index.ts",
    "importStyle": "{newConnectionError}",
    "description": "Returns new EventstoreError type of EventstoreConnectionError",
    "lineNumber": 6,
    "params": [
      {
        "types": [],
        "name": "message"
      },
      {
        "types": [
          "Error",
          "null"
        ],
        "name": "rootCause",
        "optional": true,
        "defaultRaw": null,
        "defaultValue": "null"
      }
    ],
    "type": {
      "types": [
        "EventstoreError"
      ]
    }
  },
  {
    "__docId__": 69,
    "kind": "function",
    "name": "newProtocolError",
    "memberof": "src/errors/index.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/errors/index.ts~newProtocolError",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/errors/index.ts",
    "importStyle": "{newProtocolError}",
    "description": "Returns new EventstoreError type of EventstoreProtocolError",
    "lineNumber": 13,
    "params": [
      {
        "types": [],
        "name": "message"
      },
      {
        "types": [
          "Error",
          "null"
        ],
        "name": "rootCause",
        "optional": true,
        "defaultRaw": null,
        "defaultValue": "null"
      }
    ],
    "type": {
      "types": [
        "EventstoreError"
      ]
    }
  },
  {
    "__docId__": 70,
    "kind": "function",
    "name": "newBadRequestError",
    "memberof": "src/errors/index.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/errors/index.ts~newBadRequestError",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/errors/index.ts",
    "importStyle": "{newBadRequestError}",
    "description": "Returns new EventstoreError type of EventstoreBadRequestError",
    "lineNumber": 20,
    "params": [
      {
        "types": [
          "string"
        ],
        "name": "message",
        "optional": true,
        "defaultRaw": "Bad Request",
        "defaultValue": "Bad Request"
      },
      {
        "types": [
          "Error",
          "null"
        ],
        "name": "rootCause",
        "optional": true,
        "defaultRaw": null,
        "defaultValue": "null"
      }
    ],
    "type": {
      "types": [
        "EventstoreError"
      ]
    }
  },
  {
    "__docId__": 71,
    "kind": "function",
    "name": "newNotAuthenticatedError",
    "memberof": "src/errors/index.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/errors/index.ts~newNotAuthenticatedError",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/errors/index.ts",
    "importStyle": "{newNotAuthenticatedError}",
    "description": "Returns new EventstoreError type of EventstoreNotAuthenticatedError",
    "lineNumber": 30,
    "params": [
      {
        "types": [
          "string"
        ],
        "name": "message",
        "optional": true,
        "defaultRaw": "Not Authenticated",
        "defaultValue": "Not Authenticated"
      },
      {
        "types": [
          "Error",
          "null"
        ],
        "name": "rootCause",
        "optional": true,
        "defaultRaw": null,
        "defaultValue": "null"
      }
    ],
    "type": {
      "types": [
        "EventstoreError"
      ]
    }
  },
  {
    "__docId__": 72,
    "kind": "function",
    "name": "newNotHandledError",
    "memberof": "src/errors/index.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/errors/index.ts~newNotHandledError",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/errors/index.ts",
    "importStyle": "{newNotHandledError}",
    "description": "Returns new EventstoreError type of EventstoreNotHandledError",
    "lineNumber": 40,
    "params": [
      {
        "types": [],
        "name": "message"
      },
      {
        "types": [
          "Error",
          "null"
        ],
        "name": "rootCause",
        "optional": true,
        "defaultRaw": null,
        "defaultValue": "null"
      }
    ],
    "type": {
      "types": [
        "EventstoreError"
      ]
    }
  },
  {
    "__docId__": 73,
    "kind": "function",
    "name": "newPrepareTimeoutError",
    "memberof": "src/errors/index.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/errors/index.ts~newPrepareTimeoutError",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/errors/index.ts",
    "importStyle": "{newPrepareTimeoutError}",
    "description": "Returns new EventstoreError type of EventstorePrepareTimeoutError",
    "lineNumber": 47,
    "params": [
      {
        "types": [],
        "name": "message"
      },
      {
        "types": [
          "Error",
          "null"
        ],
        "name": "rootCause",
        "optional": true,
        "defaultRaw": null,
        "defaultValue": "null"
      }
    ],
    "type": {
      "types": [
        "EventstoreError"
      ]
    }
  },
  {
    "__docId__": 74,
    "kind": "function",
    "name": "newCommitTimeoutError",
    "memberof": "src/errors/index.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/errors/index.ts~newCommitTimeoutError",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/errors/index.ts",
    "importStyle": "{newCommitTimeoutError}",
    "description": "Returns new EventstoreError type of EventstoreCommitTimeoutError",
    "lineNumber": 58,
    "params": [
      {
        "types": [],
        "name": "message"
      },
      {
        "types": [
          "Error",
          "null"
        ],
        "name": "rootCause",
        "optional": true,
        "defaultRaw": null,
        "defaultValue": "null"
      }
    ],
    "type": {
      "types": [
        "EventstoreError"
      ]
    }
  },
  {
    "__docId__": 75,
    "kind": "function",
    "name": "newForwardTimeoutError",
    "memberof": "src/errors/index.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/errors/index.ts~newForwardTimeoutError",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/errors/index.ts",
    "importStyle": "{newForwardTimeoutError}",
    "description": "Returns new EventstoreError type of EventstoreForwardTimeoutError",
    "lineNumber": 65,
    "params": [
      {
        "types": [],
        "name": "message"
      },
      {
        "types": [
          "Error",
          "null"
        ],
        "name": "rootCause",
        "optional": true,
        "defaultRaw": null,
        "defaultValue": "null"
      }
    ],
    "type": {
      "types": [
        "EventstoreError"
      ]
    }
  },
  {
    "__docId__": 76,
    "kind": "function",
    "name": "newWrongExpectedVersionError",
    "memberof": "src/errors/index.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/errors/index.ts~newWrongExpectedVersionError",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/errors/index.ts",
    "importStyle": "{newWrongExpectedVersionError}",
    "description": "Returns new EventstoreError type of EventstoreWrongExpectedVersionError",
    "lineNumber": 76,
    "params": [
      {
        "types": [],
        "name": "message"
      },
      {
        "types": [
          "Error",
          "null"
        ],
        "name": "rootCause",
        "optional": true,
        "defaultRaw": null,
        "defaultValue": "null"
      }
    ],
    "type": {
      "types": [
        "EventstoreError"
      ]
    }
  },
  {
    "__docId__": 77,
    "kind": "function",
    "name": "newStreamDeletedError",
    "memberof": "src/errors/index.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/errors/index.ts~newStreamDeletedError",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/errors/index.ts",
    "importStyle": "{newStreamDeletedError}",
    "description": "Returns new EventstoreError type of EventstoreStreamDeletedError",
    "lineNumber": 90,
    "params": [
      {
        "types": [],
        "name": "message"
      },
      {
        "types": [
          "Error",
          "null"
        ],
        "name": "rootCause",
        "optional": true,
        "defaultRaw": null,
        "defaultValue": "null"
      }
    ],
    "type": {
      "types": [
        "EventstoreError"
      ]
    }
  },
  {
    "__docId__": 78,
    "kind": "function",
    "name": "newInvalidTransactionError",
    "memberof": "src/errors/index.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/errors/index.ts~newInvalidTransactionError",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/errors/index.ts",
    "importStyle": "{newInvalidTransactionError}",
    "description": "Returns new EventstoreError type of EventstoreInvalidTransactionError",
    "lineNumber": 97,
    "params": [
      {
        "types": [],
        "name": "message"
      },
      {
        "types": [
          "Error",
          "null"
        ],
        "name": "rootCause",
        "optional": true,
        "defaultRaw": null,
        "defaultValue": "null"
      }
    ],
    "type": {
      "types": [
        "EventstoreError"
      ]
    }
  },
  {
    "__docId__": 79,
    "kind": "function",
    "name": "newAccessDeniedError",
    "memberof": "src/errors/index.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/errors/index.ts~newAccessDeniedError",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/errors/index.ts",
    "importStyle": "{newAccessDeniedError}",
    "description": "Returns new EventstoreError type of EventstoreAccessDeniedError",
    "lineNumber": 111,
    "params": [
      {
        "types": [],
        "name": "message"
      },
      {
        "types": [
          "Error",
          "null"
        ],
        "name": "rootCause",
        "optional": true,
        "defaultRaw": null,
        "defaultValue": "null"
      }
    ],
    "type": {
      "types": [
        "EventstoreError"
      ]
    }
  },
  {
    "__docId__": 80,
    "kind": "function",
    "name": "newNotFoundError",
    "memberof": "src/errors/index.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/errors/index.ts~newNotFoundError",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/errors/index.ts",
    "importStyle": "{newNotFoundError}",
    "description": "Returns new EventstoreError type of EventstoreNotFoundError",
    "lineNumber": 118,
    "params": [
      {
        "types": [],
        "name": "message"
      },
      {
        "types": [
          "Error",
          "null"
        ],
        "name": "rootCause",
        "optional": true,
        "defaultRaw": null,
        "defaultValue": "null"
      }
    ],
    "type": {
      "types": [
        "EventstoreError"
      ]
    }
  },
  {
    "__docId__": 81,
    "kind": "function",
    "name": "newNoStreamError",
    "memberof": "src/errors/index.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/errors/index.ts~newNoStreamError",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/errors/index.ts",
    "importStyle": "{newNoStreamError}",
    "description": "Returns new EventstoreError type of EventstoreNoStreamError",
    "lineNumber": 125,
    "params": [
      {
        "types": [],
        "name": "message"
      },
      {
        "types": [
          "Error",
          "null"
        ],
        "name": "rootCause",
        "optional": true,
        "defaultRaw": null,
        "defaultValue": "null"
      }
    ],
    "type": {
      "types": [
        "EventstoreError"
      ]
    }
  },
  {
    "__docId__": 82,
    "kind": "function",
    "name": "newNotModifiedError",
    "memberof": "src/errors/index.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/errors/index.ts~newNotModifiedError",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/errors/index.ts",
    "importStyle": "{newNotModifiedError}",
    "description": "Returns new EventstoreError type of EventstoreNotModifiedError",
    "lineNumber": 132,
    "params": [
      {
        "types": [],
        "name": "message"
      },
      {
        "types": [
          "Error",
          "null"
        ],
        "name": "rootCause",
        "optional": true,
        "defaultRaw": null,
        "defaultValue": "null"
      }
    ],
    "type": {
      "types": [
        "EventstoreError"
      ]
    }
  },
  {
    "__docId__": 83,
    "kind": "function",
    "name": "newUnspecificError",
    "memberof": "src/errors/index.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/errors/index.ts~newUnspecificError",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/errors/index.ts",
    "importStyle": "{newUnspecificError}",
    "description": "Returns new EventstoreError type of EventstoreUnspecificError",
    "lineNumber": 139,
    "params": [
      {
        "types": [
          "string"
        ],
        "name": "message",
        "optional": true,
        "defaultRaw": "",
        "defaultValue": ""
      },
      {
        "types": [
          "Error",
          "null"
        ],
        "name": "rootCause",
        "optional": true,
        "defaultRaw": null,
        "defaultValue": "null"
      }
    ],
    "type": {
      "types": [
        "EventstoreError"
      ]
    }
  },
  {
    "__docId__": 84,
    "kind": "function",
    "name": "newDoesNotExistError",
    "memberof": "src/errors/index.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/errors/index.ts~newDoesNotExistError",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/errors/index.ts",
    "importStyle": "{newDoesNotExistError}",
    "description": "Returns new EventstoreError type of EventstoreDoesNotExistError",
    "lineNumber": 164,
    "params": [
      {
        "types": [
          "string"
        ],
        "name": "message",
        "optional": true,
        "defaultRaw": "Does not exist",
        "defaultValue": "Does not exist"
      },
      {
        "types": [
          "Error",
          "null"
        ],
        "name": "rootCause",
        "optional": true,
        "defaultRaw": null,
        "defaultValue": "null"
      }
    ],
    "type": {
      "types": [
        "EventstoreError"
      ]
    }
  },
  {
    "__docId__": 85,
    "kind": "function",
    "name": "newAlreadyExistError",
    "memberof": "src/errors/index.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/errors/index.ts~newAlreadyExistError",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/errors/index.ts",
    "importStyle": "{newAlreadyExistError}",
    "description": "Returns new EventstoreError type of EventstoreAlreadyExistError",
    "lineNumber": 174,
    "params": [
      {
        "types": [
          "string"
        ],
        "name": "message",
        "optional": true,
        "defaultRaw": "Already exists",
        "defaultValue": "Already exists"
      },
      {
        "types": [
          "Error",
          "null"
        ],
        "name": "rootCause",
        "optional": true,
        "defaultRaw": null,
        "defaultValue": "null"
      }
    ],
    "type": {
      "types": [
        "EventstoreError"
      ]
    }
  },
  {
    "__docId__": 86,
    "kind": "function",
    "name": "newImplementationError",
    "memberof": "src/errors/index.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/errors/index.ts~newImplementationError",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/errors/index.ts",
    "importStyle": "{newImplementationError}",
    "description": "Returns new EventstoreError type of EventstoreImplementationError",
    "lineNumber": 150,
    "params": [
      {
        "types": [
          "string"
        ],
        "name": "message",
        "optional": true,
        "defaultRaw": "",
        "defaultValue": ""
      },
      {
        "types": [
          "Error",
          "null"
        ],
        "name": "rootCause",
        "optional": true,
        "defaultRaw": null,
        "defaultValue": "null"
      }
    ],
    "type": {
      "types": [
        "EventstoreError"
      ]
    }
  },
  {
    "__docId__": 87,
    "kind": "function",
    "name": "newTimeoutError",
    "memberof": "src/errors/index.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/errors/index.ts~newTimeoutError",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/errors/index.ts",
    "importStyle": "{newTimeoutError}",
    "description": "Returns new EventstoreError type of EventstoreTimeoutError",
    "lineNumber": 184,
    "params": [
      {
        "types": [
          "string"
        ],
        "name": "message",
        "optional": true,
        "defaultRaw": "",
        "defaultValue": ""
      },
      {
        "types": [
          "Error",
          "null"
        ],
        "name": "rootCause",
        "optional": true,
        "defaultRaw": null,
        "defaultValue": "null"
      }
    ],
    "type": {
      "types": [
        "EventstoreError"
      ]
    }
  },
  {
    "__docId__": 88,
    "kind": "function",
    "name": "newOperationError",
    "memberof": "src/errors/index.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/errors/index.ts~newOperationError",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/errors/index.ts",
    "importStyle": "{newOperationError}",
    "description": "Returns new EventstoreError type of EventstoreOperationError",
    "lineNumber": 191,
    "params": [
      {
        "types": [
          "string"
        ],
        "name": "message",
        "optional": true,
        "defaultRaw": "",
        "defaultValue": ""
      },
      {
        "types": [
          "Error",
          "null"
        ],
        "name": "rootCause",
        "optional": true,
        "defaultRaw": null,
        "defaultValue": "null"
      }
    ],
    "type": {
      "types": [
        "EventstoreError"
      ]
    }
  },
  {
    "__docId__": 89,
    "kind": "file",
    "name": "src/event/Event.ts",
    "content": "import Long from 'long'\nimport uuid = require('uuid/v4')\nimport {uuidFromBuffer, uuidToBuffer} from '../protobuf/uuidBufferConvert'\nimport * as eventstoreError from '../errors'\nimport * as model from '../protobuf/model'\nimport {JSONValue} from '../JSON'\n\n/** protobuf shorthand */\nconst protobuf = model.eventstore.proto\n\n/**\n * Represents a single event\n *\n * @export\n * @class Event\n */\nexport class Event {\n  /** streamId */\n  public streamId: string | null = null\n  /** event number in stream */\n  public eventNumber: Long | number | null = null\n  /** unique event uuid4 */\n  protected eventId: string = uuid()\n  /** event type = name of event */\n  protected eventType: string\n  /** flag if data is type of json */\n  protected dataContentType: number = 1\n  /** flag if metadata is type of json */\n  protected metadataContentType: number = 1\n  /** raw buffer representation of data */\n  public rawData: Uint8Array | null = null\n  /** raw buffer representation of metadata */\n  public rawMetadata: Uint8Array | null = null\n  /** js object  representation of data */\n  protected objectData: {[k: string]: JSONValue} | null = null\n  /** js object  representation of metadata */\n  protected objectMetadata:\n    | {\n        $correlationId?: string\n      } & {[k: string]: JSONValue}\n    | null = null\n  /** creation date as timestamp */\n  protected objectCreated: number | Long | null = null\n  /** creation date as timestamp */\n  protected objectCreatedEpoch: number | Long | null = null\n  /** events correlation uuid4 */\n  protected objectCorrelationId: string | null = null\n\n  /** indicates if event was written to eventstore */\n  protected frozen: boolean = false\n  /** indicates if its an event or a link which must be resolved */\n  protected isResolved = true\n\n  /**\n   * Creates an instance of Event.\n   */\n  public constructor(eventType: string, data?: {}, metadata?: {}) {\n    this.eventType = eventType\n    this.objectData = data ? data : null\n    this.objectMetadata = metadata ? metadata : null\n  }\n\n  /**\n   * Freezes event instance.\n   * Done when this event is already stored at eventstore.\n   */\n  public freeze(): void {\n    this.frozen = true\n    Object.freeze(this.objectData)\n    Object.freeze(this.objectMetadata)\n  }\n\n  /**\n   * Returns true if event is not stored at eventstore and false if event was written to eventstore\n   */\n  public isNew(): boolean {\n    return !this.frozen\n  }\n\n  /**\n   * Helper function to throw while changing an event which is already stored in eventstore\n   */\n  protected throwIfNotNewEvent(fieldName: string): void {\n    if (this.frozen) {\n      throw eventstoreError.newOperationError(\n        `Changing of ${fieldName} is not allowed for stored events`\n      )\n    }\n  }\n\n  /**\n   * Setter for event id\n   */\n  public set id(newId: string) {\n    this.throwIfNotNewEvent('eventId')\n    this.eventId = newId\n  }\n\n  /**\n   * Getter for event id\n   */\n  public get id(): string {\n    return this.eventId\n  }\n\n  /**\n   * Returns true if event is a link and not a full resolved event\n   */\n  public isLink(): boolean {\n    return !this.isResolved\n  }\n\n  /**\n   * Getter for event data\n   */\n  public get data(): {[k: string]: JSONValue} | string {\n    if (this.objectData) {\n      return this.objectData\n    }\n    if (this.rawData && !this.isLink()) {\n      this.objectData = JSON.parse(Buffer.from(this.rawData).toString())\n    } else if (this.rawData && this.isLink()) {\n      return Buffer.from(this.rawData).toString()\n    }\n    return this.objectData || {}\n  }\n\n  /**\n   * Sets data\n   */\n  public set data(newData: {[k: string]: JSONValue} | string) {\n    this.throwIfNotNewEvent('eventData')\n    //add as new object to prevent unwanted changes\n    this.objectData = typeof newData === 'string' ? JSON.parse(newData) : {...newData}\n  }\n\n  /**\n   * Getter for event metadata\n   */\n  public get metadata(): {$correlationId?: string} & {[k: string]: JSONValue} | null | string {\n    if (this.objectMetadata) {\n      return this.objectMetadata\n    }\n    if (this.rawMetadata) {\n      this.objectMetadata = JSON.parse(Buffer.from(this.rawMetadata).toString())\n    }\n    return this.objectMetadata\n  }\n\n  /**\n   * Setter for event metadata\n   */\n  public set metadata(\n    newMetadata: {$correlationId?: string} & {[k: string]: JSONValue} | null | string\n  ) {\n    this.throwIfNotNewEvent('eventMetadata')\n    //add as new object to prevent unwanted changes\n    this.objectMetadata =\n      typeof newMetadata === 'string' ? JSON.parse(newMetadata) : {...newMetadata}\n  }\n\n  /**\n   * Setter for event correlationId\n   */\n  public set correlationId(newCorrelationId: string | null) {\n    this.throwIfNotNewEvent('correlationId')\n    if (!newCorrelationId) {\n      this.objectCorrelationId = newCorrelationId\n      if (this.objectMetadata && this.objectMetadata.$correlationId) {\n        delete this.objectMetadata.$correlationId\n      }\n      return\n    }\n    this.objectCorrelationId = newCorrelationId\n    if (this.metadata && typeof this.metadata !== 'string' && this.metadata.$correlationId) {\n      this.metadata.$correlationId = this.objectCorrelationId\n    } else {\n      this.metadata = {$correlationId: this.objectCorrelationId}\n    }\n  }\n\n  /**\n   * Getter for event correlationId\n   */\n  public get correlationId(): string | null {\n    if (this.metadata && typeof this.metadata !== 'string') {\n      this.objectCorrelationId = this.metadata.$correlationId || null\n    }\n    return this.objectCorrelationId\n  }\n\n  /**\n   * Returns a new instance of Event from protobuf result\n   */\n  public static fromRaw(rawEvent: model.eventstore.proto.IEventRecord | null | undefined): Event {\n    if (!rawEvent) {\n      throw eventstoreError.newProtocolError('No event or link was given at Event.fromRaw')\n    }\n    const event = new Event(rawEvent.eventType)\n    if (rawEvent.eventType === '$>' || rawEvent.eventType === '$@') {\n      //is linked event\n      event.isResolved = false\n    }\n    event.streamId = rawEvent.eventStreamId\n    event.eventNumber = rawEvent.eventNumber\n    event.eventId = uuidFromBuffer(Buffer.from(rawEvent.eventId))\n    event.dataContentType = rawEvent.dataContentType\n    event.rawData = rawEvent.data\n    event.rawMetadata = rawEvent.metadata || null\n    event.metadataContentType = rawEvent.metadataContentType\n    event.objectCreated = rawEvent.created ? rawEvent.created : null\n    event.objectCreatedEpoch = rawEvent.createdEpoch ? rawEvent.createdEpoch : null\n    event.freeze()\n    return event\n  }\n\n  /**\n   * Returns protobuf representation of this event\n   */\n  public toRaw(): model.eventstore.proto.NewEvent {\n    const newEvent = {\n      eventId: uuidToBuffer(this.eventId),\n      eventType: this.eventType,\n      data: Buffer.from(JSON.stringify(this.data)),\n      metadata: this.metadata ? Buffer.from(JSON.stringify(this.metadata)) : null\n    }\n    return protobuf.NewEvent.fromObject(newEvent)\n  }\n\n  /**\n   * Setter for name\n   */\n  public set name(newName: string) {\n    this.throwIfNotNewEvent('name')\n    this.eventType = newName\n  }\n\n  /**\n   * Getter for event name\n   */\n  public get name(): string {\n    return this.eventType\n  }\n}\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/src/event/Event.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 90,
    "kind": "variable",
    "name": "protobuf",
    "memberof": "src/event/Event.ts",
    "static": true,
    "longname": "src/event/Event.ts~protobuf",
    "access": "public",
    "export": false,
    "importPath": "eventstore-ts-client/src/event/Event.ts",
    "importStyle": null,
    "description": "protobuf shorthand",
    "lineNumber": 9,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 91,
    "kind": "class",
    "name": "Event",
    "memberof": "src/event/Event.ts",
    "static": true,
    "longname": "src/event/Event.ts~Event",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/event/Event.ts",
    "importStyle": "{Event}",
    "description": "Represents a single event",
    "lineNumber": 17,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "Event"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 92,
    "kind": "member",
    "name": "streamId",
    "memberof": "src/event/Event.ts~Event",
    "static": false,
    "longname": "src/event/Event.ts~Event#streamId",
    "access": "public",
    "description": "streamId",
    "lineNumber": 19,
    "type": {
      "types": [
        "string",
        "null"
      ]
    }
  },
  {
    "__docId__": 93,
    "kind": "member",
    "name": "eventNumber",
    "memberof": "src/event/Event.ts~Event",
    "static": false,
    "longname": "src/event/Event.ts~Event#eventNumber",
    "access": "public",
    "description": "event number in stream",
    "lineNumber": 21,
    "type": {
      "types": [
        "Long",
        "number",
        "null"
      ]
    }
  },
  {
    "__docId__": 94,
    "kind": "member",
    "name": "eventId",
    "memberof": "src/event/Event.ts~Event",
    "static": false,
    "longname": "src/event/Event.ts~Event#eventId",
    "access": "protected",
    "description": "unique event uuid4",
    "lineNumber": 23,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 95,
    "kind": "member",
    "name": "eventType",
    "memberof": "src/event/Event.ts~Event",
    "static": false,
    "longname": "src/event/Event.ts~Event#eventType",
    "access": "protected",
    "description": "event type = name of event",
    "lineNumber": 25,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 96,
    "kind": "member",
    "name": "dataContentType",
    "memberof": "src/event/Event.ts~Event",
    "static": false,
    "longname": "src/event/Event.ts~Event#dataContentType",
    "access": "protected",
    "description": "flag if data is type of json",
    "lineNumber": 27,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 97,
    "kind": "member",
    "name": "metadataContentType",
    "memberof": "src/event/Event.ts~Event",
    "static": false,
    "longname": "src/event/Event.ts~Event#metadataContentType",
    "access": "protected",
    "description": "flag if metadata is type of json",
    "lineNumber": 29,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 98,
    "kind": "member",
    "name": "rawData",
    "memberof": "src/event/Event.ts~Event",
    "static": false,
    "longname": "src/event/Event.ts~Event#rawData",
    "access": "public",
    "description": "raw buffer representation of data",
    "lineNumber": 31,
    "type": {
      "types": [
        "Uint8Array",
        "null"
      ]
    }
  },
  {
    "__docId__": 99,
    "kind": "member",
    "name": "rawMetadata",
    "memberof": "src/event/Event.ts~Event",
    "static": false,
    "longname": "src/event/Event.ts~Event#rawMetadata",
    "access": "public",
    "description": "raw buffer representation of metadata",
    "lineNumber": 33,
    "type": {
      "types": [
        "Uint8Array",
        "null"
      ]
    }
  },
  {
    "__docId__": 100,
    "kind": "member",
    "name": "objectData",
    "memberof": "src/event/Event.ts~Event",
    "static": false,
    "longname": "src/event/Event.ts~Event#objectData",
    "access": "protected",
    "description": "js object  representation of data",
    "lineNumber": 35,
    "type": {
      "types": [
        null,
        "null"
      ]
    }
  },
  {
    "__docId__": 101,
    "kind": "member",
    "name": "objectMetadata",
    "memberof": "src/event/Event.ts~Event",
    "static": false,
    "longname": "src/event/Event.ts~Event#objectMetadata",
    "access": "protected",
    "description": "js object  representation of metadata",
    "lineNumber": 37,
    "type": {
      "types": [
        null,
        "null"
      ]
    }
  },
  {
    "__docId__": 102,
    "kind": "member",
    "name": "objectCreated",
    "memberof": "src/event/Event.ts~Event",
    "static": false,
    "longname": "src/event/Event.ts~Event#objectCreated",
    "access": "protected",
    "description": "creation date as timestamp",
    "lineNumber": 43,
    "type": {
      "types": [
        "number",
        "Long",
        "null"
      ]
    }
  },
  {
    "__docId__": 103,
    "kind": "member",
    "name": "objectCreatedEpoch",
    "memberof": "src/event/Event.ts~Event",
    "static": false,
    "longname": "src/event/Event.ts~Event#objectCreatedEpoch",
    "access": "protected",
    "description": "creation date as timestamp",
    "lineNumber": 45,
    "type": {
      "types": [
        "number",
        "Long",
        "null"
      ]
    }
  },
  {
    "__docId__": 104,
    "kind": "member",
    "name": "objectCorrelationId",
    "memberof": "src/event/Event.ts~Event",
    "static": false,
    "longname": "src/event/Event.ts~Event#objectCorrelationId",
    "access": "protected",
    "description": "events correlation uuid4",
    "lineNumber": 47,
    "type": {
      "types": [
        "string",
        "null"
      ]
    }
  },
  {
    "__docId__": 105,
    "kind": "member",
    "name": "frozen",
    "memberof": "src/event/Event.ts~Event",
    "static": false,
    "longname": "src/event/Event.ts~Event#frozen",
    "access": "protected",
    "description": "indicates if event was written to eventstore",
    "lineNumber": 50,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 106,
    "kind": "member",
    "name": "isResolved",
    "memberof": "src/event/Event.ts~Event",
    "static": false,
    "longname": "src/event/Event.ts~Event#isResolved",
    "access": "protected",
    "description": "indicates if its an event or a link which must be resolved",
    "lineNumber": 52,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 107,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/event/Event.ts~Event",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/event/Event.ts~Event#constructor",
    "access": "public",
    "description": "Creates an instance of Event.",
    "lineNumber": 57
  },
  {
    "__docId__": 111,
    "kind": "method",
    "name": "freeze",
    "memberof": "src/event/Event.ts~Event",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/event/Event.ts~Event#freeze",
    "access": "public",
    "description": "Freezes event instance.\nDone when this event is already stored at eventstore.",
    "lineNumber": 67,
    "params": [],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 113,
    "kind": "method",
    "name": "isNew",
    "memberof": "src/event/Event.ts~Event",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/event/Event.ts~Event#isNew",
    "access": "public",
    "description": "Returns true if event is not stored at eventstore and false if event was written to eventstore",
    "lineNumber": 76,
    "params": [],
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 114,
    "kind": "method",
    "name": "throwIfNotNewEvent",
    "memberof": "src/event/Event.ts~Event",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/event/Event.ts~Event#throwIfNotNewEvent",
    "access": "protected",
    "description": "Helper function to throw while changing an event which is already stored in eventstore",
    "lineNumber": 83,
    "params": [
      {
        "types": [],
        "name": "fieldName"
      }
    ],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 115,
    "kind": "set",
    "name": "id",
    "memberof": "src/event/Event.ts~Event",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/event/Event.ts~Event#id",
    "access": "public",
    "description": "Setter for event id",
    "lineNumber": 94,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 117,
    "kind": "get",
    "name": "id",
    "memberof": "src/event/Event.ts~Event",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/event/Event.ts~Event#id",
    "access": "public",
    "description": "Getter for event id",
    "lineNumber": 102,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 118,
    "kind": "method",
    "name": "isLink",
    "memberof": "src/event/Event.ts~Event",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/event/Event.ts~Event#isLink",
    "access": "public",
    "description": "Returns true if event is a link and not a full resolved event",
    "lineNumber": 109,
    "params": [],
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 119,
    "kind": "get",
    "name": "data",
    "memberof": "src/event/Event.ts~Event",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/event/Event.ts~Event#data",
    "access": "public",
    "description": "Getter for event data",
    "lineNumber": 116,
    "type": {
      "types": [
        null,
        "string"
      ]
    }
  },
  {
    "__docId__": 121,
    "kind": "set",
    "name": "data",
    "memberof": "src/event/Event.ts~Event",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/event/Event.ts~Event#data",
    "access": "public",
    "description": "Sets data",
    "lineNumber": 131,
    "type": {
      "types": [
        null,
        "string"
      ]
    }
  },
  {
    "__docId__": 123,
    "kind": "get",
    "name": "metadata",
    "memberof": "src/event/Event.ts~Event",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/event/Event.ts~Event#metadata",
    "access": "public",
    "description": "Getter for event metadata",
    "lineNumber": 140,
    "type": {
      "types": [
        null,
        "null",
        "string"
      ]
    }
  },
  {
    "__docId__": 125,
    "kind": "set",
    "name": "metadata",
    "memberof": "src/event/Event.ts~Event",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/event/Event.ts~Event#metadata",
    "access": "public",
    "description": "Setter for event metadata",
    "lineNumber": 153,
    "type": {
      "types": [
        null,
        "null",
        "string"
      ]
    }
  },
  {
    "__docId__": 127,
    "kind": "set",
    "name": "correlationId",
    "memberof": "src/event/Event.ts~Event",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/event/Event.ts~Event#correlationId",
    "access": "public",
    "description": "Setter for event correlationId",
    "lineNumber": 165,
    "type": {
      "types": [
        "string",
        "null"
      ]
    }
  },
  {
    "__docId__": 131,
    "kind": "get",
    "name": "correlationId",
    "memberof": "src/event/Event.ts~Event",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/event/Event.ts~Event#correlationId",
    "access": "public",
    "description": "Getter for event correlationId",
    "lineNumber": 185,
    "type": {
      "types": [
        "string",
        "null"
      ]
    }
  },
  {
    "__docId__": 133,
    "kind": "method",
    "name": "fromRaw",
    "memberof": "src/event/Event.ts~Event",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/event/Event.ts~Event.fromRaw",
    "access": "public",
    "description": "Returns a new instance of Event from protobuf result",
    "lineNumber": 195,
    "params": [
      {
        "types": [
          "null",
          "undefined"
        ],
        "name": "rawEvent"
      }
    ],
    "type": {
      "types": [
        "Event"
      ]
    }
  },
  {
    "__docId__": 134,
    "kind": "method",
    "name": "toRaw",
    "memberof": "src/event/Event.ts~Event",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/event/Event.ts~Event#toRaw",
    "access": "public",
    "description": "Returns protobuf representation of this event",
    "lineNumber": 220,
    "params": [],
    "type": {
      "types": [
        null
      ]
    }
  },
  {
    "__docId__": 135,
    "kind": "set",
    "name": "name",
    "memberof": "src/event/Event.ts~Event",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/event/Event.ts~Event#name",
    "access": "public",
    "description": "Setter for name",
    "lineNumber": 233,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 137,
    "kind": "get",
    "name": "name",
    "memberof": "src/event/Event.ts~Event",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/event/Event.ts~Event#name",
    "access": "public",
    "description": "Getter for event name",
    "lineNumber": 241,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 138,
    "kind": "file",
    "name": "src/event/index.ts",
    "content": "export {Event} from './Event'\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/src/event/index.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 139,
    "kind": "file",
    "name": "src/eventstore/Eventstore.ts",
    "content": "import {setConnectionSettings, EventstoreSettings, UserCredentials} from './EventstoreSettings'\nimport {EventEmitter} from 'events'\nimport {Stream, StreamOptions, StreamPosition} from '../stream'\nimport * as bunyan from 'bunyan'\nimport {TCPConnection} from './TCPConnection'\nimport uuid = require('uuid/v4')\nimport Long = require('long')\nimport {EventstoreCommand} from '../protobuf/EventstoreCommand'\nimport * as model from '../protobuf/model'\nimport {Position} from './Position'\nimport {StreamWalker} from '../StreamWalker'\nimport {Event} from '../event'\nimport * as eventstoreErrors from '../errors'\n\n/** protobuf shorthand */\nconst protobuf = model.eventstore.proto\n\n/**\n * @typedef {object} WriteResult\n * @property {Long | number} firstEventNumber\n * @property {Long | number} lastEventNumber\n * @property {Position} position\n */\nexport interface WriteResult {\n  firstEventNumber: Long | number\n  lastEventNumber: Long | number\n  position: Position\n}\n\n/**\n * Base class to communicate with eventstore\n * @emits{connected} emitted as soon as connection is established\n * @emits{secureConnect} emitted when connection is secured connected\n * @emits{ready} emitted after connected after authentication and identify client\n * @emits{reconnect} emitted as soon as lib tries to reconnect (param: reconnect count)\n * @emits{close} emitted as soon as connection is closed\n * @emits{drain} emitted when connection drains existing requests before connection close\n * @emits{error} emitted on connection errors (param: error)\n */\nexport class Eventstore extends EventEmitter {\n  /** connection config */\n  protected connectionConfig: EventstoreSettings\n  /** logger */\n  public log: bunyan\n  /** connection base */\n  protected connection: TCPConnection\n  /** default read slice size */\n  protected defaultSliceSize: number = 100\n\n  /**\n   * Creates an instance of Eventstore.\n   */\n  public constructor(connectionConfiguration: EventstoreSettings | object = {}) {\n    super()\n    this.connectionConfig = setConnectionSettings(connectionConfiguration)\n    this.log = this.connectionConfig.logger\n    this.connection = new TCPConnection({...this.connectionConfig})\n\n    this.on(\n      'error',\n      (err): void => {\n        //prevent throwing error\n        this.log.error({err}, 'Eventstore error')\n      }\n    )\n  }\n\n  /**\n   * Ensure to use up-to-date settings, logger and a fresh connection socket\n   */\n  protected init(connectionConfiguration: EventstoreSettings | {} = {}): void {\n    this.connectionConfig = {...this.connectionConfig, ...connectionConfiguration}\n    this.log = this.connectionConfig.logger\n    this.connection = new TCPConnection(this.connectionConfig)\n    this.connection.on(\n      'error',\n      (err): void => {\n        this.log.error({err}, err.name)\n        this.emit('error', err)\n      }\n    )\n    this.connection.on(\n      'secureConnect',\n      (): void => {\n        this.log.debug('secure connected')\n        this.emit('secureConnect')\n      }\n    )\n    this.connection.on(\n      'drain',\n      (): void => {\n        this.log.debug('connection is draining')\n        this.emit('drain')\n      }\n    )\n    this.connection.on(\n      'close',\n      (): void => {\n        this.log.debug('connection is closed')\n        this.emit('close')\n      }\n    )\n    this.connection.on(\n      'connected',\n      (): void => {\n        this.log.debug('connected to eventstore')\n        this.emit('connected')\n      }\n    )\n    this.connection.on(\n      'reconnect',\n      (reconnectCount: number): void => {\n        this.log.debug({reconnectCount}, 'reconnecting to eventstore')\n        this.emit('reconnect', reconnectCount)\n      }\n    )\n  }\n\n  /**\n   * Returns client id - name of eventstore connection\n   */\n  public get name(): string {\n    return this.connectionConfig.clientId\n  }\n\n  /**\n   * Connect to eventstore\n   */\n  public async connect(connectionConfiguration: EventstoreSettings | object = {}): Promise<void> {\n    this.init(connectionConfiguration)\n    await this.connection.connect()\n\n    try {\n      await this.authenticate()\n      await this.identifyClient()\n      this.log.debug('connection ready')\n      this.emit('ready')\n    } catch (err) {\n      await this.disconnect()\n      throw err\n    }\n  }\n\n  /**\n   * Disconnect from eventstore and try to drain pending requests\n   */\n  public disconnect(): Promise<void> {\n    return this.connection.disconnect()\n  }\n\n  /**\n   * Indicates if connection to eventstore is available\n   */\n  public get isConnected(): boolean {\n    return this.connection.isConnected\n  }\n\n  /**\n   * Returns current connection\n   */\n  public getConnection(): TCPConnection {\n    return this.connection\n  }\n\n  /**\n   * Get current logger instance\n   */\n  public get logger(): bunyan {\n    return this.log\n  }\n\n  /**\n   * Set logger instance\n   */\n  public set logger(newLogger: bunyan) {\n    this.connectionConfig.logger = newLogger\n  }\n\n  /**\n   * Get a stream instance specified by streamName\n   * You can also use one of the alias functions fromStream or atStream\n   */\n  public stream(streamName: string, streamOptions?: StreamOptions): Stream {\n    const defaultOptions: StreamOptions = {\n      requireMaster: false,\n      resolveLinks: true,\n      credentials: null\n    }\n    return new Stream(this, streamName, {...defaultOptions, ...streamOptions})\n  }\n\n  /**\n   * Get a stream instance specified by streamName\n   * Alias for method stream\n   */\n  public fromStream(streamName: string, streamOptions?: StreamOptions): Stream {\n    return this.stream(streamName, streamOptions)\n  }\n\n  /**\n   * Get a stream instance specified by streamName\n   * Alias for method stream\n   */\n  public atStream(streamName: string, streamOptions?: StreamOptions): Stream {\n    return this.stream(streamName, streamOptions)\n  }\n\n  /**\n   * Ping eventstore\n   */\n  public async ping(): Promise<void> {\n    await new Promise(\n      (resolve, reject): void => {\n        this.connection.sendCommand(\n          uuid(),\n          EventstoreCommand.Ping,\n          null,\n          this.connectionConfig.credentials,\n          {\n            resolve,\n            reject\n          }\n        )\n      }\n    )\n  }\n\n  /**\n   * Called directly after connecting to eventstore\n   * Identifies connection against eventstore\n   * Identification can be set in connection settings field clientId\n   */\n  protected async identifyClient(): Promise<void> {\n    await new Promise(\n      (resolve, reject): void => {\n        this.log.debug(`Identify as ${this.connectionConfig.clientId}`)\n        const raw = protobuf.IdentifyClient.fromObject({\n          version: 1,\n          connectionName: this.connectionConfig.clientId\n        })\n        this.connection.sendCommand(\n          uuid(),\n          EventstoreCommand.IdentifyClient,\n          Buffer.from(protobuf.IdentifyClient.encode(raw).finish()),\n          this.connectionConfig.credentials,\n          {\n            resolve,\n            reject\n          }\n        )\n      }\n    )\n  }\n\n  /**\n   * Authenticate with credentials from settings\n   */\n  protected async authenticate(): Promise<void> {\n    await new Promise(\n      (resolve, reject): void => {\n        this.log.debug(`Authenticate`)\n        this.connection.sendCommand(\n          uuid(),\n          EventstoreCommand.Authenticate,\n          null,\n          this.connectionConfig.credentials,\n          {\n            resolve,\n            reject\n          }\n        )\n      }\n    )\n  }\n\n  /**\n   * Reads a slice of events from current stream\n   */\n  protected async readSlice(\n    direction: EventstoreCommand,\n    position: Position,\n    maxSliceCount: number,\n    resolveLinks: boolean,\n    requireMaster: boolean,\n    credentials: UserCredentials | null\n  ): Promise<model.eventstore.proto.ReadAllEventsCompleted> {\n    return await new Promise(\n      (resolve, reject): void => {\n        const raw = protobuf.ReadAllEvents.fromObject({\n          commitPosition: position.commitPosition,\n          preparePosition: position.preparePosition,\n          maxCount: maxSliceCount,\n          resolveLinks,\n          requireMaster\n        })\n        this.connection.sendCommand(\n          uuid(),\n          direction,\n          Buffer.from(protobuf.ReadAllEvents.encode(raw).finish()),\n          credentials,\n          {\n            resolve,\n            reject\n          }\n        )\n      }\n    )\n  }\n\n  /**\n   * Reads a slice from current stream in forward direction\n   */\n  public async readSliceForward(\n    position: Position,\n    maxSliceCount?: number,\n    resolveLinks: boolean = true,\n    requireMaster?: boolean,\n    credentials?: UserCredentials | null\n  ): Promise<model.eventstore.proto.ReadAllEventsCompleted> {\n    if (maxSliceCount === undefined) {\n      maxSliceCount = this.defaultSliceSize\n    }\n    return await this.readSlice(\n      EventstoreCommand.ReadAllEventsForward,\n      position,\n      maxSliceCount,\n      resolveLinks,\n      requireMaster || this.connectionConfig.requireMaster,\n      credentials || this.connectionConfig.credentials\n    )\n  }\n\n  /**\n   * Reads a slice from current stream in backward direction\n   */\n  public async readSliceBackward(\n    position: Position,\n    maxSliceCount?: number,\n    resolveLinks: boolean = true,\n    requireMaster?: boolean,\n    credentials?: UserCredentials | null\n  ): Promise<model.eventstore.proto.ReadAllEventsCompleted> {\n    if (maxSliceCount === undefined) {\n      maxSliceCount = this.defaultSliceSize\n    }\n    return await this.readSlice(\n      EventstoreCommand.ReadAllEventsBackward,\n      position,\n      maxSliceCount,\n      resolveLinks,\n      requireMaster || this.connectionConfig.requireMaster,\n      credentials || this.connectionConfig.credentials\n    )\n  }\n\n  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\n  /**\n   * Walks all events forward\n   */\n  public async walkAllForward(\n    start: Position = Position.Start,\n    resolveLinks: boolean = true,\n    requireMaster?: boolean,\n    credentials?: UserCredentials | null\n  ): Promise<StreamWalker> {\n    const that = this\n    if (requireMaster === undefined) {\n      requireMaster = this.connectionConfig.requireMaster\n    }\n    if (credentials === undefined) {\n      credentials = this.connectionConfig.credentials\n    }\n    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\n    const asyncGenerator = async function*(begin: Position) {\n      let index = 0\n      //fetch first slice\n      let readResult = that.readSliceForward(\n        begin,\n        that.defaultSliceSize,\n        resolveLinks,\n        requireMaster,\n        credentials\n      )\n      let result = await readResult\n      let maxSlicePosition = new Position(result.commitPosition, result.preparePosition)\n      begin = new Position(result.nextCommitPosition, result.nextPreparePosition)\n      if (begin.compareTo(maxSlicePosition) >= 0) {\n        //we have more so start fetching in background\n        readResult = that.readSliceForward(\n          begin,\n          that.defaultSliceSize,\n          resolveLinks,\n          requireMaster,\n          credentials\n        )\n      }\n      while (true) {\n        if (index < result.events.length) {\n          const entry = result.events[index++]\n          yield Event.fromRaw(entry.event || entry.link)\n        } else if (begin.compareTo(maxSlicePosition) <= 0) {\n          return null\n        } else {\n          index = 0\n          //wait for background fetch and grab result\n          result = await readResult\n          maxSlicePosition = new Position(result.commitPosition, result.preparePosition)\n          begin = new Position(result.nextCommitPosition, result.nextPreparePosition)\n          if (begin.compareTo(maxSlicePosition) > 0) {\n            //if there are more events start fetching in background\n\n            readResult = that.readSliceForward(\n              begin,\n              that.defaultSliceSize,\n              resolveLinks,\n              requireMaster,\n              credentials\n            )\n          }\n        }\n      }\n    }\n\n    return new StreamWalker(asyncGenerator(start))\n  }\n\n  /**\n   * Walks all events backward\n   */\n  public async walkAllBackward(\n    start: Position = Position.End,\n    resolveLinks: boolean = true,\n    requireMaster?: boolean,\n    credentials?: UserCredentials | null\n  ): Promise<StreamWalker> {\n    const that = this\n    if (requireMaster === undefined) {\n      requireMaster = this.connectionConfig.requireMaster\n    }\n    if (credentials === undefined) {\n      credentials = this.connectionConfig.credentials\n    }\n    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\n    const asyncGenerator = async function*(begin: Position) {\n      let index = 0\n      //fetch first slice\n      let readResult = that.readSliceBackward(\n        begin,\n        that.defaultSliceSize,\n        resolveLinks,\n        requireMaster,\n        credentials\n      )\n      let result = await readResult\n\n      let maxSlicePosition = new Position(result.commitPosition, result.preparePosition)\n      begin = new Position(result.nextCommitPosition, result.nextPreparePosition)\n      if (begin.compareTo(maxSlicePosition) < 0) {\n        //we have more so start fetching in background\n        readResult = that.readSliceBackward(\n          begin,\n          that.defaultSliceSize,\n          resolveLinks,\n          requireMaster,\n          credentials\n        )\n      }\n      while (true) {\n        if (index < result.events.length) {\n          const entry = result.events[index++]\n          yield Event.fromRaw(entry.event || entry.link)\n        } else if (begin.compareTo(maxSlicePosition) >= 0) {\n          return null\n        } else {\n          index = 0\n          //wait for background fetch and grab result\n          result = await readResult\n          maxSlicePosition = new Position(result.commitPosition, result.preparePosition)\n          begin = new Position(result.nextCommitPosition, result.nextPreparePosition)\n          if (begin.compareTo(maxSlicePosition) < 0) {\n            //if there are more events start fetching in background\n\n            readResult = that.readSliceBackward(\n              begin,\n              that.defaultSliceSize,\n              resolveLinks,\n              requireMaster,\n              credentials\n            )\n          }\n        }\n      }\n    }\n\n    return new StreamWalker(asyncGenerator(start))\n  }\n\n  /** Resolves a link  */\n  public async resolveLink(\n    link: Event,\n    requireMaster?: boolean,\n    credentials?: UserCredentials | null\n  ): Promise<Event | null> {\n    if (!link.isLink()) {\n      return link\n    }\n\n    if (requireMaster === undefined) {\n      requireMaster = this.connectionConfig.requireMaster\n    }\n\n    if (typeof link.data !== 'string') {\n      throw eventstoreErrors.newProtocolError('Invalid link data')\n    }\n\n    const linkInfo = link.data.split('@')\n    let streamName = linkInfo[1]\n    let eventNumber = Long.fromValue(linkInfo[0])\n\n    const stream = this.stream(streamName)\n    if (stream.isMetaStream()) {\n      this.log.debug({streamName}, 'Getting specific event from meta is not supported')\n      return null\n    }\n    if (requireMaster) {\n      stream.requiresMaster()\n    }\n    if (credentials) {\n      stream.withCredentials(credentials)\n    }\n    const event = await stream.getEventByNumber(eventNumber)\n    if (!event) {\n      throw eventstoreErrors.newNotFoundError('Event could not be found')\n    }\n    return event\n  }\n\n  /**\n   * Get all events from given stream category\n   * (eventstore system projections must be enabled)\n   */\n  public async walkEventsByStreamCategory(\n    category: string,\n    start: Long | number = StreamPosition.Start,\n    resolveLinks: boolean = true,\n    requireMaster?: boolean,\n    credentials?: UserCredentials\n  ): Promise<StreamWalker> {\n    const stream = this.stream(`$ce-${category}`)\n    return stream.walkStreamForward(start, resolveLinks, requireMaster, credentials)\n  }\n\n  /**\n   * Get all events by event type (event name)\n   * (eventstore system projections must be enabled)\n   */\n  public async walkEventsByType(\n    eventType: string,\n    start: Long | number = StreamPosition.Start,\n    resolveLinks: boolean = true,\n    requireMaster?: boolean,\n    credentials?: UserCredentials\n  ): Promise<StreamWalker> {\n    const stream = this.stream(`$et-${eventType}`)\n    return stream.walkStreamForward(start, resolveLinks, requireMaster, credentials)\n  }\n\n  /**\n   * Get all events by correlation id\n   * (eventstore system projections must be enabled)\n   */\n  public async walkEventsByCorrelationId(\n    correlationId: string,\n    start: Long | number = StreamPosition.Start,\n    resolveLinks: boolean = true,\n    requireMaster?: boolean,\n    credentials?: UserCredentials\n  ): Promise<StreamWalker> {\n    const stream = this.stream(`$bc-${correlationId}`)\n\n    return stream.walkStreamForward(start, resolveLinks, requireMaster, credentials)\n  }\n\n  /**\n   * Get all stream names by stream category\n   * (eventstore system projections must be enabled)\n   */\n  public async streamNamesByCategory(\n    category: string,\n    start: Long | number = StreamPosition.Start,\n    requireMaster?: boolean,\n    credentials?: UserCredentials\n  ): Promise<StreamWalker> {\n    const stream = this.stream(`$category-${category}`)\n    return stream.walkStreamForward(start, false, requireMaster, credentials)\n  }\n}\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/src/eventstore/Eventstore.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 140,
    "kind": "variable",
    "name": "protobuf",
    "memberof": "src/eventstore/Eventstore.ts",
    "static": true,
    "longname": "src/eventstore/Eventstore.ts~protobuf",
    "access": "public",
    "export": false,
    "importPath": "eventstore-ts-client/src/eventstore/Eventstore.ts",
    "importStyle": null,
    "description": "protobuf shorthand",
    "lineNumber": 16,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 141,
    "kind": "typedef",
    "name": "WriteResult",
    "memberof": "src/eventstore/Eventstore.ts",
    "static": true,
    "longname": "src/eventstore/Eventstore.ts~WriteResult",
    "access": "public",
    "description": "",
    "lineNumber": 24,
    "properties": [
      {
        "nullable": null,
        "types": [
          "Long ",
          " number"
        ],
        "spread": false,
        "optional": false,
        "name": "firstEventNumber",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Long ",
          " number"
        ],
        "spread": false,
        "optional": false,
        "name": "lastEventNumber",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Position"
        ],
        "spread": false,
        "optional": false,
        "name": "position",
        "description": ""
      }
    ],
    "type": {
      "types": [
        "object"
      ],
      "optional": false,
      "name": "WriteResult"
    }
  },
  {
    "__docId__": 142,
    "kind": "class",
    "name": "Eventstore",
    "memberof": "src/eventstore/Eventstore.ts",
    "static": true,
    "longname": "src/eventstore/Eventstore.ts~Eventstore",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/eventstore/Eventstore.ts",
    "importStyle": "{Eventstore}",
    "description": "Base class to communicate with eventstore\n@emits{connected} emitted as soon as connection is established\n@emits{secureConnect} emitted when connection is secured connected\n@emits{ready} emitted after connected after authentication and identify client\n@emits{reconnect} emitted as soon as lib tries to reconnect (param: reconnect count)\n@emits{close} emitted as soon as connection is closed\n@emits{drain} emitted when connection drains existing requests before connection close\n@emits{error} emitted on connection errors (param: error)",
    "lineNumber": 40,
    "interface": false,
    "extends": [
      "events~EventEmitter"
    ]
  },
  {
    "__docId__": 143,
    "kind": "member",
    "name": "connectionConfig",
    "memberof": "src/eventstore/Eventstore.ts~Eventstore",
    "static": false,
    "longname": "src/eventstore/Eventstore.ts~Eventstore#connectionConfig",
    "access": "protected",
    "description": "connection config",
    "lineNumber": 42,
    "type": {
      "types": [
        "EventstoreSettings"
      ]
    }
  },
  {
    "__docId__": 144,
    "kind": "member",
    "name": "log",
    "memberof": "src/eventstore/Eventstore.ts~Eventstore",
    "static": false,
    "longname": "src/eventstore/Eventstore.ts~Eventstore#log",
    "access": "public",
    "description": "logger",
    "lineNumber": 44,
    "type": {
      "types": [
        "bunyan"
      ]
    }
  },
  {
    "__docId__": 145,
    "kind": "member",
    "name": "connection",
    "memberof": "src/eventstore/Eventstore.ts~Eventstore",
    "static": false,
    "longname": "src/eventstore/Eventstore.ts~Eventstore#connection",
    "access": "protected",
    "description": "connection base",
    "lineNumber": 46,
    "type": {
      "types": [
        "TCPConnection"
      ]
    }
  },
  {
    "__docId__": 146,
    "kind": "member",
    "name": "defaultSliceSize",
    "memberof": "src/eventstore/Eventstore.ts~Eventstore",
    "static": false,
    "longname": "src/eventstore/Eventstore.ts~Eventstore#defaultSliceSize",
    "access": "protected",
    "description": "default read slice size",
    "lineNumber": 48,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 147,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/eventstore/Eventstore.ts~Eventstore",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/Eventstore.ts~Eventstore#constructor",
    "access": "public",
    "description": "Creates an instance of Eventstore.",
    "lineNumber": 53
  },
  {
    "__docId__": 151,
    "kind": "method",
    "name": "init",
    "memberof": "src/eventstore/Eventstore.ts~Eventstore",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/Eventstore.ts~Eventstore#init",
    "access": "protected",
    "description": "Ensure to use up-to-date settings, logger and a fresh connection socket",
    "lineNumber": 71,
    "params": [
      {
        "types": [
          "{}"
        ],
        "name": "connectionConfiguration",
        "optional": true,
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 155,
    "kind": "get",
    "name": "name",
    "memberof": "src/eventstore/Eventstore.ts~Eventstore",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/Eventstore.ts~Eventstore#name",
    "access": "public",
    "description": "Returns client id - name of eventstore connection",
    "lineNumber": 122,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 156,
    "kind": "method",
    "name": "connect",
    "memberof": "src/eventstore/Eventstore.ts~Eventstore",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/eventstore/Eventstore.ts~Eventstore#connect",
    "access": "public",
    "description": "Connect to eventstore",
    "lineNumber": 129,
    "params": [
      {
        "types": [
          "{}"
        ],
        "name": "connectionConfiguration",
        "optional": true,
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 157,
    "kind": "method",
    "name": "disconnect",
    "memberof": "src/eventstore/Eventstore.ts~Eventstore",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/Eventstore.ts~Eventstore#disconnect",
    "access": "public",
    "description": "Disconnect from eventstore and try to drain pending requests",
    "lineNumber": 147,
    "params": [],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 158,
    "kind": "get",
    "name": "isConnected",
    "memberof": "src/eventstore/Eventstore.ts~Eventstore",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/Eventstore.ts~Eventstore#isConnected",
    "access": "public",
    "description": "Indicates if connection to eventstore is available",
    "lineNumber": 154,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 159,
    "kind": "method",
    "name": "getConnection",
    "memberof": "src/eventstore/Eventstore.ts~Eventstore",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/Eventstore.ts~Eventstore#getConnection",
    "access": "public",
    "description": "Returns current connection",
    "lineNumber": 161,
    "params": [],
    "type": {
      "types": [
        "TCPConnection"
      ]
    }
  },
  {
    "__docId__": 160,
    "kind": "get",
    "name": "logger",
    "memberof": "src/eventstore/Eventstore.ts~Eventstore",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/Eventstore.ts~Eventstore#logger",
    "access": "public",
    "description": "Get current logger instance",
    "lineNumber": 168,
    "type": {
      "types": [
        "bunyan"
      ]
    }
  },
  {
    "__docId__": 161,
    "kind": "set",
    "name": "logger",
    "memberof": "src/eventstore/Eventstore.ts~Eventstore",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/Eventstore.ts~Eventstore#logger",
    "access": "public",
    "description": "Set logger instance",
    "lineNumber": 175,
    "type": {
      "types": [
        "bunyan"
      ]
    }
  },
  {
    "__docId__": 162,
    "kind": "method",
    "name": "stream",
    "memberof": "src/eventstore/Eventstore.ts~Eventstore",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/Eventstore.ts~Eventstore#stream",
    "access": "public",
    "description": "Get a stream instance specified by streamName\nYou can also use one of the alias functions fromStream or atStream",
    "lineNumber": 183,
    "params": [
      {
        "types": [],
        "name": "streamName"
      },
      {
        "types": [
          "StreamOptions"
        ],
        "name": "streamOptions"
      }
    ],
    "type": {
      "types": [
        "Stream"
      ]
    }
  },
  {
    "__docId__": 163,
    "kind": "method",
    "name": "fromStream",
    "memberof": "src/eventstore/Eventstore.ts~Eventstore",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/Eventstore.ts~Eventstore#fromStream",
    "access": "public",
    "description": "Get a stream instance specified by streamName\nAlias for method stream",
    "lineNumber": 196,
    "params": [
      {
        "types": [],
        "name": "streamName"
      },
      {
        "types": [
          "StreamOptions"
        ],
        "name": "streamOptions"
      }
    ],
    "type": {
      "types": [
        "Stream"
      ]
    }
  },
  {
    "__docId__": 164,
    "kind": "method",
    "name": "atStream",
    "memberof": "src/eventstore/Eventstore.ts~Eventstore",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/Eventstore.ts~Eventstore#atStream",
    "access": "public",
    "description": "Get a stream instance specified by streamName\nAlias for method stream",
    "lineNumber": 204,
    "params": [
      {
        "types": [],
        "name": "streamName"
      },
      {
        "types": [
          "StreamOptions"
        ],
        "name": "streamOptions"
      }
    ],
    "type": {
      "types": [
        "Stream"
      ]
    }
  },
  {
    "__docId__": 165,
    "kind": "method",
    "name": "ping",
    "memberof": "src/eventstore/Eventstore.ts~Eventstore",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/eventstore/Eventstore.ts~Eventstore#ping",
    "access": "public",
    "description": "Ping eventstore",
    "lineNumber": 211,
    "params": [],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 166,
    "kind": "method",
    "name": "identifyClient",
    "memberof": "src/eventstore/Eventstore.ts~Eventstore",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/eventstore/Eventstore.ts~Eventstore#identifyClient",
    "access": "protected",
    "description": "Called directly after connecting to eventstore\nIdentifies connection against eventstore\nIdentification can be set in connection settings field clientId",
    "lineNumber": 233,
    "params": [],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 167,
    "kind": "method",
    "name": "authenticate",
    "memberof": "src/eventstore/Eventstore.ts~Eventstore",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/eventstore/Eventstore.ts~Eventstore#authenticate",
    "access": "protected",
    "description": "Authenticate with credentials from settings",
    "lineNumber": 258,
    "params": [],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 168,
    "kind": "method",
    "name": "readSlice",
    "memberof": "src/eventstore/Eventstore.ts~Eventstore",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/eventstore/Eventstore.ts~Eventstore#readSlice",
    "access": "protected",
    "description": "Reads a slice of events from current stream",
    "lineNumber": 279,
    "params": [
      {
        "types": [
          "EventstoreCommand"
        ],
        "name": "direction"
      },
      {
        "types": [
          "Position"
        ],
        "name": "position"
      },
      {
        "types": [],
        "name": "maxSliceCount"
      },
      {
        "types": [],
        "name": "resolveLinks"
      },
      {
        "types": [],
        "name": "requireMaster"
      },
      {
        "types": [
          "UserCredentials",
          "null"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 169,
    "kind": "method",
    "name": "readSliceForward",
    "memberof": "src/eventstore/Eventstore.ts~Eventstore",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/eventstore/Eventstore.ts~Eventstore#readSliceForward",
    "access": "public",
    "description": "Reads a slice from current stream in forward direction",
    "lineNumber": 313,
    "params": [
      {
        "types": [
          "Position"
        ],
        "name": "position"
      },
      {
        "types": [],
        "name": "maxSliceCount"
      },
      {
        "types": [
          "boolean"
        ],
        "name": "resolveLinks",
        "optional": true,
        "defaultRaw": true,
        "defaultValue": "true"
      },
      {
        "types": [],
        "name": "requireMaster"
      },
      {
        "types": [
          "UserCredentials",
          "null"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 170,
    "kind": "method",
    "name": "readSliceBackward",
    "memberof": "src/eventstore/Eventstore.ts~Eventstore",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/eventstore/Eventstore.ts~Eventstore#readSliceBackward",
    "access": "public",
    "description": "Reads a slice from current stream in backward direction",
    "lineNumber": 336,
    "params": [
      {
        "types": [
          "Position"
        ],
        "name": "position"
      },
      {
        "types": [],
        "name": "maxSliceCount"
      },
      {
        "types": [
          "boolean"
        ],
        "name": "resolveLinks",
        "optional": true,
        "defaultRaw": true,
        "defaultValue": "true"
      },
      {
        "types": [],
        "name": "requireMaster"
      },
      {
        "types": [
          "UserCredentials",
          "null"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 171,
    "kind": "method",
    "name": "walkAllForward",
    "memberof": "src/eventstore/Eventstore.ts~Eventstore",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/eventstore/Eventstore.ts~Eventstore#walkAllForward",
    "access": "public",
    "description": "Walks all events forward",
    "lineNumber": 360,
    "params": [
      {
        "types": [
          "*"
        ],
        "name": "start",
        "optional": true
      },
      {
        "types": [
          "boolean"
        ],
        "name": "resolveLinks",
        "optional": true,
        "defaultRaw": true,
        "defaultValue": "true"
      },
      {
        "types": [],
        "name": "requireMaster"
      },
      {
        "types": [
          "UserCredentials",
          "null"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 172,
    "kind": "method",
    "name": "walkAllBackward",
    "memberof": "src/eventstore/Eventstore.ts~Eventstore",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/eventstore/Eventstore.ts~Eventstore#walkAllBackward",
    "access": "public",
    "description": "Walks all events backward",
    "lineNumber": 430,
    "params": [
      {
        "types": [
          "*"
        ],
        "name": "start",
        "optional": true
      },
      {
        "types": [
          "boolean"
        ],
        "name": "resolveLinks",
        "optional": true,
        "defaultRaw": true,
        "defaultValue": "true"
      },
      {
        "types": [],
        "name": "requireMaster"
      },
      {
        "types": [
          "UserCredentials",
          "null"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 173,
    "kind": "method",
    "name": "resolveLink",
    "memberof": "src/eventstore/Eventstore.ts~Eventstore",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/eventstore/Eventstore.ts~Eventstore#resolveLink",
    "access": "public",
    "description": "Resolves a link",
    "lineNumber": 499,
    "params": [
      {
        "types": [
          "Event"
        ],
        "name": "link"
      },
      {
        "types": [],
        "name": "requireMaster"
      },
      {
        "types": [
          "UserCredentials",
          "null"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 174,
    "kind": "method",
    "name": "walkEventsByStreamCategory",
    "memberof": "src/eventstore/Eventstore.ts~Eventstore",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/eventstore/Eventstore.ts~Eventstore#walkEventsByStreamCategory",
    "access": "public",
    "description": "Get all events from given stream category\n(eventstore system projections must be enabled)",
    "lineNumber": 542,
    "params": [
      {
        "types": [],
        "name": "category"
      },
      {
        "types": [
          "*"
        ],
        "name": "start",
        "optional": true
      },
      {
        "types": [
          "boolean"
        ],
        "name": "resolveLinks",
        "optional": true,
        "defaultRaw": true,
        "defaultValue": "true"
      },
      {
        "types": [],
        "name": "requireMaster"
      },
      {
        "types": [
          "UserCredentials"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 175,
    "kind": "method",
    "name": "walkEventsByType",
    "memberof": "src/eventstore/Eventstore.ts~Eventstore",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/eventstore/Eventstore.ts~Eventstore#walkEventsByType",
    "access": "public",
    "description": "Get all events by event type (event name)\n(eventstore system projections must be enabled)",
    "lineNumber": 557,
    "params": [
      {
        "types": [],
        "name": "eventType"
      },
      {
        "types": [
          "*"
        ],
        "name": "start",
        "optional": true
      },
      {
        "types": [
          "boolean"
        ],
        "name": "resolveLinks",
        "optional": true,
        "defaultRaw": true,
        "defaultValue": "true"
      },
      {
        "types": [],
        "name": "requireMaster"
      },
      {
        "types": [
          "UserCredentials"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 176,
    "kind": "method",
    "name": "walkEventsByCorrelationId",
    "memberof": "src/eventstore/Eventstore.ts~Eventstore",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/eventstore/Eventstore.ts~Eventstore#walkEventsByCorrelationId",
    "access": "public",
    "description": "Get all events by correlation id\n(eventstore system projections must be enabled)",
    "lineNumber": 572,
    "params": [
      {
        "types": [],
        "name": "correlationId"
      },
      {
        "types": [
          "*"
        ],
        "name": "start",
        "optional": true
      },
      {
        "types": [
          "boolean"
        ],
        "name": "resolveLinks",
        "optional": true,
        "defaultRaw": true,
        "defaultValue": "true"
      },
      {
        "types": [],
        "name": "requireMaster"
      },
      {
        "types": [
          "UserCredentials"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 177,
    "kind": "method",
    "name": "streamNamesByCategory",
    "memberof": "src/eventstore/Eventstore.ts~Eventstore",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/eventstore/Eventstore.ts~Eventstore#streamNamesByCategory",
    "access": "public",
    "description": "Get all stream names by stream category\n(eventstore system projections must be enabled)",
    "lineNumber": 588,
    "params": [
      {
        "types": [],
        "name": "category"
      },
      {
        "types": [
          "*"
        ],
        "name": "start",
        "optional": true
      },
      {
        "types": [],
        "name": "requireMaster"
      },
      {
        "types": [
          "UserCredentials"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 178,
    "kind": "file",
    "name": "src/eventstore/EventstoreSettings.ts",
    "content": "import * as bunyan from 'bunyan'\nimport uuid = require('uuid/v4')\nimport * as tls from 'tls'\n\n/**\n * @external {bunyan} https://github.com/trentm/node-bunyan\n */\n\n/**\n * @external {Long} https://github.com/dcodeIO/long.js\n */\n\n/**\n * @typedef {object} UserCredentials\n * @property {string} username username to use for authentication\n * @property {string} password password to use for authentication\n */\nexport interface UserCredentials {\n  username: string\n  password: string\n}\n\n/**\n * @typedef {Object} EventstoreSettings\n * @property {string} uri connection uri (default=tcp://admin@changeit@127.0.0.1:1113)\n * @property {boolean} useSSL indicates if to connect to secure tcp port (default=false)\n * @property {SecureContextOptions | null} secureContext node tls.SecureContextOptions (default=null)\n * @property {boolean} useHttps indicates if to use https for discovery (default=false)\n * @property {string} host connection host name (will be ignored if uri is set)\n * @property {number} port connection port (will be ignored if uri is set)\n * @property {UserCredentials} credentials user credentials\n * @property {boolean} requireMaster forces to connect to master node only if set to true (default=true)\n * @property {bunyan} logger bunyan logger instance\n * @property {number} maxQueueSize maximum pending requests (default=5000)\n * @property {number} connectTimeout connect timeout in ms (default=1000)\n * @property {number} maxReconnections maximum re-connection tries (default=10)\n * @property {number} reconnectionDelay delay between reconnects in ms (default=2000)\n * @property {number} operationTimeout time in ms until a request timed out if no response from eventstore arrives (default=7000)\n * @property {number} operationTimeoutCheckPeriod time period in ms to check for timed out requests (default=1000)\n * @property {string} clusterDns dns ip to use to discover eventstore cluster ip's (default=empty string)\n * @property {number} maxDiscoverAttempts maximum count of discover attempts before giving up\n * @property {number} externalGossipPort gossip ip port (default=2112)\n * @property {number} gossipTimeout timeout in ms (default=1000)\n * @property {string[]} gossipSeeds array list of eventstore cluster ip's\n * @property {boolean} validateServer validate server ssl certificate (default=false)\n * @property {string} clientId client id string to identify connection at eventstore (default=ts-client-uuid())\n *\n */\nexport interface EventstoreSettings {\n  uri: string\n  useSSL: boolean\n  secureContext: null | tls.SecureContextOptions\n  useHttps: boolean\n  host: string\n  port: number\n  credentials: UserCredentials\n  requireMaster: boolean\n  logger: bunyan\n\n  maxQueueSize: number\n  connectTimeout: number\n  maxReconnections: number\n  reconnectionDelay: number\n  operationTimeout: number\n  operationTimeoutCheckPeriod: number\n  clusterDns: string\n  maxDiscoverAttempts: number\n  externalGossipPort: number\n  gossipTimeout: number\n  gossipSeeds: string[]\n  validateServer: boolean\n  clientId: string\n}\n\n/** default eventstore connection settings */\nconst defaultConnectionSettings: EventstoreSettings = {\n  uri: 'tcp://admin@changeit@127.0.0.1:1113',\n  requireMaster: true,\n\n  maxDiscoverAttempts: 10,\n  clusterDns: '',\n  externalGossipPort: 2112,\n  gossipTimeout: 1000,\n  gossipSeeds: [],\n\n  useSSL: false, //use tcp encrypted?\n  secureContext: null,\n  useHttps: false, //fetch gossip info over https?\n  validateServer: false,\n\n  connectTimeout: 1000,\n  maxReconnections: 10,\n  reconnectionDelay: 2 * 1000,\n\n  clientId: `ts-client-${uuid()}`,\n\n  maxQueueSize: 5000,\n\n  operationTimeout: 7 * 1000,\n  operationTimeoutCheckPeriod: 1000,\n\n  logger: bunyan.createLogger({\n    name: 'eventstore-ts-client',\n    level: 'debug'\n  }),\n\n  host: '', //dummy entry will be overwritten by internal functions\n  port: 0, //dummy entry will be overwritten by internal functions\n  credentials: {\n    password: '', //dummy entry will be overwritten by internal functions\n    username: '' //dummy entry will be overwritten by internal functions\n  }\n}\n\n/**\n * Generates settings for connecting to eventstore\n *\n * @export\n * @param {(object | EventstoreSettings)} customSettings\n * @returns {EventstoreSettings}\n */\nexport function setConnectionSettings(\n  customSettings: object | EventstoreSettings\n): EventstoreSettings {\n  return {...defaultConnectionSettings, ...customSettings}\n}\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/src/eventstore/EventstoreSettings.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 179,
    "kind": "external",
    "name": "bunyan",
    "externalLink": "https://github.com/trentm/node-bunyan",
    "memberof": "src/eventstore/EventstoreSettings.ts",
    "static": true,
    "longname": "src/eventstore/EventstoreSettings.ts~bunyan",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 180,
    "kind": "external",
    "name": "Long",
    "externalLink": "https://github.com/dcodeIO/long.js",
    "memberof": "src/eventstore/EventstoreSettings.ts",
    "static": true,
    "longname": "src/eventstore/EventstoreSettings.ts~Long",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 181,
    "kind": "typedef",
    "name": "UserCredentials",
    "memberof": "src/eventstore/EventstoreSettings.ts",
    "static": true,
    "longname": "src/eventstore/EventstoreSettings.ts~UserCredentials",
    "access": "public",
    "description": "",
    "lineNumber": 18,
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "username",
        "description": "username to use for authentication"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "password",
        "description": "password to use for authentication"
      }
    ],
    "type": {
      "types": [
        "object"
      ],
      "optional": false,
      "name": "UserCredentials"
    }
  },
  {
    "__docId__": 182,
    "kind": "typedef",
    "name": "EventstoreSettings",
    "memberof": "src/eventstore/EventstoreSettings.ts",
    "static": true,
    "longname": "src/eventstore/EventstoreSettings.ts~EventstoreSettings",
    "access": "public",
    "description": "",
    "lineNumber": 49,
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "uri",
        "description": "connection uri (default=tcp://admin@changeit@127.0.0.1:1113)"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "useSSL",
        "description": "indicates if to connect to secure tcp port (default=false)"
      },
      {
        "nullable": null,
        "types": [
          "SecureContextOptions ",
          " null"
        ],
        "spread": false,
        "optional": false,
        "name": "secureContext",
        "description": "node tls.SecureContextOptions (default=null)"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "useHttps",
        "description": "indicates if to use https for discovery (default=false)"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "host",
        "description": "connection host name (will be ignored if uri is set)"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "port",
        "description": "connection port (will be ignored if uri is set)"
      },
      {
        "nullable": null,
        "types": [
          "UserCredentials"
        ],
        "spread": false,
        "optional": false,
        "name": "credentials",
        "description": "user credentials"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "requireMaster",
        "description": "forces to connect to master node only if set to true (default=true)"
      },
      {
        "nullable": null,
        "types": [
          "bunyan"
        ],
        "spread": false,
        "optional": false,
        "name": "logger",
        "description": "bunyan logger instance"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "maxQueueSize",
        "description": "maximum pending requests (default=5000)"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "connectTimeout",
        "description": "connect timeout in ms (default=1000)"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "maxReconnections",
        "description": "maximum re-connection tries (default=10)"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "reconnectionDelay",
        "description": "delay between reconnects in ms (default=2000)"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "operationTimeout",
        "description": "time in ms until a request timed out if no response from eventstore arrives (default=7000)"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "operationTimeoutCheckPeriod",
        "description": "time period in ms to check for timed out requests (default=1000)"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "clusterDns",
        "description": "dns ip to use to discover eventstore cluster ip's (default=empty string)"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "maxDiscoverAttempts",
        "description": "maximum count of discover attempts before giving up"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "externalGossipPort",
        "description": "gossip ip port (default=2112)"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "gossipTimeout",
        "description": "timeout in ms (default=1000)"
      },
      {
        "nullable": null,
        "types": [
          "string[]"
        ],
        "spread": false,
        "optional": false,
        "name": "gossipSeeds",
        "description": "array list of eventstore cluster ip's"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "validateServer",
        "description": "validate server ssl certificate (default=false)"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "clientId",
        "description": "client id string to identify connection at eventstore (default=ts-client-uuid())"
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "EventstoreSettings"
    }
  },
  {
    "__docId__": 183,
    "kind": "variable",
    "name": "defaultConnectionSettings",
    "memberof": "src/eventstore/EventstoreSettings.ts",
    "static": true,
    "longname": "src/eventstore/EventstoreSettings.ts~defaultConnectionSettings",
    "access": "public",
    "export": false,
    "importPath": "eventstore-ts-client/src/eventstore/EventstoreSettings.ts",
    "importStyle": null,
    "description": "default eventstore connection settings",
    "lineNumber": 76,
    "type": {
      "types": [
        "{\"uri\": string, \"requireMaster\": boolean, \"maxDiscoverAttempts\": number, \"clusterDns\": *, \"externalGossipPort\": number, \"gossipTimeout\": number, \"gossipSeeds\": *, \"useSSL\": *, \"secureContext\": *, \"useHttps\": *, \"validateServer\": *, \"connectTimeout\": number, \"maxReconnections\": number, \"reconnectionDelay\": *, \"clientId\": *, \"maxQueueSize\": number, \"operationTimeout\": *, \"operationTimeoutCheckPeriod\": number, \"logger\": *, \"host\": *, \"port\": *, \"credentials\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 184,
    "kind": "function",
    "name": "setConnectionSettings",
    "memberof": "src/eventstore/EventstoreSettings.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/eventstore/EventstoreSettings.ts~setConnectionSettings",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/eventstore/EventstoreSettings.ts",
    "importStyle": "{setConnectionSettings}",
    "description": null,
    "lineNumber": 122,
    "undocument": true,
    "params": [
      {
        "types": [
          "object",
          "EventstoreSettings"
        ],
        "name": "customSettings"
      }
    ],
    "type": {
      "types": [
        "EventstoreSettings"
      ]
    }
  },
  {
    "__docId__": 185,
    "kind": "file",
    "name": "src/eventstore/Position.ts",
    "content": "import Long = require('long')\n\n/**\n * Represents a position in eventstore global log file\n */\nexport class Position {\n  /** commit position part of position */\n  public commitPosition: Long = Long.fromValue(0)\n\n  /** prepare position part of position */\n  public preparePosition: Long = Long.fromValue(0)\n\n  /**\n   *Creates an instance of Position.\n   */\n  public constructor(commitPosition: Long | number, preparePosition: Long | number) {\n    this.commitPosition =\n      typeof commitPosition === 'number' ? Long.fromValue(commitPosition) : commitPosition\n    this.preparePosition =\n      typeof preparePosition === 'number' ? Long.fromValue(preparePosition) : preparePosition\n  }\n\n  /**\n   * Compares two Position values\n   */\n  public compareTo(position: Position): number {\n    if (\n      this.commitPosition.lt(position.commitPosition) ||\n      (this.commitPosition.eq(position.commitPosition) &&\n        this.preparePosition.lt(position.preparePosition))\n    ) {\n      return -1\n    }\n    if (\n      this.commitPosition.gt(position.commitPosition) ||\n      (this.commitPosition.eq(position.commitPosition) &&\n        this.preparePosition.gt(position.preparePosition))\n    ) {\n      return 1\n    }\n    return 0\n  }\n\n  /**\n   * return start position in global log file\n   */\n  public static get Start(): Position {\n    return new Position(Long.fromValue(0), Long.fromValue(0))\n  }\n\n  /**\n   * return end position in global log file\n   */\n  public static get End(): Position {\n    return new Position(Long.fromValue(-1), Long.fromValue(-1))\n  }\n}\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/src/eventstore/Position.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 186,
    "kind": "class",
    "name": "Position",
    "memberof": "src/eventstore/Position.ts",
    "static": true,
    "longname": "src/eventstore/Position.ts~Position",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/eventstore/Position.ts",
    "importStyle": "{Position}",
    "description": "Represents a position in eventstore global log file",
    "lineNumber": 6,
    "interface": false
  },
  {
    "__docId__": 187,
    "kind": "member",
    "name": "commitPosition",
    "memberof": "src/eventstore/Position.ts~Position",
    "static": false,
    "longname": "src/eventstore/Position.ts~Position#commitPosition",
    "access": "public",
    "description": "commit position part of position",
    "lineNumber": 8,
    "type": {
      "types": [
        "Long"
      ]
    }
  },
  {
    "__docId__": 188,
    "kind": "member",
    "name": "preparePosition",
    "memberof": "src/eventstore/Position.ts~Position",
    "static": false,
    "longname": "src/eventstore/Position.ts~Position#preparePosition",
    "access": "public",
    "description": "prepare position part of position",
    "lineNumber": 11,
    "type": {
      "types": [
        "Long"
      ]
    }
  },
  {
    "__docId__": 189,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/eventstore/Position.ts~Position",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/Position.ts~Position#constructor",
    "access": "public",
    "description": "Creates an instance of Position.",
    "lineNumber": 16
  },
  {
    "__docId__": 192,
    "kind": "method",
    "name": "compareTo",
    "memberof": "src/eventstore/Position.ts~Position",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/Position.ts~Position#compareTo",
    "access": "public",
    "description": "Compares two Position values",
    "lineNumber": 26,
    "params": [
      {
        "types": [
          "Position"
        ],
        "name": "position"
      }
    ],
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 193,
    "kind": "get",
    "name": "Start",
    "memberof": "src/eventstore/Position.ts~Position",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/eventstore/Position.ts~Position.Start",
    "access": "public",
    "description": "return start position in global log file",
    "lineNumber": 47,
    "type": {
      "types": [
        "Position"
      ]
    }
  },
  {
    "__docId__": 194,
    "kind": "get",
    "name": "End",
    "memberof": "src/eventstore/Position.ts~Position",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/eventstore/Position.ts~Position.End",
    "access": "public",
    "description": "return end position in global log file",
    "lineNumber": 54,
    "type": {
      "types": [
        "Position"
      ]
    }
  },
  {
    "__docId__": 195,
    "kind": "file",
    "name": "src/eventstore/TCPConnection.ts",
    "content": "import {EventstoreSettings} from './EventstoreSettings'\nimport * as net from 'net'\nimport * as tls from 'tls'\nimport * as bunyan from 'bunyan'\nimport {EventEmitter} from 'events'\nimport {uuidToBuffer, uuidFromBuffer} from '../protobuf/uuidBufferConvert'\nimport {EventstoreCommand} from '../protobuf/EventstoreCommand'\nimport * as eventstoreError from '../errors'\nimport {EventstoreError} from '../errors'\nimport * as model from '../protobuf/model'\nimport {\n  Subscription,\n  PersistentSubscription,\n  SubscriptionDropReason,\n  SubscriptionStatus\n} from '../subscription'\nimport {Stream} from '../stream'\nimport {UserCredentials} from '../eventstore/EventstoreSettings'\nimport uuid = require('uuid/v4')\nimport {Event} from '../event'\nimport {getIpAndPort} from './getConnectInfo'\nimport {Position} from './Position'\nimport {WriteResult} from './Eventstore'\nimport Long from 'long'\n\n/** protobuf shorthand */\nconst protobuf = model.eventstore.proto\n\n/** typescript enumeration of connection states */\nenum connectionState {\n  closed,\n  init,\n  connected,\n  drain\n}\n\n/** raw tcp communication constant */\nconst FLAGS_NONE = 0x00\n/** raw tcp communication constant */\nconst FLAGS_AUTH = 0x01\n/** raw tcp communication constant */\nconst UINT32_LENGTH = 4\n/** raw tcp communication constant */\nconst GUID_LENGTH = 16\n/** raw tcp communication constant */\nconst HEADER_LENGTH = 1 + 1 + GUID_LENGTH // Cmd + Flags + CorrelationId\n/** raw tcp communication constant */\nconst COMMAND_OFFSET = UINT32_LENGTH\n/** raw tcp communication constant */\nconst FLAGS_OFFSET = COMMAND_OFFSET + 1\n/** raw tcp communication constant */\nconst CORRELATION_ID_OFFSET = FLAGS_OFFSET + 1\n/** raw tcp communication constant */\nconst DATA_OFFSET = CORRELATION_ID_OFFSET + GUID_LENGTH // Length + Cmd + Flags + CorrelationId\n\n/**\n * Raw tcp communication to eventstore\n * This class handles basic communication with eventstore\n */\nexport class TCPConnection extends EventEmitter {\n  /** initial config */\n  protected initialConfig: EventstoreSettings\n  /** config after discovery process */\n  protected connectionConfig: EventstoreSettings\n  /** tcp socket  */\n  protected socket: net.Socket | tls.TLSSocket\n  /** connection id  */\n  protected connectionId: string | null = null\n  /** list of pending requests */\n  protected pendingRequests: Map<\n    string,\n    {resolve: Function; reject: Function; sendTime: number}\n  > = new Map()\n  /** timeout interval for timed out pending requests */\n  protected timeoutInterval: null | NodeJS.Timeout = null\n  /** logger instance */\n  public log: bunyan\n  /** connection state */\n  protected state: connectionState = connectionState.closed\n  /** message offset of tcp data */\n  protected messageCurrentOffset: number = 0\n  /** message length of tcp data */\n  protected messageCurrentLength: number = 0\n  /** message buffer of tcp data */\n  protected messageData: Buffer | null = null\n  /** list of subscriptions */\n  protected subscriptionList: Map<string, Subscription> = new Map()\n  /** list of persistent subscriptions */\n  protected persistentSubscriptionList: Map<string, PersistentSubscription> = new Map()\n  /** indicates if connection close is wanted by user or not */\n  protected isUnexpectedClosed: boolean = true\n  /** counter for re-connections */\n  protected reconnectCount: number = 0\n\n  /**\n   *Creates an instance of TCPConnection.\n   */\n  public constructor(connectionConfiguration: EventstoreSettings) {\n    super()\n    this.initialConfig = {...connectionConfiguration}\n    this.connectionConfig = connectionConfiguration\n    this.log = this.connectionConfig.logger.child\n      ? this.connectionConfig.logger.child({module: 'TCPConnection'})\n      : this.connectionConfig.logger\n\n    this.socket = new net.Socket()\n  }\n\n  /**\n   * Returns true if connected to eventstore otherwise false\n   */\n  public get isConnected(): boolean {\n    return this.state === connectionState.connected\n  }\n\n  /**\n   * Called to connect to eventstore\n   */\n  public async connect(): Promise<void> {\n    let connected = false\n    while (!connected && this.reconnectCount < this.initialConfig.maxReconnections) {\n      this.state = connectionState.init\n      this.connectionConfig = await getIpAndPort({...this.initialConfig}, this.log)\n\n      try {\n        await this.tryToConnect()\n        connected = true\n      } catch (err) {\n        this.log.error({err, count: this.reconnectCount, fn: 'connect'}, 'Try to connect failed ')\n        this.reconnectCount++\n        this.emit('reconnect', this.reconnectCount)\n        await new Promise(\n          (resolve): void => {\n            setTimeout(resolve, this.initialConfig.reconnectionDelay)\n          }\n        )\n      }\n    }\n  }\n\n  /**\n   * Connect to eventstore\n   */\n  protected async tryToConnect(): Promise<void> {\n    const port = this.connectionConfig.port\n    const host = this.connectionConfig.host\n\n    if (port === 0 || host === '') {\n      throw eventstoreError.newConnectionError('Invalid connection settings on host and port')\n    }\n\n    this.log.debug(`Start connecting to ${host}:${port}`)\n\n    await new Promise(\n      (resolve, reject): void => {\n        const errorListener = (err: Error | EventstoreError): void => {\n          this.state = connectionState.closed\n          if (err instanceof Error) {\n            this.onError(eventstoreError.newConnectionError(err.message, err))\n          } else {\n            this.onError(err)\n          }\n\n          reject(err)\n        }\n\n        const successListener = (): void => {\n          if (this.socket instanceof tls.TLSSocket) {\n            if (!this.socket.authorized) {\n              this.log.warn({err: this.socket.authorizationError}, 'SSL authorization warning')\n            }\n          }\n          this.socket.removeListener('error', errorListener)\n          this.socket.on('error', this.onError.bind(this))\n          this.onConnect()\n          resolve()\n        }\n\n        if (this.connectionConfig.useSSL) {\n          let secureContext\n          if (this.connectionConfig.secureContext) {\n            try {\n              secureContext = tls.createSecureContext(this.connectionConfig.secureContext)\n            } catch (err) {\n              const conErr = eventstoreError.newConnectionError(\n                'Error creating secure context',\n                err\n              )\n              reject(conErr)\n            }\n          }\n\n          const options = {\n            port,\n            host,\n            servername: host,\n            requestCert: this.connectionConfig.validateServer,\n            rejectUnauthorized: this.connectionConfig.validateServer,\n            timeout: this.connectionConfig.connectTimeout,\n            secureContext\n          }\n\n          this.socket = tls.connect(options, successListener)\n        } else {\n          const options = {\n            port,\n            host,\n            servername: host,\n            timeout: this.connectionConfig.connectTimeout\n          }\n          this.socket = net.connect(options, successListener)\n        }\n\n        this.socket.once('error', errorListener.bind(this))\n        this.socket.on('close', this.onClose.bind(this))\n        this.socket.on('data', this.onData.bind(this))\n        this.socket.on('secureConnect', this.onSecureConnect.bind(this))\n      }\n    )\n  }\n\n  /**\n   * Disconnect from eventstore.\n   * It tries to drain pending queue to prevent data loose before connection gets closed\n   * If disconnect() is call no new outgoing requests accepted\n   */\n  public async disconnect(): Promise<void> {\n    if (!this.isConnected) {\n      return\n    }\n    this.isUnexpectedClosed = false\n    await new Promise(\n      (resolve): void => {\n        this.onDrain()\n        if (this.pendingRequests.size <= 0) {\n          this.state = connectionState.closed\n          this.socket.destroy()\n          resolve()\n        } else {\n          this.log.debug(\n            {\n              pendingRequests: this.pendingRequests.size,\n              timeout:\n                this.initialConfig.operationTimeout + this.initialConfig.operationTimeoutCheckPeriod\n            },\n            'Wait for pending requests'\n          )\n          // wait for pending requests/timeouts\n          setTimeout((): void => {\n            this.state = connectionState.closed\n            this.socket.destroy()\n            this.log.debug('Timeout finished')\n            this.pendingRequests.forEach(\n              (value, id): void => {\n                this.rejectCommandPromise(\n                  id,\n                  eventstoreError.newConnectionError('Connection closed')\n                )\n              }\n            )\n            resolve()\n          }, this.initialConfig.operationTimeout + this.initialConfig.operationTimeoutCheckPeriod)\n        }\n      }\n    )\n  }\n\n  /**\n   * Called by interval function to check if there are some pending requests which should be rejected with time out error\n   */\n  protected checkTimeout(): void {\n    this.log.trace('Check timeout queue')\n    const timeout: string[] = []\n    const now = Date.now() - this.initialConfig.operationTimeout\n    for (var [key, value] of this.pendingRequests) {\n      if (value.sendTime < now) {\n        timeout.push(key)\n      }\n    }\n    for (let x = 0, xMax = timeout.length; x < xMax; x++) {\n      try {\n        this.rejectCommandPromise(\n          timeout[x],\n          eventstoreError.newTimeoutError('Timeout by eventstore-ts-client')\n        )\n      } catch (err) {\n        this.log.error({err, fn: 'checkTimeout'}, 'Error on rejectCommandPromise')\n      }\n    }\n  }\n\n  /**\n   * Creates and sends raw data message to eventstore and adds given promise to pending queue\n   */\n  public sendCommand(\n    correlationId: string,\n    command: EventstoreCommand,\n    data: Buffer | null = null,\n    credentials: UserCredentials | null = null,\n    promise: {resolve: Function; reject: Function} | null = null\n  ): void {\n    this.log.trace(`Sending ${EventstoreCommand[command]} with ${correlationId}`)\n    if (\n      this.state !== connectionState.connected &&\n      command !== EventstoreCommand.HeartbeatResponseCommand &&\n      command !== EventstoreCommand.Pong\n    ) {\n      throw eventstoreError.newConnectionError(\n        'Connection to eventstore is: ' + connectionState[this.state]\n      )\n    }\n\n    if (promise) {\n      if (this.pendingRequests.size >= this.connectionConfig.maxQueueSize) {\n        promise.reject(eventstoreError.newConnectionError('Maximum concurrent items reached'))\n        throw eventstoreError.newConnectionError('Maximum concurrent items reached')\n      }\n      this.pendingRequests.set(correlationId, {...promise, sendTime: Date.now()})\n    }\n\n    try {\n      let authLength = 0\n      let flags = FLAGS_NONE\n      if (credentials) {\n        flags = FLAGS_AUTH\n        authLength = 1 + credentials.username.length + 1 + credentials.password.length\n      }\n\n      let commandLength = HEADER_LENGTH + authLength\n      if (data) {\n        commandLength += data.length\n      }\n      const packetLength = 4 + commandLength\n\n      const buf = Buffer.alloc(packetLength)\n      buf.writeUInt32LE(commandLength, 0)\n      buf[COMMAND_OFFSET] = command\n      buf[FLAGS_OFFSET] = flags\n\n      uuidToBuffer(correlationId).copy(buf, CORRELATION_ID_OFFSET, 0, GUID_LENGTH)\n      if (credentials) {\n        buf.writeUInt8(credentials.username.length, DATA_OFFSET)\n        buf.write(credentials.username, DATA_OFFSET + 1)\n        buf.writeUInt8(credentials.password.length, DATA_OFFSET + 1 + credentials.username.length)\n        buf.write(credentials.password, DATA_OFFSET + 1 + credentials.username.length + 1)\n      }\n\n      if (data) {\n        data.copy(buf, DATA_OFFSET + authLength, 0, data.length)\n      }\n\n      this.socket.write(buf)\n    } catch (err) {\n      const newErr = eventstoreError.newConnectionError(err.message, err)\n      this.rejectCommandPromise(correlationId, newErr)\n      this.onError(newErr)\n    }\n  }\n\n  /**\n   * Gets called as soon as new data over tcp connection arrives as raw buffer data\n   * Checks if\n   * - new received data is part of previously received data\n   * - new data contains multiple responses\n   * - new data is single response\n   */\n  protected handleNewResponseData(data: Buffer): Buffer | null {\n    const commandLength = data.readUInt32LE(0)\n    if (commandLength < HEADER_LENGTH) {\n      this.log.error(\n        {\n          connectionId: this.connectionId,\n          fn: 'handleNewResponseData'\n        },\n        'Invalid command length of ' + commandLength + ' bytes'\n      )\n      throw eventstoreError.newProtocolError('Invalid command length')\n    }\n\n    const messageLength = UINT32_LENGTH + commandLength\n    if (data.length === messageLength) {\n      // A single packet message, no need to copy into another buffer\n      this.handleSingleResponseData(data)\n      return null\n    } else if (data.length > messageLength) {\n      // Multiple messages in one packet\n      const firstMessage = data.slice(0, messageLength)\n      this.messageCurrentLength = messageLength\n      this.handleSingleResponseData(firstMessage)\n      return data.slice(this.messageCurrentLength)\n    } else {\n      // The first packet of a multi-packet message\n      this.messageData = Buffer.alloc(messageLength)\n      const packetLength = data.copy(this.messageData, this.messageCurrentOffset, 0)\n      this.messageCurrentOffset = packetLength\n      return null\n    }\n  }\n\n  /**\n   * This function handles raw buffer responses received within multiple tcp data package\n   */\n  protected handleMultiPacketResponseData(data: Buffer): Buffer | null {\n    this.log.trace({fn: 'handleMultiPacketResponseData'}, `MultipacketResponse`)\n    if (this.messageData === null) {\n      return null\n    }\n    const packetLength = data.copy(this.messageData, this.messageCurrentOffset, 0)\n    this.messageCurrentOffset += packetLength\n    if (this.messageCurrentOffset >= this.messageData.length) {\n      this.handleSingleResponseData(this.messageData)\n      this.messageData = null\n      this.messageCurrentOffset = 0\n    }\n    return null\n  }\n\n  /**\n   * This function handles a single raw buffer response\n   */\n  protected handleSingleResponseData(data: Buffer): void {\n    const commandLength = data.readUInt32LE(0)\n    if (commandLength < HEADER_LENGTH) {\n      this.log.error(\n        {\n          connectionId: this.connectionId,\n          fn: 'handleSingleResponseData'\n        },\n        'Invalid command length of ' + commandLength + ' bytes'\n      )\n      throw eventstoreError.newProtocolError('Invalid command length')\n    }\n\n    const command = data[COMMAND_OFFSET]\n\n    const correlationId = uuidFromBuffer(\n      data.slice(CORRELATION_ID_OFFSET, CORRELATION_ID_OFFSET + GUID_LENGTH)\n    )\n\n    this.log.trace('Incoming response: ' + EventstoreCommand[command])\n\n    //Answer Heartbeat directly without adding to promise queue\n    if (command === EventstoreCommand.HeartbeatRequestCommand) {\n      this.emit('heartbeat')\n      this.sendCommand(correlationId, EventstoreCommand.HeartbeatResponseCommand)\n      return\n    }\n\n    //Answer Ping directly without adding to promise queue\n    if (command === EventstoreCommand.Ping) {\n      this.sendCommand(correlationId, EventstoreCommand.Pong)\n      return\n    }\n\n    const payloadLength = commandLength - HEADER_LENGTH\n    const payload = Buffer.alloc(payloadLength)\n    if (payloadLength > 0) {\n      data.copy(payload, 0, DATA_OFFSET, DATA_OFFSET + payloadLength)\n    }\n\n    let err: eventstoreError.EventstoreError\n    switch (command) {\n      case EventstoreCommand.BadRequest:\n        err = eventstoreError.newBadRequestError()\n        this.rejectCommandPromise(correlationId, err)\n        this.onError(err)\n        break\n      case EventstoreCommand.NotAuthenticated:\n        err = eventstoreError.newNotAuthenticatedError()\n        this.rejectCommandPromise(correlationId, err)\n        this.onError(err)\n        break\n      case EventstoreCommand.NotHandled:\n        const notHandled = protobuf.NotHandled.decode(payload)\n        err = eventstoreError.newNotHandledError(`\n          ${protobuf.NotHandled.NotHandledReason[notHandled.reason]}\n        `)\n        this.rejectCommandPromise(correlationId, err)\n        this.onError(err)\n        break\n      case EventstoreCommand.CreatePersistentSubscriptionCompleted:\n        this.handleCreatePersistentSubscriptionCompleted(correlationId, payload)\n        break\n      case EventstoreCommand.DeletePersistentSubscriptionCompleted:\n        this.handleDeletePersistentSubscriptionCompleted(correlationId, payload)\n        break\n      case EventstoreCommand.DeleteStreamCompleted:\n        this.handleDeleteStreamCompleted(correlationId, payload)\n        break\n      case EventstoreCommand.PersistentSubscriptionConfirmation:\n        this.handlePersistentSubscriptionConfirmation(correlationId, payload)\n        break\n      case EventstoreCommand.PersistentSubscriptionStreamEventAppeared:\n        this.handlePersistentSubscriptionStreamEventAppeared(correlationId, payload)\n        break\n\n      case EventstoreCommand.ReadAllEventsBackwardCompleted:\n        this.handleReadAllEventsCompleted(correlationId, payload)\n        break\n      case EventstoreCommand.ReadAllEventsForwardCompleted:\n        this.handleReadAllEventsCompleted(correlationId, payload)\n        break\n\n      case EventstoreCommand.ReadEventCompleted:\n        this.handleReadEventCompleted(correlationId, payload)\n        break\n\n      case EventstoreCommand.ReadStreamEventsBackwardCompleted:\n        this.handleReadStreamEventsCompleted(correlationId, payload)\n        break\n      case EventstoreCommand.ReadStreamEventsForwardCompleted:\n        this.handleReadStreamEventsCompleted(correlationId, payload)\n        break\n      case EventstoreCommand.StreamEventAppeared:\n        this.handleStreamEventAppeared(correlationId, payload)\n        break\n      case EventstoreCommand.SubscriptionConfirmation:\n        this.handleSubscriptionConfirmation(correlationId, payload)\n        break\n      case EventstoreCommand.SubscriptionDropped:\n        this.handleSubscriptionDropped(correlationId, payload)\n        break\n      case EventstoreCommand.TransactionCommitCompleted:\n        this.handleTransactionCommitCompleted(correlationId, payload)\n        break\n      case EventstoreCommand.TransactionStartCompleted:\n        this.handleTransactionStartCompleted(correlationId, payload)\n        break\n      case EventstoreCommand.TransactionWriteCompleted:\n        this.handleTransactionWriteCompleted(correlationId, payload)\n        break\n      case EventstoreCommand.UpdatePersistentSubscriptionCompleted:\n        this.handleUpdatePersistentSubscriptionCompleted(correlationId, payload)\n        break\n      case EventstoreCommand.WriteEventsCompleted:\n        this.handleWriteEventsCompleted(correlationId, payload)\n        break\n      case EventstoreCommand.ClientIdentified:\n        this.resolveCommandPromise(correlationId)\n        break\n      case EventstoreCommand.Pong:\n        this.resolveCommandPromise(correlationId)\n        break\n      case EventstoreCommand.Authenticated:\n        this.resolveCommandPromise(correlationId)\n        break\n      default:\n        err = new eventstoreError.EventstoreError(\n          'Unhandled eventstore command : ' + EventstoreCommand[command] + ' -> ' + command,\n          'EventstoreImplementationError'\n        )\n        this.rejectCommandPromise(correlationId, err)\n        this.onError(err)\n        break\n    }\n  }\n\n  /**\n   * Handle response for command CreatePersistentSubscription\n   */\n  protected handleCreatePersistentSubscriptionCompleted(\n    correlationId: string,\n    payload: Buffer\n  ): void {\n    const decoded = protobuf.CreatePersistentSubscriptionCompleted.decode(payload)\n    if (\n      decoded.result ===\n      protobuf.CreatePersistentSubscriptionCompleted.CreatePersistentSubscriptionResult.Success\n    ) {\n      this.resolveCommandPromise(correlationId)\n    } else {\n      const errorMsg =\n        `${\n          protobuf.CreatePersistentSubscriptionCompleted.CreatePersistentSubscriptionResult[\n            decoded.result\n          ]\n        } ` + (decoded.reason || '')\n      let err\n      switch (decoded.result) {\n        case protobuf.CreatePersistentSubscriptionCompleted.CreatePersistentSubscriptionResult\n          .AccessDenied:\n          err = eventstoreError.newAccessDeniedError(errorMsg)\n          break\n        case protobuf.CreatePersistentSubscriptionCompleted.CreatePersistentSubscriptionResult\n          .AlreadyExists:\n          err = eventstoreError.newAlreadyExistError(errorMsg)\n          break\n        default:\n          err = eventstoreError.newUnspecificError(errorMsg)\n      }\n      this.rejectCommandPromise(correlationId, err)\n    }\n  }\n\n  /**\n   * Handle response for command DeletePersistentSubscription\n   */\n  protected handleDeletePersistentSubscriptionCompleted(\n    correlationId: string,\n    payload: Buffer\n  ): void {\n    const status = protobuf.DeletePersistentSubscriptionCompleted.DeletePersistentSubscriptionResult\n    const decoded = protobuf.DeletePersistentSubscriptionCompleted.decode(payload)\n    if (decoded.result === status.Success) {\n      this.resolveCommandPromise(correlationId)\n    } else {\n      let returnError\n      switch (decoded.result) {\n        case status.AccessDenied:\n          returnError = eventstoreError.newAccessDeniedError(\n            'Delete of Subscription not allowed: ' + decoded.reason || ''\n          )\n          break\n        case status.DoesNotExist:\n          returnError = eventstoreError.newDoesNotExistError(\n            'Persistent subscription does not exist: ' + decoded.reason || ''\n          )\n          break\n        default:\n          returnError = eventstoreError.newUnspecificError(\n            'Delete persistent connection failed: ' + (decoded.reason || '')\n          )\n      }\n      this.rejectCommandPromise(correlationId, returnError)\n    }\n  }\n\n  /**\n   * Handle response for command DeleteStreamCompleted\n   */\n  protected handleDeleteStreamCompleted(correlationId: string, payload: Buffer): void {\n    const decoded = protobuf.DeleteStreamCompleted.decode(payload)\n    if (\n      this.checkOperationResult(\n        correlationId,\n        decoded.result,\n        'handleDeleteStream: ' + decoded.message\n      )\n    ) {\n      this.resolveCommandPromise(\n        correlationId,\n        new Position(decoded.commitPosition, decoded.preparePosition)\n      )\n    }\n  }\n\n  /**\n   * Handle response for command ReadAllEvents\n   */\n  protected handleReadAllEventsCompleted(correlationId: string, payload: Buffer): void {\n    const decoded = protobuf.ReadAllEventsCompleted.decode(payload)\n    let err: eventstoreError.EventstoreError\n    const message: string = decoded.error || ''\n    switch (decoded.result) {\n      case protobuf.ReadAllEventsCompleted.ReadAllResult.Success:\n        this.resolveCommandPromise(correlationId, decoded)\n        return\n      case protobuf.ReadAllEventsCompleted.ReadAllResult.AccessDenied:\n        err = eventstoreError.newAccessDeniedError(message)\n        break\n      case protobuf.ReadAllEventsCompleted.ReadAllResult.NotModified:\n        err = eventstoreError.newNotModifiedError(message)\n        break\n      default:\n        err = eventstoreError.newUnspecificError(message)\n    }\n    this.rejectCommandPromise(correlationId, err)\n  }\n\n  /**\n   * Handle response for command ReadStreamEvents\n   */\n  protected handleReadStreamEventsCompleted(correlationId: string, payload: Buffer): void {\n    const decoded = protobuf.ReadStreamEventsCompleted.decode(payload)\n    let err: eventstoreError.EventstoreError\n    const message: string = decoded.error || ''\n    switch (decoded.result) {\n      case protobuf.ReadStreamEventsCompleted.ReadStreamResult.Success:\n        this.resolveCommandPromise(correlationId, decoded)\n        return\n      case protobuf.ReadStreamEventsCompleted.ReadStreamResult.NoStream:\n        err = eventstoreError.newNoStreamError(message)\n        break\n      case protobuf.ReadStreamEventsCompleted.ReadStreamResult.NotModified:\n        err = eventstoreError.newNotModifiedError(message)\n        break\n      case protobuf.ReadStreamEventsCompleted.ReadStreamResult.StreamDeleted:\n        err = eventstoreError.newStreamDeletedError(message)\n        break\n      case protobuf.ReadStreamEventsCompleted.ReadStreamResult.AccessDenied:\n        err = eventstoreError.newAccessDeniedError(message)\n        break\n\n      default:\n        err = eventstoreError.newUnspecificError(message)\n    }\n    this.rejectCommandPromise(correlationId, err)\n  }\n\n  /**\n   * Handle response for command ReadEvent\n   */\n  protected handleReadEventCompleted(correlationId: string, payload: Buffer): void {\n    const decoded = protobuf.ReadEventCompleted.decode(payload)\n\n    let err: eventstoreError.EventstoreError\n    const message: string = decoded.error || ''\n    switch (decoded.result) {\n      case protobuf.ReadEventCompleted.ReadEventResult.Success:\n        this.resolveCommandPromise(correlationId, decoded.event)\n        return\n      case protobuf.ReadEventCompleted.ReadEventResult.NotFound:\n        err = eventstoreError.newNotFoundError(message)\n        break\n      case protobuf.ReadEventCompleted.ReadEventResult.NoStream:\n        err = eventstoreError.newNoStreamError(message)\n        break\n      case protobuf.ReadEventCompleted.ReadEventResult.StreamDeleted:\n        err = eventstoreError.newStreamDeletedError(message)\n        break\n      case protobuf.ReadEventCompleted.ReadEventResult.AccessDenied:\n        err = eventstoreError.newAccessDeniedError(message)\n        break\n      default:\n        err = eventstoreError.newUnspecificError(message)\n    }\n    this.rejectCommandPromise(correlationId, err)\n  }\n\n  /**\n   * Handle incoming event for subscription\n   */\n  protected handleStreamEventAppeared(correlationId: string, payload: Buffer): void {\n    const decoded = protobuf.StreamEventAppeared.decode(payload)\n    const subscription = this.subscriptionList.get(correlationId)\n    if (subscription) {\n      const event = Event.fromRaw(decoded.event.event || decoded.event.link)\n      subscription.eventAppeared(\n        event,\n        new Position(decoded.event.commitPosition, decoded.event.preparePosition)\n      )\n    } else {\n      this.log.error(\n        {subscriptionId: correlationId, fn: 'handleStreamEventAppeared'},\n        'Received StreamEventAppeared for unknown id'\n      )\n      this.emit(\n        'error',\n        eventstoreError.newImplementationError(\n          `Received StreamEventAppeared for unknown id ${correlationId}`\n        )\n      )\n    }\n  }\n\n  /**\n   * Handle response for command Subscription\n   */\n  protected handleSubscriptionConfirmation(correlationId: string, payload: Buffer): void {\n    const decoded = protobuf.SubscriptionConfirmation.decode(payload)\n\n    this.resolveCommandPromise(correlationId, {\n      subscriptionId: correlationId,\n      lastCommitPosition: decoded.lastCommitPosition,\n      lastEventNumber: decoded.lastEventNumber\n    })\n  }\n\n  /**\n   * Handle subscription drop\n   */\n  protected handleSubscriptionDropped(correlationId: string, payload: Buffer): void {\n    const decoded = protobuf.SubscriptionDropped.decode(payload)\n    const subscription = this.subscriptionList.get(correlationId) || null\n    if (subscription) {\n      subscription.emit('dropped', SubscriptionDropReason[decoded.reason])\n    }\n    const persistentSubscription = this.persistentSubscriptionList.get(correlationId) || null\n    if (persistentSubscription) {\n      persistentSubscription.emit('dropped', SubscriptionDropReason[decoded.reason])\n    }\n    if (this.pendingRequests.has(correlationId)) {\n      if (decoded.reason === SubscriptionDropReason.Unsubscribed) {\n        this.resolveCommandPromise(correlationId, SubscriptionDropReason[decoded.reason])\n      } else {\n        this.rejectCommandPromise(\n          correlationId,\n          eventstoreError.newUnspecificError(\n            'Subscription dropped: ' + SubscriptionDropReason[decoded.reason]\n          )\n        )\n      }\n    }\n  }\n\n  /**\n   * Handle response for command TransactionCommit\n   */\n  protected handleTransactionCommitCompleted(correlationId: string, payload: Buffer): void {\n    const decoded = protobuf.TransactionCommitCompleted.decode(payload)\n    if (\n      this.checkOperationResult(\n        correlationId,\n        decoded.result,\n        'handleTransactionCommit: ' + decoded.message\n      )\n    ) {\n      const result: WriteResult = {\n        firstEventNumber: decoded.firstEventNumber,\n        lastEventNumber: decoded.lastEventNumber,\n        position: new Position(decoded.commitPosition, decoded.preparePosition)\n      }\n      this.resolveCommandPromise(correlationId, result)\n    }\n  }\n\n  /**\n   * Handle response for command TransactionStart\n   */\n  protected handleTransactionStartCompleted(correlationId: string, payload: Buffer): void {\n    const decoded = protobuf.TransactionStartCompleted.decode(payload)\n    if (\n      this.checkOperationResult(\n        correlationId,\n        decoded.result,\n        'handleTransactionStart: ' + decoded.message\n      )\n    ) {\n      this.resolveCommandPromise(correlationId, decoded.transactionId)\n    }\n  }\n\n  /**\n   * Handles transaction write completed\n   */\n  protected handleTransactionWriteCompleted(correlationId: string, payload: Buffer): void {\n    const decoded = protobuf.TransactionWriteCompleted.decode(payload)\n    if (\n      this.checkOperationResult(\n        correlationId,\n        decoded.result,\n        'handleTransactionWrite: ' + decoded.message\n      )\n    ) {\n      this.resolveCommandPromise(correlationId, decoded.transactionId)\n    }\n  }\n\n  /**\n   * Handles update persistent subscription completed\n   */\n  protected handleUpdatePersistentSubscriptionCompleted(\n    correlationId: string,\n    payload: Buffer\n  ): void {\n    const decoded = protobuf.UpdatePersistentSubscriptionCompleted.decode(payload)\n    const status = protobuf.UpdatePersistentSubscriptionCompleted.UpdatePersistentSubscriptionResult\n    const message = decoded.reason || ''\n    switch (decoded.result) {\n      case status.Success:\n        this.resolveCommandPromise(correlationId)\n        break\n      case status.DoesNotExist:\n        this.rejectCommandPromise(correlationId, eventstoreError.newDoesNotExistError(message))\n        break\n      case status.AccessDenied:\n        this.rejectCommandPromise(correlationId, eventstoreError.newAccessDeniedError(message))\n        break\n      default:\n    }\n  }\n\n  /**\n   * Handles write events completed\n   */\n  protected handleWriteEventsCompleted(correlationId: string, payload: Buffer): void {\n    const decoded = protobuf.WriteEventsCompleted.decode(payload)\n    if (\n      this.checkOperationResult(\n        correlationId,\n        decoded.result,\n        'handleWriteEvents: ' + decoded.message\n      )\n    ) {\n      this.resolveCommandPromise(correlationId, decoded)\n    }\n  }\n\n  /**\n   * Handles persistent subscription confirmation\n   */\n  protected handlePersistentSubscriptionConfirmation(correlationId: string, payload: Buffer): void {\n    const decoded = protobuf.PersistentSubscriptionConfirmation.decode(payload)\n    this.resolveCommandPromise(correlationId, decoded)\n  }\n\n  /**\n   * Handles persistent subscription stream event appeared\n   */\n  protected handlePersistentSubscriptionStreamEventAppeared(\n    correlationId: string,\n    payload: Buffer\n  ): void {\n    const decoded = protobuf.PersistentSubscriptionStreamEventAppeared.decode(payload)\n    const subscription = this.persistentSubscriptionList.get(correlationId)\n    if (subscription) {\n      const event = Event.fromRaw(decoded.event.event || decoded.event.link)\n      subscription.eventAppeared(event)\n    } else {\n      this.log.error(\n        {\n          subscriptionId: correlationId,\n          persistentSubscriptionList: this.persistentSubscriptionList,\n          fn: 'handlePersistentSubscriptionStreamEventAppeared'\n        },\n        'Received PersistentSubscriptionStreamEventAppeared for unknown id'\n      )\n      this.emit(\n        'error',\n        eventstoreError.newImplementationError(\n          `Received PersistentSubscriptionStreamEventAppeared for unknown id ${correlationId}`\n        )\n      )\n    }\n  }\n\n  /**\n   * CHecks if given result is an error code\n   * It returns true for successful result otherwise it returns false.\n   * If result is an error this function rejects corresponding command promise and remove it from command queue\n   */\n  protected checkOperationResult(\n    correlationId: string,\n    result: number,\n    message: string = ''\n  ): boolean {\n    let err: eventstoreError.EventstoreError\n    switch (result) {\n      case protobuf.OperationResult.Success:\n        return true\n      case protobuf.OperationResult.AccessDenied:\n        err = eventstoreError.newAccessDeniedError(message)\n        break\n      case protobuf.OperationResult.CommitTimeout:\n        err = eventstoreError.newCommitTimeoutError(message)\n        break\n      case protobuf.OperationResult.ForwardTimeout:\n        err = eventstoreError.newForwardTimeoutError(message)\n        break\n      case protobuf.OperationResult.InvalidTransaction:\n        err = eventstoreError.newInvalidTransactionError(message)\n        break\n      case protobuf.OperationResult.PrepareTimeout:\n        err = eventstoreError.newPrepareTimeoutError(message)\n        break\n      case protobuf.OperationResult.StreamDeleted:\n        err = eventstoreError.newStreamDeletedError(message)\n        break\n      case protobuf.OperationResult.WrongExpectedVersion:\n        err = eventstoreError.newWrongExpectedVersionError(message)\n        break\n      default:\n        err = eventstoreError.newUnspecificError('Invalid operation result')\n        break\n    }\n    this.rejectCommandPromise(correlationId, err)\n    return false\n  }\n\n  /**\n   * Will be called if a command send to eventstore was replied with an error\n   * In this case corresponding promise will be rejected and removed from queue\n   */\n  protected rejectCommandPromise(\n    correlationId: string,\n    error: eventstoreError.EventstoreError\n  ): void {\n    const resultPromise = this.pendingRequests.get(correlationId)\n    if (resultPromise) {\n      resultPromise.reject(error)\n      this.pendingRequests.delete(correlationId)\n    } else {\n      const err = eventstoreError.newImplementationError(\n        `Could not find correlationId ${correlationId} on rejectCommandPromise`\n      )\n      this.onError(err)\n    }\n  }\n\n  /**\n   * Will be called if a command send to eventstore was replied with success response\n   * In this case corresponding promise will be resolved with result received from eventstore\n   */\n  protected resolveCommandPromise<T>(correlationId: string, result: null | T = null): void {\n    const resultPromise = this.pendingRequests.get(correlationId)\n    if (resultPromise) {\n      resultPromise.resolve(result)\n      this.pendingRequests.delete(correlationId)\n    } else {\n      const err = eventstoreError.newImplementationError(\n        `Could not find correlationId ${correlationId} on resolveCommandPromise`\n      )\n      this.onError(err)\n    }\n  }\n\n  /**\n   * Subscribes to stream\n   */\n  public subscribeToStream(\n    stream: Stream,\n    resolveLinkTos: boolean = true,\n    credentials: UserCredentials | null\n  ): Promise<Subscription> {\n    const newSubscription = new Subscription(uuid(), this, stream, resolveLinkTos, credentials)\n    this.subscriptionList.set(newSubscription.id, newSubscription)\n    return new Promise(\n      (resolve, reject): void => {\n        const resolveFunction = (): void => {\n          newSubscription.isSubscribed = true\n          newSubscription.emit('subscribed')\n          resolve(newSubscription)\n        }\n        const raw = protobuf.SubscribeToStream.fromObject({\n          eventStreamId: stream.id,\n          resolveLinkTos\n        })\n        this.sendCommand(\n          newSubscription.id,\n          EventstoreCommand.SubscribeToStream,\n          Buffer.from(protobuf.SubscribeToStream.encode(raw).finish()),\n          credentials,\n          {\n            resolve: resolveFunction,\n            reject\n          }\n        )\n      }\n    )\n  }\n\n  /**\n   * Unsubscribes from stream\n   */\n  public async unsubscribeFromStream(subscriptionId: string): Promise<void> {\n    const subscription = this.subscriptionList.get(subscriptionId)\n    if (!subscription) {\n      throw eventstoreError.newImplementationError(\n        `Can not unsubscribe - subscription ${subscriptionId} not found`\n      )\n    }\n    const subscriptionList = this.subscriptionList\n    await new Promise(\n      (resolve, reject): void => {\n        const resolveFunction = (): void => {\n          subscription.isSubscribed = false\n          subscriptionList.delete(subscriptionId)\n          resolve()\n        }\n        this.sendCommand(\n          subscription.id,\n          EventstoreCommand.UnsubscribeFromStream,\n          null,\n          subscription.getCredentials,\n          {\n            resolve: resolveFunction,\n            reject\n          }\n        )\n      }\n    )\n  }\n\n  /**\n   * Connects to persistent subscription\n   */\n  public async connectToPersistentSubscription(\n    subscription: PersistentSubscription,\n    allowedInFlightMessages: number = 10,\n    credentials?: UserCredentials | null\n  ): Promise<model.eventstore.proto.PersistentSubscriptionConfirmation> {\n    this.persistentSubscriptionList.set(subscription.id, subscription)\n    const result: model.eventstore.proto.PersistentSubscriptionConfirmation = await new Promise(\n      (resolve, reject): void => {\n        const raw = protobuf.ConnectToPersistentSubscription.fromObject({\n          subscriptionId: subscription.subscriptionGroupName,\n          eventStreamId: subscription.stream.id,\n          allowedInFlightMessages\n        })\n        this.sendCommand(\n          subscription.id,\n          EventstoreCommand.ConnectToPersistentSubscription,\n          Buffer.from(protobuf.ConnectToPersistentSubscription.encode(raw).finish()),\n          credentials,\n          {\n            resolve,\n            reject\n          }\n        )\n      }\n    )\n    subscription.emit('subscribed')\n    subscription.lastCommitPosition = result.lastCommitPosition\n      ? Long.fromValue(result.lastCommitPosition)\n      : Long.fromValue(0)\n    subscription.lastEventNumber = result.lastEventNumber\n      ? Long.fromValue(result.lastEventNumber)\n      : Long.fromValue(-1)\n\n    return result\n  }\n\n  /**\n   * Stop listening on persistent subscription\n   */\n  public async unsubscribeFromPersistentSubscription(\n    subscriptionId: string,\n    credentials?: UserCredentials | null\n  ): Promise<void> {\n    const subscription = this.persistentSubscriptionList.get(subscriptionId)\n    if (!subscription) {\n      throw eventstoreError.newImplementationError(\n        `Can not unsubscribe - persistent subscription ${subscriptionId} not found`\n      )\n    }\n    const subscriptionList = this.persistentSubscriptionList\n    await new Promise(\n      (resolve, reject): void => {\n        const resolveFunction = (): void => {\n          subscription.state = SubscriptionStatus.disconnected\n          subscriptionList.delete(subscriptionId)\n          resolve()\n        }\n        this.sendCommand(\n          subscription.id,\n          EventstoreCommand.UnsubscribeFromStream,\n          null,\n          credentials,\n          {\n            resolve: resolveFunction,\n            reject\n          }\n        )\n      }\n    )\n  }\n\n  /**\n   * Emit general low level connection errors (communication errors).\n   * Will not emit errors on business level\n   */\n  protected onError(err?: Error): void {\n    let errorMessage\n    let error = err ? err : eventstoreError.newConnectionError('Eventstore connection error')\n\n    if (error.name === 'Error') {\n      error = eventstoreError.newConnectionError(error.message, err)\n    }\n    errorMessage = error.message\n    this.log.error({err: error}, errorMessage)\n    this.emit('error', error)\n  }\n\n  /**\n   * Emit as soon as connection to eventstore was established successfully\n   */\n  protected onConnect(): void {\n    this.reconnectCount = 0\n    this.isUnexpectedClosed = true\n    this.log.debug('Connected to eventstore')\n    this.state = connectionState.connected\n    this.emit('connected')\n\n    this.timeoutInterval = setInterval(\n      this.checkTimeout.bind(this),\n      this.initialConfig.operationTimeoutCheckPeriod\n    )\n  }\n\n  /**\n   * Emitted as soon as data arrives over tcp connection\n   */\n  protected onData(data: Buffer | null): void {\n    while (data != null) {\n      if (this.messageData === null) {\n        data = this.handleNewResponseData(data)\n      } else {\n        data = this.handleMultiPacketResponseData(data)\n      }\n    }\n  }\n\n  /**\n   * Emit as soon as connection to eventstore is closed\n   */\n  protected onClose(): void {\n    this.log.debug('Connection to eventstore closed')\n    this.state = connectionState.closed\n    this.emit('close')\n    if (this.isUnexpectedClosed) {\n      this.emit('error', eventstoreError.newConnectionError('Connection closed unexpected'))\n      this.connect()\n    }\n\n    // stop timeout interval\n    if (this.timeoutInterval) {\n      clearInterval(this.timeoutInterval)\n      this.timeoutInterval = null\n    }\n\n    // reject all pending promises\n    this.pendingRequests.forEach(\n      (value): void => {\n        value.reject(eventstoreError.newConnectionError('Connection closed'))\n      }\n    )\n    this.pendingRequests = new Map()\n\n    //drop all subscriptions\n    this.subscriptionList.forEach(\n      (subscription): void => {\n        subscription.emit('dropped', 'Connection closed')\n      }\n    )\n\n    //drop all persistent subscriptions\n    this.persistentSubscriptionList.forEach(\n      (subscription): void => {\n        subscription.emit('dropped', 'Connection closed')\n      }\n    )\n  }\n\n  /**\n   * Emit when connection starts draining\n   */\n  protected onDrain(): void {\n    this.log.debug('Eventstore connection draining')\n    this.state = connectionState.drain\n    this.emit('drain')\n  }\n\n  /**\n   * Emit when connection secured\n   */\n  protected onSecureConnect(): void {\n    this.log.debug('Eventstore connection secured')\n    this.emit('secureConnect')\n  }\n}\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/src/eventstore/TCPConnection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 196,
    "kind": "variable",
    "name": "protobuf",
    "memberof": "src/eventstore/TCPConnection.ts",
    "static": true,
    "longname": "src/eventstore/TCPConnection.ts~protobuf",
    "access": "public",
    "export": false,
    "importPath": "eventstore-ts-client/src/eventstore/TCPConnection.ts",
    "importStyle": null,
    "description": "protobuf shorthand",
    "lineNumber": 27,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 197,
    "kind": "variable",
    "name": "FLAGS_NONE",
    "memberof": "src/eventstore/TCPConnection.ts",
    "static": true,
    "longname": "src/eventstore/TCPConnection.ts~FLAGS_NONE",
    "access": "public",
    "export": false,
    "importPath": "eventstore-ts-client/src/eventstore/TCPConnection.ts",
    "importStyle": null,
    "description": "raw tcp communication constant",
    "lineNumber": 38,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 198,
    "kind": "variable",
    "name": "FLAGS_AUTH",
    "memberof": "src/eventstore/TCPConnection.ts",
    "static": true,
    "longname": "src/eventstore/TCPConnection.ts~FLAGS_AUTH",
    "access": "public",
    "export": false,
    "importPath": "eventstore-ts-client/src/eventstore/TCPConnection.ts",
    "importStyle": null,
    "description": "raw tcp communication constant",
    "lineNumber": 40,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 199,
    "kind": "variable",
    "name": "UINT32_LENGTH",
    "memberof": "src/eventstore/TCPConnection.ts",
    "static": true,
    "longname": "src/eventstore/TCPConnection.ts~UINT32_LENGTH",
    "access": "public",
    "export": false,
    "importPath": "eventstore-ts-client/src/eventstore/TCPConnection.ts",
    "importStyle": null,
    "description": "raw tcp communication constant",
    "lineNumber": 42,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 200,
    "kind": "variable",
    "name": "GUID_LENGTH",
    "memberof": "src/eventstore/TCPConnection.ts",
    "static": true,
    "longname": "src/eventstore/TCPConnection.ts~GUID_LENGTH",
    "access": "public",
    "export": false,
    "importPath": "eventstore-ts-client/src/eventstore/TCPConnection.ts",
    "importStyle": null,
    "description": "raw tcp communication constant",
    "lineNumber": 44,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 201,
    "kind": "variable",
    "name": "HEADER_LENGTH",
    "memberof": "src/eventstore/TCPConnection.ts",
    "static": true,
    "longname": "src/eventstore/TCPConnection.ts~HEADER_LENGTH",
    "access": "public",
    "export": false,
    "importPath": "eventstore-ts-client/src/eventstore/TCPConnection.ts",
    "importStyle": null,
    "description": "raw tcp communication constant",
    "lineNumber": 46,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 202,
    "kind": "variable",
    "name": "COMMAND_OFFSET",
    "memberof": "src/eventstore/TCPConnection.ts",
    "static": true,
    "longname": "src/eventstore/TCPConnection.ts~COMMAND_OFFSET",
    "access": "public",
    "export": false,
    "importPath": "eventstore-ts-client/src/eventstore/TCPConnection.ts",
    "importStyle": null,
    "description": "raw tcp communication constant",
    "lineNumber": 48,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 203,
    "kind": "variable",
    "name": "FLAGS_OFFSET",
    "memberof": "src/eventstore/TCPConnection.ts",
    "static": true,
    "longname": "src/eventstore/TCPConnection.ts~FLAGS_OFFSET",
    "access": "public",
    "export": false,
    "importPath": "eventstore-ts-client/src/eventstore/TCPConnection.ts",
    "importStyle": null,
    "description": "raw tcp communication constant",
    "lineNumber": 50,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 204,
    "kind": "variable",
    "name": "CORRELATION_ID_OFFSET",
    "memberof": "src/eventstore/TCPConnection.ts",
    "static": true,
    "longname": "src/eventstore/TCPConnection.ts~CORRELATION_ID_OFFSET",
    "access": "public",
    "export": false,
    "importPath": "eventstore-ts-client/src/eventstore/TCPConnection.ts",
    "importStyle": null,
    "description": "raw tcp communication constant",
    "lineNumber": 52,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 205,
    "kind": "variable",
    "name": "DATA_OFFSET",
    "memberof": "src/eventstore/TCPConnection.ts",
    "static": true,
    "longname": "src/eventstore/TCPConnection.ts~DATA_OFFSET",
    "access": "public",
    "export": false,
    "importPath": "eventstore-ts-client/src/eventstore/TCPConnection.ts",
    "importStyle": null,
    "description": "raw tcp communication constant",
    "lineNumber": 54,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 206,
    "kind": "class",
    "name": "TCPConnection",
    "memberof": "src/eventstore/TCPConnection.ts",
    "static": true,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/eventstore/TCPConnection.ts",
    "importStyle": "{TCPConnection}",
    "description": "Raw tcp communication to eventstore\nThis class handles basic communication with eventstore",
    "lineNumber": 60,
    "interface": false,
    "extends": [
      "events~EventEmitter"
    ]
  },
  {
    "__docId__": 207,
    "kind": "member",
    "name": "initialConfig",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#initialConfig",
    "access": "protected",
    "description": "initial config",
    "lineNumber": 62,
    "type": {
      "types": [
        "EventstoreSettings"
      ]
    }
  },
  {
    "__docId__": 208,
    "kind": "member",
    "name": "connectionConfig",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#connectionConfig",
    "access": "protected",
    "description": "config after discovery process",
    "lineNumber": 64,
    "type": {
      "types": [
        "EventstoreSettings"
      ]
    }
  },
  {
    "__docId__": 209,
    "kind": "member",
    "name": "socket",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#socket",
    "access": "protected",
    "description": "tcp socket",
    "lineNumber": 66,
    "type": {
      "types": [
        null,
        null
      ]
    }
  },
  {
    "__docId__": 210,
    "kind": "member",
    "name": "connectionId",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#connectionId",
    "access": "protected",
    "description": "connection id",
    "lineNumber": 68,
    "type": {
      "types": [
        "string",
        "null"
      ]
    }
  },
  {
    "__docId__": 211,
    "kind": "member",
    "name": "pendingRequests",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#pendingRequests",
    "access": "protected",
    "description": "list of pending requests",
    "lineNumber": 70,
    "type": {
      "types": [
        "Map"
      ]
    }
  },
  {
    "__docId__": 212,
    "kind": "member",
    "name": "timeoutInterval",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#timeoutInterval",
    "access": "protected",
    "description": "timeout interval for timed out pending requests",
    "lineNumber": 75,
    "type": {
      "types": [
        "null",
        null
      ]
    }
  },
  {
    "__docId__": 213,
    "kind": "member",
    "name": "log",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#log",
    "access": "public",
    "description": "logger instance",
    "lineNumber": 77,
    "type": {
      "types": [
        "bunyan"
      ]
    }
  },
  {
    "__docId__": 214,
    "kind": "member",
    "name": "state",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#state",
    "access": "protected",
    "description": "connection state",
    "lineNumber": 79,
    "type": {
      "types": [
        "connectionState"
      ]
    }
  },
  {
    "__docId__": 215,
    "kind": "member",
    "name": "messageCurrentOffset",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#messageCurrentOffset",
    "access": "protected",
    "description": "message offset of tcp data",
    "lineNumber": 81,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 216,
    "kind": "member",
    "name": "messageCurrentLength",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#messageCurrentLength",
    "access": "protected",
    "description": "message length of tcp data",
    "lineNumber": 83,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 217,
    "kind": "member",
    "name": "messageData",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#messageData",
    "access": "protected",
    "description": "message buffer of tcp data",
    "lineNumber": 85,
    "type": {
      "types": [
        "Buffer",
        "null"
      ]
    }
  },
  {
    "__docId__": 218,
    "kind": "member",
    "name": "subscriptionList",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#subscriptionList",
    "access": "protected",
    "description": "list of subscriptions",
    "lineNumber": 87,
    "type": {
      "types": [
        "Map"
      ]
    }
  },
  {
    "__docId__": 219,
    "kind": "member",
    "name": "persistentSubscriptionList",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#persistentSubscriptionList",
    "access": "protected",
    "description": "list of persistent subscriptions",
    "lineNumber": 89,
    "type": {
      "types": [
        "Map"
      ]
    }
  },
  {
    "__docId__": 220,
    "kind": "member",
    "name": "isUnexpectedClosed",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#isUnexpectedClosed",
    "access": "protected",
    "description": "indicates if connection close is wanted by user or not",
    "lineNumber": 91,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 221,
    "kind": "member",
    "name": "reconnectCount",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#reconnectCount",
    "access": "protected",
    "description": "counter for re-connections",
    "lineNumber": 93,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 222,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#constructor",
    "access": "public",
    "description": "Creates an instance of TCPConnection.",
    "lineNumber": 98
  },
  {
    "__docId__": 227,
    "kind": "get",
    "name": "isConnected",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#isConnected",
    "access": "public",
    "description": "Returns true if connected to eventstore otherwise false",
    "lineNumber": 112,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 228,
    "kind": "method",
    "name": "connect",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#connect",
    "access": "public",
    "description": "Called to connect to eventstore",
    "lineNumber": 119,
    "params": [],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 231,
    "kind": "method",
    "name": "tryToConnect",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#tryToConnect",
    "access": "protected",
    "description": "Connect to eventstore",
    "lineNumber": 144,
    "params": [],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 235,
    "kind": "method",
    "name": "disconnect",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#disconnect",
    "access": "public",
    "description": "Disconnect from eventstore.\nIt tries to drain pending queue to prevent data loose before connection gets closed\nIf disconnect() is call no new outgoing requests accepted",
    "lineNumber": 227,
    "params": [],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 239,
    "kind": "method",
    "name": "checkTimeout",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#checkTimeout",
    "access": "protected",
    "description": "Called by interval function to check if there are some pending requests which should be rejected with time out error",
    "lineNumber": 271,
    "params": [],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 240,
    "kind": "method",
    "name": "sendCommand",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#sendCommand",
    "access": "public",
    "description": "Creates and sends raw data message to eventstore and adds given promise to pending queue",
    "lineNumber": 295,
    "params": [
      {
        "types": [],
        "name": "correlationId"
      },
      {
        "types": [
          "EventstoreCommand"
        ],
        "name": "command"
      },
      {
        "types": [
          "Buffer",
          "null"
        ],
        "name": "data",
        "optional": true,
        "defaultRaw": null,
        "defaultValue": "null"
      },
      {
        "types": [
          "UserCredentials",
          "null"
        ],
        "name": "credentials",
        "optional": true,
        "defaultRaw": null,
        "defaultValue": "null"
      },
      {
        "types": [
          "null"
        ],
        "name": "promise",
        "optional": true,
        "defaultRaw": null,
        "defaultValue": "null"
      }
    ],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 241,
    "kind": "method",
    "name": "handleNewResponseData",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#handleNewResponseData",
    "access": "protected",
    "description": "Gets called as soon as new data over tcp connection arrives as raw buffer data\nChecks if\n- new received data is part of previously received data\n- new data contains multiple responses\n- new data is single response",
    "lineNumber": 367,
    "params": [
      {
        "types": [
          "Buffer"
        ],
        "name": "data"
      }
    ],
    "type": {
      "types": [
        "Buffer",
        "null"
      ]
    }
  },
  {
    "__docId__": 245,
    "kind": "method",
    "name": "handleMultiPacketResponseData",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#handleMultiPacketResponseData",
    "access": "protected",
    "description": "This function handles raw buffer responses received within multiple tcp data package",
    "lineNumber": 403,
    "params": [
      {
        "types": [
          "Buffer"
        ],
        "name": "data"
      }
    ],
    "type": {
      "types": [
        "Buffer",
        "null"
      ]
    }
  },
  {
    "__docId__": 249,
    "kind": "method",
    "name": "handleSingleResponseData",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#handleSingleResponseData",
    "access": "protected",
    "description": "This function handles a single raw buffer response",
    "lineNumber": 421,
    "params": [
      {
        "types": [
          "Buffer"
        ],
        "name": "data"
      }
    ],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 250,
    "kind": "method",
    "name": "handleCreatePersistentSubscriptionCompleted",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#handleCreatePersistentSubscriptionCompleted",
    "access": "protected",
    "description": "Handle response for command CreatePersistentSubscription",
    "lineNumber": 561,
    "params": [
      {
        "types": [],
        "name": "correlationId"
      },
      {
        "types": [
          "Buffer"
        ],
        "name": "payload"
      }
    ],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 251,
    "kind": "method",
    "name": "handleDeletePersistentSubscriptionCompleted",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#handleDeletePersistentSubscriptionCompleted",
    "access": "protected",
    "description": "Handle response for command DeletePersistentSubscription",
    "lineNumber": 598,
    "params": [
      {
        "types": [],
        "name": "correlationId"
      },
      {
        "types": [
          "Buffer"
        ],
        "name": "payload"
      }
    ],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 252,
    "kind": "method",
    "name": "handleDeleteStreamCompleted",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#handleDeleteStreamCompleted",
    "access": "protected",
    "description": "Handle response for command DeleteStreamCompleted",
    "lineNumber": 631,
    "params": [
      {
        "types": [],
        "name": "correlationId"
      },
      {
        "types": [
          "Buffer"
        ],
        "name": "payload"
      }
    ],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 253,
    "kind": "method",
    "name": "handleReadAllEventsCompleted",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#handleReadAllEventsCompleted",
    "access": "protected",
    "description": "Handle response for command ReadAllEvents",
    "lineNumber": 650,
    "params": [
      {
        "types": [],
        "name": "correlationId"
      },
      {
        "types": [
          "Buffer"
        ],
        "name": "payload"
      }
    ],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 254,
    "kind": "method",
    "name": "handleReadStreamEventsCompleted",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#handleReadStreamEventsCompleted",
    "access": "protected",
    "description": "Handle response for command ReadStreamEvents",
    "lineNumber": 673,
    "params": [
      {
        "types": [],
        "name": "correlationId"
      },
      {
        "types": [
          "Buffer"
        ],
        "name": "payload"
      }
    ],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 255,
    "kind": "method",
    "name": "handleReadEventCompleted",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#handleReadEventCompleted",
    "access": "protected",
    "description": "Handle response for command ReadEvent",
    "lineNumber": 703,
    "params": [
      {
        "types": [],
        "name": "correlationId"
      },
      {
        "types": [
          "Buffer"
        ],
        "name": "payload"
      }
    ],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 256,
    "kind": "method",
    "name": "handleStreamEventAppeared",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#handleStreamEventAppeared",
    "access": "protected",
    "description": "Handle incoming event for subscription",
    "lineNumber": 733,
    "params": [
      {
        "types": [],
        "name": "correlationId"
      },
      {
        "types": [
          "Buffer"
        ],
        "name": "payload"
      }
    ],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 257,
    "kind": "method",
    "name": "handleSubscriptionConfirmation",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#handleSubscriptionConfirmation",
    "access": "protected",
    "description": "Handle response for command Subscription",
    "lineNumber": 759,
    "params": [
      {
        "types": [],
        "name": "correlationId"
      },
      {
        "types": [
          "Buffer"
        ],
        "name": "payload"
      }
    ],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 258,
    "kind": "method",
    "name": "handleSubscriptionDropped",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#handleSubscriptionDropped",
    "access": "protected",
    "description": "Handle subscription drop",
    "lineNumber": 772,
    "params": [
      {
        "types": [],
        "name": "correlationId"
      },
      {
        "types": [
          "Buffer"
        ],
        "name": "payload"
      }
    ],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 259,
    "kind": "method",
    "name": "handleTransactionCommitCompleted",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#handleTransactionCommitCompleted",
    "access": "protected",
    "description": "Handle response for command TransactionCommit",
    "lineNumber": 799,
    "params": [
      {
        "types": [],
        "name": "correlationId"
      },
      {
        "types": [
          "Buffer"
        ],
        "name": "payload"
      }
    ],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 260,
    "kind": "method",
    "name": "handleTransactionStartCompleted",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#handleTransactionStartCompleted",
    "access": "protected",
    "description": "Handle response for command TransactionStart",
    "lineNumber": 820,
    "params": [
      {
        "types": [],
        "name": "correlationId"
      },
      {
        "types": [
          "Buffer"
        ],
        "name": "payload"
      }
    ],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 261,
    "kind": "method",
    "name": "handleTransactionWriteCompleted",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#handleTransactionWriteCompleted",
    "access": "protected",
    "description": "Handles transaction write completed",
    "lineNumber": 836,
    "params": [
      {
        "types": [],
        "name": "correlationId"
      },
      {
        "types": [
          "Buffer"
        ],
        "name": "payload"
      }
    ],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 262,
    "kind": "method",
    "name": "handleUpdatePersistentSubscriptionCompleted",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#handleUpdatePersistentSubscriptionCompleted",
    "access": "protected",
    "description": "Handles update persistent subscription completed",
    "lineNumber": 852,
    "params": [
      {
        "types": [],
        "name": "correlationId"
      },
      {
        "types": [
          "Buffer"
        ],
        "name": "payload"
      }
    ],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 263,
    "kind": "method",
    "name": "handleWriteEventsCompleted",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#handleWriteEventsCompleted",
    "access": "protected",
    "description": "Handles write events completed",
    "lineNumber": 876,
    "params": [
      {
        "types": [],
        "name": "correlationId"
      },
      {
        "types": [
          "Buffer"
        ],
        "name": "payload"
      }
    ],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 264,
    "kind": "method",
    "name": "handlePersistentSubscriptionConfirmation",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#handlePersistentSubscriptionConfirmation",
    "access": "protected",
    "description": "Handles persistent subscription confirmation",
    "lineNumber": 892,
    "params": [
      {
        "types": [],
        "name": "correlationId"
      },
      {
        "types": [
          "Buffer"
        ],
        "name": "payload"
      }
    ],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 265,
    "kind": "method",
    "name": "handlePersistentSubscriptionStreamEventAppeared",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#handlePersistentSubscriptionStreamEventAppeared",
    "access": "protected",
    "description": "Handles persistent subscription stream event appeared",
    "lineNumber": 900,
    "params": [
      {
        "types": [],
        "name": "correlationId"
      },
      {
        "types": [
          "Buffer"
        ],
        "name": "payload"
      }
    ],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 266,
    "kind": "method",
    "name": "checkOperationResult",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#checkOperationResult",
    "access": "protected",
    "description": "CHecks if given result is an error code\nIt returns true for successful result otherwise it returns false.\nIf result is an error this function rejects corresponding command promise and remove it from command queue",
    "lineNumber": 932,
    "params": [
      {
        "types": [],
        "name": "correlationId"
      },
      {
        "types": [],
        "name": "result"
      },
      {
        "types": [
          "string"
        ],
        "name": "message",
        "optional": true,
        "defaultRaw": "",
        "defaultValue": ""
      }
    ],
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 267,
    "kind": "method",
    "name": "rejectCommandPromise",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#rejectCommandPromise",
    "access": "protected",
    "description": "Will be called if a command send to eventstore was replied with an error\nIn this case corresponding promise will be rejected and removed from queue",
    "lineNumber": 974,
    "params": [
      {
        "types": [],
        "name": "correlationId"
      },
      {
        "types": [],
        "name": "error"
      }
    ],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 268,
    "kind": "method",
    "name": "resolveCommandPromise",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#resolveCommandPromise",
    "access": "protected",
    "description": "Will be called if a command send to eventstore was replied with success response\nIn this case corresponding promise will be resolved with result received from eventstore",
    "lineNumber": 994,
    "params": [
      {
        "types": [],
        "name": "correlationId"
      },
      {
        "types": [
          "null",
          "T"
        ],
        "name": "result",
        "optional": true,
        "defaultRaw": null,
        "defaultValue": "null"
      }
    ],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 269,
    "kind": "method",
    "name": "subscribeToStream",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#subscribeToStream",
    "access": "public",
    "description": "Subscribes to stream",
    "lineNumber": 1010,
    "params": [
      {
        "types": [
          "Stream"
        ],
        "name": "stream"
      },
      {
        "types": [
          "boolean"
        ],
        "name": "resolveLinkTos",
        "optional": true,
        "defaultRaw": true,
        "defaultValue": "true"
      },
      {
        "types": [
          "UserCredentials",
          "null"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 270,
    "kind": "method",
    "name": "unsubscribeFromStream",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#unsubscribeFromStream",
    "access": "public",
    "description": "Unsubscribes from stream",
    "lineNumber": 1045,
    "params": [
      {
        "types": [],
        "name": "subscriptionId"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 271,
    "kind": "method",
    "name": "connectToPersistentSubscription",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#connectToPersistentSubscription",
    "access": "public",
    "description": "Connects to persistent subscription",
    "lineNumber": 1077,
    "params": [
      {
        "types": [
          "PersistentSubscription"
        ],
        "name": "subscription"
      },
      {
        "types": [
          "number"
        ],
        "name": "allowedInFlightMessages",
        "optional": true,
        "defaultRaw": 10,
        "defaultValue": "10"
      },
      {
        "types": [
          "UserCredentials",
          "null"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 272,
    "kind": "method",
    "name": "unsubscribeFromPersistentSubscription",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#unsubscribeFromPersistentSubscription",
    "access": "public",
    "description": "Stop listening on persistent subscription",
    "lineNumber": 1116,
    "params": [
      {
        "types": [],
        "name": "subscriptionId"
      },
      {
        "types": [
          "UserCredentials",
          "null"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 273,
    "kind": "method",
    "name": "onError",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#onError",
    "access": "protected",
    "description": "Emit general low level connection errors (communication errors).\nWill not emit errors on business level",
    "lineNumber": 1152,
    "params": [
      {
        "types": [
          "Error"
        ],
        "name": "err"
      }
    ],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 274,
    "kind": "method",
    "name": "onConnect",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#onConnect",
    "access": "protected",
    "description": "Emit as soon as connection to eventstore was established successfully",
    "lineNumber": 1167,
    "params": [],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 279,
    "kind": "method",
    "name": "onData",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#onData",
    "access": "protected",
    "description": "Emitted as soon as data arrives over tcp connection",
    "lineNumber": 1183,
    "params": [
      {
        "types": [
          "Buffer",
          "null"
        ],
        "name": "data"
      }
    ],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 280,
    "kind": "method",
    "name": "onClose",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#onClose",
    "access": "protected",
    "description": "Emit as soon as connection to eventstore is closed",
    "lineNumber": 1196,
    "params": [],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 284,
    "kind": "method",
    "name": "onDrain",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#onDrain",
    "access": "protected",
    "description": "Emit when connection starts draining",
    "lineNumber": 1237,
    "params": [],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 286,
    "kind": "method",
    "name": "onSecureConnect",
    "memberof": "src/eventstore/TCPConnection.ts~TCPConnection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/eventstore/TCPConnection.ts~TCPConnection#onSecureConnect",
    "access": "protected",
    "description": "Emit when connection secured",
    "lineNumber": 1246,
    "params": [],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 287,
    "kind": "file",
    "name": "src/eventstore/getConnectInfo.ts",
    "content": "import * as dns from 'dns'\nimport * as util from 'util'\nimport * as request from 'request-promise-native'\nimport * as bunyan from 'bunyan'\nimport {JSONValue} from '../JSON'\nimport {URL} from 'url'\nimport {EventstoreSettings} from './EventstoreSettings'\n\n/**\n * dns lookup for given domain and returns list of corresponding ip's\n */\nexport const getIpListFromDns = async (dnsServer: string, log: bunyan): Promise<string[]> => {\n  const lookup = util.promisify(dns.lookup)\n  const dnsOptions = {\n    family: 4,\n    hints: dns.ADDRCONFIG | dns.V4MAPPED,\n    all: true\n  }\n  log.debug({dnsServer}, 'Fetch ip list from dns')\n  let ipList: string[] = []\n\n  try {\n    const result:\n      | {address: string | dns.LookupAddress[]; family?: number}\n      | dns.LookupAddress[] = await lookup(dnsServer, dnsOptions)\n\n    if (Array.isArray(result)) {\n      ipList = result.map((entry: dns.LookupAddress): string => entry.address)\n    }\n    log.debug({dnsServer, ipList}, 'Finished dns lookup')\n  } catch (err) {\n    log.error({err}, 'Failed to fetch dns information')\n  }\n\n  return ipList\n}\n\n/**\n * tries to fetch gossip json information from given ip and port\n */\nexport const fetchgossipJson = async (\n  host: string,\n  port: number,\n  useHttps: boolean,\n  timeout: number,\n  log: bunyan\n): Promise<\n  | JSONValue & {\n      members: {\n        state: string\n        externalTcpIp: string\n        externalTcpPort: number\n        externalSecureTcpPort: number\n        isAlive: boolean\n      }[]\n    }\n  | null\n> => {\n  let gossipInfo = null\n  const protocol = useHttps ? 'https' : 'http'\n  try {\n    log.debug({host, protocol, port}, 'Try to fetch gossip info')\n    gossipInfo = await request.get({\n      uri: `${protocol}://${host}:${port}/gossip?format=json`,\n      json: true,\n      timeout\n    })\n  } catch (err) {\n    log.error({err}, 'No gossip info found')\n  }\n  return gossipInfo\n}\n\n/**\n * Searches for master node inside of gossip json\n */\nexport const getMasterNodeInfo = (\n  gossipInfo: JSONValue & {\n    members: {\n      state: string\n      externalTcpIp: string\n      externalTcpPort: number\n      externalSecureTcpPort: number\n      isAlive: boolean\n    }[]\n  }\n): {ip: string; tcpPort: number; tcpSecurePort: number} | null => {\n  let nodeInfo = null\n\n  const aliveList = gossipInfo.members.filter(\n    (entry): boolean => entry.isAlive && entry.state.toLowerCase() === 'master'\n  )\n  if (aliveList.length > 0) {\n    nodeInfo = {\n      ip: aliveList[0].externalTcpIp,\n      tcpPort: aliveList[0].externalTcpPort,\n      tcpSecurePort: aliveList[0].externalSecureTcpPort\n    }\n  }\n\n  return nodeInfo\n}\n\n/**\n * Gets a random cluster node from gossip json\n */\nexport const getRandomNodeInfo = (\n  gossipInfo: JSONValue & {\n    members: {\n      state: string\n      externalTcpIp: string\n      externalTcpPort: number\n      externalSecureTcpPort: number\n      isAlive: boolean\n    }[]\n  }\n): {ip: string; tcpPort: number; tcpSecurePort: number} | null => {\n  let nodeInfo = null\n\n  const aliveList = gossipInfo.members.filter(\n    (entry): boolean => {\n      const skipItWhen = ['manager', 'shuttingdown', 'shutdown']\n      return entry.isAlive && !skipItWhen.includes(entry.state)\n    }\n  )\n  if (aliveList.length > 0) {\n    const pos = Math.floor(Math.random() * aliveList.length)\n    nodeInfo = {\n      ip: aliveList[pos].externalTcpIp,\n      tcpPort: aliveList[pos].externalTcpPort,\n      tcpSecurePort: aliveList[pos].externalSecureTcpPort\n    }\n  }\n\n  return nodeInfo\n}\n\n/**\n * Updates connection information depending on given settings\n */\nexport const getIpAndPort = async (\n  currentSettings: EventstoreSettings,\n  log: bunyan\n): Promise<EventstoreSettings> => {\n  let gossipJson:\n    | JSONValue & {\n        members: {\n          state: string\n          externalTcpIp: string\n          externalTcpPort: number\n          externalSecureTcpPort: number\n          isAlive: boolean\n        }[]\n      }\n    | null = null\n\n  if (currentSettings.uri && currentSettings.uri !== '') {\n    const esUrl = new URL(currentSettings.uri)\n\n    if (esUrl.username && esUrl.username !== '') {\n      currentSettings.credentials.username = esUrl.username\n    }\n    if (esUrl.password && esUrl.password !== '') {\n      currentSettings.credentials.password = esUrl.password\n    }\n\n    if (currentSettings.uri.toLowerCase().startsWith('tcp')) {\n      //single node connection\n      log.debug('Config for single node connection found')\n      currentSettings.port = parseInt(esUrl.port) || 1113\n      currentSettings.host = esUrl.hostname\n      return currentSettings\n    } else if (currentSettings.uri.toLowerCase().startsWith('discover')) {\n      log.debug('Config for discover node connection found')\n      //gossip\n      gossipJson = await fetchgossipJson(\n        esUrl.hostname,\n        parseInt(esUrl.port),\n        currentSettings.useHttps,\n        currentSettings.gossipTimeout,\n        log\n      )\n    }\n  } else {\n    //if we have a dns server we look for cluster node ip's\n    if (currentSettings.clusterDns && currentSettings.clusterDns !== '') {\n      const ipList = await getIpListFromDns(currentSettings.clusterDns, log)\n      if (ipList.length > 0) {\n        log.debug(`Found ${ipList.length} entries in DNS record`)\n        //add dns lookup ip list\n        const updatedList = ipList.concat(currentSettings.gossipSeeds)\n        //remove duplicates from list\n        currentSettings.gossipSeeds = [...new Set(updatedList)]\n      }\n    }\n\n    //if we've a list of ip's we try to fetch gossipJson\n    if (currentSettings.gossipSeeds.length > 0) {\n      log.debug(\n        `Try to find gossipJson from seed list of ${currentSettings.gossipSeeds.length} entries`\n      )\n      let found = false\n      for (\n        let x = 0, xMax = currentSettings.gossipSeeds.length;\n        x < xMax && !found && x < currentSettings.maxDiscoverAttempts;\n        x++\n      ) {\n        const res = await await fetchgossipJson(\n          currentSettings.gossipSeeds[x],\n          currentSettings.externalGossipPort,\n          currentSettings.useHttps,\n          currentSettings.gossipTimeout,\n          log\n        )\n        if (res) {\n          found = true\n          gossipJson = res\n        }\n      }\n    } else {\n      log.debug('Gossip seed list empty')\n    }\n  }\n\n  if (!gossipJson) {\n    log.warn('Could not get any gossip info')\n    return currentSettings\n  }\n\n  let nodeInfo: {ip: string; tcpPort: number; tcpSecurePort: number} | null = null\n\n  if (currentSettings.requireMaster) {\n    nodeInfo = getMasterNodeInfo(gossipJson)\n    log.debug({nodeInfo}, 'Selecting master node')\n  } else {\n    nodeInfo = getRandomNodeInfo(gossipJson)\n    log.debug({nodeInfo}, 'Selecting unspecific node')\n  }\n\n  if (nodeInfo) {\n    currentSettings.host = nodeInfo.ip\n    currentSettings.port = currentSettings.useSSL ? nodeInfo.tcpSecurePort : nodeInfo.tcpPort\n  }\n\n  return currentSettings\n}\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/src/eventstore/getConnectInfo.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 288,
    "kind": "function",
    "name": "getIpListFromDns",
    "memberof": "src/eventstore/getConnectInfo.ts",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/eventstore/getConnectInfo.ts~getIpListFromDns",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/eventstore/getConnectInfo.ts",
    "importStyle": "{getIpListFromDns}",
    "description": "dns lookup for given domain and returns list of corresponding ip's",
    "lineNumber": 12,
    "params": [
      {
        "types": [],
        "name": "dnsServer"
      },
      {
        "types": [
          "bunyan"
        ],
        "name": "log"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 289,
    "kind": "function",
    "name": "fetchgossipJson",
    "memberof": "src/eventstore/getConnectInfo.ts",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/eventstore/getConnectInfo.ts~fetchgossipJson",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/eventstore/getConnectInfo.ts",
    "importStyle": "{fetchgossipJson}",
    "description": "tries to fetch gossip json information from given ip and port",
    "lineNumber": 41,
    "params": [
      {
        "types": [],
        "name": "host"
      },
      {
        "types": [],
        "name": "port"
      },
      {
        "types": [],
        "name": "useHttps"
      },
      {
        "types": [],
        "name": "timeout"
      },
      {
        "types": [
          "bunyan"
        ],
        "name": "log"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 290,
    "kind": "function",
    "name": "getMasterNodeInfo",
    "memberof": "src/eventstore/getConnectInfo.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/eventstore/getConnectInfo.ts~getMasterNodeInfo",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/eventstore/getConnectInfo.ts",
    "importStyle": "{getMasterNodeInfo}",
    "description": "Searches for master node inside of gossip json",
    "lineNumber": 77,
    "params": [
      {
        "types": [],
        "name": "gossipInfo"
      }
    ],
    "type": {
      "types": [
        null,
        "null"
      ]
    }
  },
  {
    "__docId__": 291,
    "kind": "function",
    "name": "getRandomNodeInfo",
    "memberof": "src/eventstore/getConnectInfo.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/eventstore/getConnectInfo.ts~getRandomNodeInfo",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/eventstore/getConnectInfo.ts",
    "importStyle": "{getRandomNodeInfo}",
    "description": "Gets a random cluster node from gossip json",
    "lineNumber": 107,
    "params": [
      {
        "types": [],
        "name": "gossipInfo"
      }
    ],
    "type": {
      "types": [
        null,
        "null"
      ]
    }
  },
  {
    "__docId__": 292,
    "kind": "function",
    "name": "getIpAndPort",
    "memberof": "src/eventstore/getConnectInfo.ts",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/eventstore/getConnectInfo.ts~getIpAndPort",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/eventstore/getConnectInfo.ts",
    "importStyle": "{getIpAndPort}",
    "description": "Updates connection information depending on given settings",
    "lineNumber": 141,
    "params": [
      {
        "types": [
          "EventstoreSettings"
        ],
        "name": "currentSettings"
      },
      {
        "types": [
          "bunyan"
        ],
        "name": "log"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 293,
    "kind": "file",
    "name": "src/eventstore/index.ts",
    "content": "export {Eventstore, WriteResult} from './Eventstore'\nexport {EventstoreSettings, UserCredentials} from './EventstoreSettings'\nexport {Position} from './Position'\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/src/eventstore/index.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 294,
    "kind": "file",
    "name": "src/index.ts",
    "content": "export {Eventstore, EventstoreSettings, UserCredentials, Position, WriteResult} from './eventstore'\nexport {Event} from './event'\nexport {ExpectedVersion} from './protobuf/ExpectedVersion'\nexport {uuidToBuffer, uuidFromBuffer} from './protobuf/uuidBufferConvert'\nexport {StreamPosition, Stream} from './stream'\nexport {\n  PersistentSubscriptionConfig,\n  SystemConsumerStrategies,\n  SubscriptionStatus,\n  SubscriptionDropReason,\n  NakAction\n} from './subscription'\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/src/index.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 295,
    "kind": "file",
    "name": "src/protobuf/EventstoreCommand.ts",
    "content": "/** List of possible eventstore command/response flags */\nexport enum EventstoreCommand {\n  HeartbeatRequestCommand = 0x01,\n  HeartbeatResponseCommand = 0x02,\n\n  Ping = 0x03,\n  Pong = 0x04,\n\n  PrepareAck = 0x05,\n  CommitAck = 0x06,\n\n  SlaveAssignment = 0x07,\n  CloneAssignment = 0x08,\n\n  SubscribeReplica = 0x10,\n  ReplicaLogPositionAck = 0x11,\n  CreateChunk = 0x12,\n  RawChunkBulk = 0x13,\n  DataChunkBulk = 0x14,\n  ReplicaSubscriptionRetry = 0x15,\n  ReplicaSubscribed = 0x16,\n\n  WriteEvents = 0x82,\n  WriteEventsCompleted = 0x83,\n\n  TransactionStart = 0x84,\n  TransactionStartCompleted = 0x85,\n  TransactionWrite = 0x86,\n  TransactionWriteCompleted = 0x87,\n  TransactionCommit = 0x88,\n  TransactionCommitCompleted = 0x89,\n\n  DeleteStream = 0x8a,\n  DeleteStreamCompleted = 0x8b,\n\n  ReadEvent = 0xb0,\n  ReadEventCompleted = 0xb1,\n  ReadStreamEventsForward = 0xb2,\n  ReadStreamEventsForwardCompleted = 0xb3,\n  ReadStreamEventsBackward = 0xb4,\n  ReadStreamEventsBackwardCompleted = 0xb5,\n  ReadAllEventsForward = 0xb6,\n  ReadAllEventsForwardCompleted = 0xb7,\n  ReadAllEventsBackward = 0xb8,\n  ReadAllEventsBackwardCompleted = 0xb9,\n\n  SubscribeToStream = 0xc0,\n  SubscriptionConfirmation = 0xc1,\n  StreamEventAppeared = 0xc2,\n  UnsubscribeFromStream = 0xc3,\n  SubscriptionDropped = 0xc4,\n  ConnectToPersistentSubscription = 0xc5,\n  PersistentSubscriptionConfirmation = 0xc6,\n  PersistentSubscriptionStreamEventAppeared = 0xc7,\n  CreatePersistentSubscription = 0xc8,\n  CreatePersistentSubscriptionCompleted = 0xc9,\n  DeletePersistentSubscription = 0xca,\n  DeletePersistentSubscriptionCompleted = 0xcb,\n  PersistentSubscriptionAckEvents = 0xcc,\n  PersistentSubscriptionNakEvents = 0xcd,\n  UpdatePersistentSubscription = 0xce,\n  UpdatePersistentSubscriptionCompleted = 0xcf,\n\n  ScavengeDatabase = 0xd0,\n  ScavengeDatabaseCompleted = 0xd1,\n\n  BadRequest = 0xf0,\n  NotHandled = 0xf1,\n  Authenticate = 0xf2,\n  Authenticated = 0xf3,\n  NotAuthenticated = 0xf4,\n  IdentifyClient = 0xf5,\n  ClientIdentified = 0xf6\n}\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/src/protobuf/EventstoreCommand.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 296,
    "kind": "file",
    "name": "src/protobuf/ExpectedVersion.ts",
    "content": "/**\n * @typedef {object} ExpectedVersion\n * - StreamExists\n * - Any\n * - NoStream\n * - EmptyStream\n */\nexport enum ExpectedVersion {\n  StreamExists = -4,\n  Any = -2,\n  NoStream = -1,\n  EmptyStream = -1\n}\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/src/protobuf/ExpectedVersion.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 297,
    "kind": "typedef",
    "name": "ExpectedVersion",
    "memberof": "src/protobuf/ExpectedVersion.ts",
    "static": true,
    "longname": "src/protobuf/ExpectedVersion.ts~ExpectedVersion",
    "access": "public",
    "description": "",
    "lineNumber": 8,
    "type": {
      "types": [
        "object"
      ],
      "optional": false,
      "name": "ExpectedVersion"
    }
  },
  {
    "__docId__": 298,
    "kind": "file",
    "name": "src/protobuf/model.d.ts",
    "content": "import * as $protobuf from 'protobufjs'\n/** Namespace eventstore. */\nexport namespace eventstore {\n  /** Namespace proto. */\n  namespace proto {\n    /** OperationResult enum. */\n    enum OperationResult {\n      Success = 0,\n      PrepareTimeout = 1,\n      CommitTimeout = 2,\n      ForwardTimeout = 3,\n      WrongExpectedVersion = 4,\n      StreamDeleted = 5,\n      InvalidTransaction = 6,\n      AccessDenied = 7\n    }\n\n    /** Properties of a NewEvent. */\n    interface INewEvent {\n      /** NewEvent eventId */\n      eventId: Uint8Array\n\n      /** NewEvent eventType */\n      eventType: string\n\n      /** NewEvent dataContentType */\n      dataContentType: number\n\n      /** NewEvent metadataContentType */\n      metadataContentType: number\n\n      /** NewEvent data */\n      data: Uint8Array\n\n      /** NewEvent metadata */\n      metadata?: Uint8Array | null\n    }\n\n    /** Represents a NewEvent. */\n    class NewEvent implements INewEvent {\n      /**\n       * Constructs a new NewEvent.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.INewEvent)\n\n      /** NewEvent eventId. */\n      public eventId: Uint8Array\n\n      /** NewEvent eventType. */\n      public eventType: string\n\n      /** NewEvent dataContentType. */\n      public dataContentType: number\n\n      /** NewEvent metadataContentType. */\n      public metadataContentType: number\n\n      /** NewEvent data. */\n      public data: Uint8Array\n\n      /** NewEvent metadata. */\n      public metadata: Uint8Array\n\n      /**\n       * Creates a new NewEvent instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns NewEvent instance\n       */\n      public static create(properties?: eventstore.proto.INewEvent): eventstore.proto.NewEvent\n\n      /**\n       * Encodes the specified NewEvent message. Does not implicitly {@link eventstore.proto.NewEvent.verify|verify} messages.\n       * @param message NewEvent message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.INewEvent,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified NewEvent message, length delimited. Does not implicitly {@link eventstore.proto.NewEvent.verify|verify} messages.\n       * @param message NewEvent message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.INewEvent,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes a NewEvent message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns NewEvent\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.NewEvent\n\n      /**\n       * Decodes a NewEvent message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns NewEvent\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.NewEvent\n\n      /**\n       * Verifies a NewEvent message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates a NewEvent message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns NewEvent\n       */\n      public static fromObject(object: {[k: string]: any}): eventstore.proto.NewEvent\n\n      /**\n       * Creates a plain object from a NewEvent message. Also converts values to other types if specified.\n       * @param message NewEvent\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.NewEvent,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this NewEvent to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    /** Properties of an EventRecord. */\n    interface IEventRecord {\n      /** EventRecord eventStreamId */\n      eventStreamId: string\n\n      /** EventRecord eventNumber */\n      eventNumber: number | Long\n\n      /** EventRecord eventId */\n      eventId: Uint8Array\n\n      /** EventRecord eventType */\n      eventType: string\n\n      /** EventRecord dataContentType */\n      dataContentType: number\n\n      /** EventRecord metadataContentType */\n      metadataContentType: number\n\n      /** EventRecord data */\n      data: Uint8Array\n\n      /** EventRecord metadata */\n      metadata?: Uint8Array | null\n\n      /** EventRecord created */\n      created?: number | Long | null\n\n      /** EventRecord createdEpoch */\n      createdEpoch?: number | Long | null\n    }\n\n    /** Represents an EventRecord. */\n    class EventRecord implements IEventRecord {\n      /**\n       * Constructs a new EventRecord.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.IEventRecord)\n\n      /** EventRecord eventStreamId. */\n      public eventStreamId: string\n\n      /** EventRecord eventNumber. */\n      public eventNumber: number | Long\n\n      /** EventRecord eventId. */\n      public eventId: Uint8Array\n\n      /** EventRecord eventType. */\n      public eventType: string\n\n      /** EventRecord dataContentType. */\n      public dataContentType: number\n\n      /** EventRecord metadataContentType. */\n      public metadataContentType: number\n\n      /** EventRecord data. */\n      public data: Uint8Array\n\n      /** EventRecord metadata. */\n      public metadata: Uint8Array\n\n      /** EventRecord created. */\n      public created: number | Long\n\n      /** EventRecord createdEpoch. */\n      public createdEpoch: number | Long\n\n      /**\n       * Creates a new EventRecord instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns EventRecord instance\n       */\n      public static create(properties?: eventstore.proto.IEventRecord): eventstore.proto.EventRecord\n\n      /**\n       * Encodes the specified EventRecord message. Does not implicitly {@link eventstore.proto.EventRecord.verify|verify} messages.\n       * @param message EventRecord message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.IEventRecord,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified EventRecord message, length delimited. Does not implicitly {@link eventstore.proto.EventRecord.verify|verify} messages.\n       * @param message EventRecord message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.IEventRecord,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes an EventRecord message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns EventRecord\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.EventRecord\n\n      /**\n       * Decodes an EventRecord message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns EventRecord\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.EventRecord\n\n      /**\n       * Verifies an EventRecord message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates an EventRecord message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns EventRecord\n       */\n      public static fromObject(object: {[k: string]: any}): eventstore.proto.EventRecord\n\n      /**\n       * Creates a plain object from an EventRecord message. Also converts values to other types if specified.\n       * @param message EventRecord\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.EventRecord,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this EventRecord to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    /** Properties of a ResolvedIndexedEvent. */\n    interface IResolvedIndexedEvent {\n      /** ResolvedIndexedEvent event */\n      event?: eventstore.proto.IEventRecord | null\n\n      /** ResolvedIndexedEvent link */\n      link?: eventstore.proto.IEventRecord | null\n    }\n\n    /** Represents a ResolvedIndexedEvent. */\n    class ResolvedIndexedEvent implements IResolvedIndexedEvent {\n      /**\n       * Constructs a new ResolvedIndexedEvent.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.IResolvedIndexedEvent)\n\n      /** ResolvedIndexedEvent event. */\n      public event?: eventstore.proto.IEventRecord | null\n\n      /** ResolvedIndexedEvent link. */\n      public link?: eventstore.proto.IEventRecord | null\n\n      /**\n       * Creates a new ResolvedIndexedEvent instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns ResolvedIndexedEvent instance\n       */\n      public static create(\n        properties?: eventstore.proto.IResolvedIndexedEvent\n      ): eventstore.proto.ResolvedIndexedEvent\n\n      /**\n       * Encodes the specified ResolvedIndexedEvent message. Does not implicitly {@link eventstore.proto.ResolvedIndexedEvent.verify|verify} messages.\n       * @param message ResolvedIndexedEvent message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.IResolvedIndexedEvent,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified ResolvedIndexedEvent message, length delimited. Does not implicitly {@link eventstore.proto.ResolvedIndexedEvent.verify|verify} messages.\n       * @param message ResolvedIndexedEvent message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.IResolvedIndexedEvent,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes a ResolvedIndexedEvent message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns ResolvedIndexedEvent\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.ResolvedIndexedEvent\n\n      /**\n       * Decodes a ResolvedIndexedEvent message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns ResolvedIndexedEvent\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.ResolvedIndexedEvent\n\n      /**\n       * Verifies a ResolvedIndexedEvent message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates a ResolvedIndexedEvent message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns ResolvedIndexedEvent\n       */\n      public static fromObject(object: {[k: string]: any}): eventstore.proto.ResolvedIndexedEvent\n\n      /**\n       * Creates a plain object from a ResolvedIndexedEvent message. Also converts values to other types if specified.\n       * @param message ResolvedIndexedEvent\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.ResolvedIndexedEvent,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this ResolvedIndexedEvent to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    /** Properties of a ResolvedEvent. */\n    interface IResolvedEvent {\n      /** ResolvedEvent event */\n      event?: eventstore.proto.IEventRecord | null\n\n      /** ResolvedEvent link */\n      link?: eventstore.proto.IEventRecord | null\n\n      /** ResolvedEvent commitPosition */\n      commitPosition: number | Long\n\n      /** ResolvedEvent preparePosition */\n      preparePosition: number | Long\n    }\n\n    /** Represents a ResolvedEvent. */\n    class ResolvedEvent implements IResolvedEvent {\n      /**\n       * Constructs a new ResolvedEvent.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.IResolvedEvent)\n\n      /** ResolvedEvent event. */\n      public event?: eventstore.proto.IEventRecord | null\n\n      /** ResolvedEvent link. */\n      public link?: eventstore.proto.IEventRecord | null\n\n      /** ResolvedEvent commitPosition. */\n      public commitPosition: number | Long\n\n      /** ResolvedEvent preparePosition. */\n      public preparePosition: number | Long\n\n      /**\n       * Creates a new ResolvedEvent instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns ResolvedEvent instance\n       */\n      public static create(\n        properties?: eventstore.proto.IResolvedEvent\n      ): eventstore.proto.ResolvedEvent\n\n      /**\n       * Encodes the specified ResolvedEvent message. Does not implicitly {@link eventstore.proto.ResolvedEvent.verify|verify} messages.\n       * @param message ResolvedEvent message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.IResolvedEvent,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified ResolvedEvent message, length delimited. Does not implicitly {@link eventstore.proto.ResolvedEvent.verify|verify} messages.\n       * @param message ResolvedEvent message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.IResolvedEvent,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes a ResolvedEvent message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns ResolvedEvent\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.ResolvedEvent\n\n      /**\n       * Decodes a ResolvedEvent message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns ResolvedEvent\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.ResolvedEvent\n\n      /**\n       * Verifies a ResolvedEvent message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates a ResolvedEvent message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns ResolvedEvent\n       */\n      public static fromObject(object: {[k: string]: any}): eventstore.proto.ResolvedEvent\n\n      /**\n       * Creates a plain object from a ResolvedEvent message. Also converts values to other types if specified.\n       * @param message ResolvedEvent\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.ResolvedEvent,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this ResolvedEvent to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    /** Properties of a WriteEvents. */\n    interface IWriteEvents {\n      /** WriteEvents eventStreamId */\n      eventStreamId: string\n\n      /** WriteEvents expectedVersion */\n      expectedVersion: number | Long\n\n      /** WriteEvents events */\n      events?: eventstore.proto.INewEvent[] | null\n\n      /** WriteEvents requireMaster */\n      requireMaster: boolean\n    }\n\n    /** Represents a WriteEvents. */\n    class WriteEvents implements IWriteEvents {\n      /**\n       * Constructs a new WriteEvents.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.IWriteEvents)\n\n      /** WriteEvents eventStreamId. */\n      public eventStreamId: string\n\n      /** WriteEvents expectedVersion. */\n      public expectedVersion: number | Long\n\n      /** WriteEvents events. */\n      public events: eventstore.proto.INewEvent[]\n\n      /** WriteEvents requireMaster. */\n      public requireMaster: boolean\n\n      /**\n       * Creates a new WriteEvents instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns WriteEvents instance\n       */\n      public static create(properties?: eventstore.proto.IWriteEvents): eventstore.proto.WriteEvents\n\n      /**\n       * Encodes the specified WriteEvents message. Does not implicitly {@link eventstore.proto.WriteEvents.verify|verify} messages.\n       * @param message WriteEvents message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.IWriteEvents,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified WriteEvents message, length delimited. Does not implicitly {@link eventstore.proto.WriteEvents.verify|verify} messages.\n       * @param message WriteEvents message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.IWriteEvents,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes a WriteEvents message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns WriteEvents\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.WriteEvents\n\n      /**\n       * Decodes a WriteEvents message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns WriteEvents\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.WriteEvents\n\n      /**\n       * Verifies a WriteEvents message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates a WriteEvents message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns WriteEvents\n       */\n      public static fromObject(object: {[k: string]: any}): eventstore.proto.WriteEvents\n\n      /**\n       * Creates a plain object from a WriteEvents message. Also converts values to other types if specified.\n       * @param message WriteEvents\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.WriteEvents,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this WriteEvents to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    /** Properties of a WriteEventsCompleted. */\n    interface IWriteEventsCompleted {\n      /** WriteEventsCompleted result */\n      result: eventstore.proto.OperationResult\n\n      /** WriteEventsCompleted message */\n      message?: string | null\n\n      /** WriteEventsCompleted firstEventNumber */\n      firstEventNumber: number | Long\n\n      /** WriteEventsCompleted lastEventNumber */\n      lastEventNumber: number | Long\n\n      /** WriteEventsCompleted preparePosition */\n      preparePosition?: number | Long | null\n\n      /** WriteEventsCompleted commitPosition */\n      commitPosition?: number | Long | null\n    }\n\n    /** Represents a WriteEventsCompleted. */\n    class WriteEventsCompleted implements IWriteEventsCompleted {\n      /**\n       * Constructs a new WriteEventsCompleted.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.IWriteEventsCompleted)\n\n      /** WriteEventsCompleted result. */\n      public result: eventstore.proto.OperationResult\n\n      /** WriteEventsCompleted message. */\n      public message: string\n\n      /** WriteEventsCompleted firstEventNumber. */\n      public firstEventNumber: number | Long\n\n      /** WriteEventsCompleted lastEventNumber. */\n      public lastEventNumber: number | Long\n\n      /** WriteEventsCompleted preparePosition. */\n      public preparePosition: number | Long\n\n      /** WriteEventsCompleted commitPosition. */\n      public commitPosition: number | Long\n\n      /**\n       * Creates a new WriteEventsCompleted instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns WriteEventsCompleted instance\n       */\n      public static create(\n        properties?: eventstore.proto.IWriteEventsCompleted\n      ): eventstore.proto.WriteEventsCompleted\n\n      /**\n       * Encodes the specified WriteEventsCompleted message. Does not implicitly {@link eventstore.proto.WriteEventsCompleted.verify|verify} messages.\n       * @param message WriteEventsCompleted message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.IWriteEventsCompleted,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified WriteEventsCompleted message, length delimited. Does not implicitly {@link eventstore.proto.WriteEventsCompleted.verify|verify} messages.\n       * @param message WriteEventsCompleted message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.IWriteEventsCompleted,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes a WriteEventsCompleted message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns WriteEventsCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.WriteEventsCompleted\n\n      /**\n       * Decodes a WriteEventsCompleted message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns WriteEventsCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.WriteEventsCompleted\n\n      /**\n       * Verifies a WriteEventsCompleted message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates a WriteEventsCompleted message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns WriteEventsCompleted\n       */\n      public static fromObject(object: {[k: string]: any}): eventstore.proto.WriteEventsCompleted\n\n      /**\n       * Creates a plain object from a WriteEventsCompleted message. Also converts values to other types if specified.\n       * @param message WriteEventsCompleted\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.WriteEventsCompleted,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this WriteEventsCompleted to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    /** Properties of a DeleteStream. */\n    interface IDeleteStream {\n      /** DeleteStream eventStreamId */\n      eventStreamId: string\n\n      /** DeleteStream expectedVersion */\n      expectedVersion: number | Long\n\n      /** DeleteStream requireMaster */\n      requireMaster: boolean\n\n      /** DeleteStream hardDelete */\n      hardDelete?: boolean | null\n    }\n\n    /** Represents a DeleteStream. */\n    class DeleteStream implements IDeleteStream {\n      /**\n       * Constructs a new DeleteStream.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.IDeleteStream)\n\n      /** DeleteStream eventStreamId. */\n      public eventStreamId: string\n\n      /** DeleteStream expectedVersion. */\n      public expectedVersion: number | Long\n\n      /** DeleteStream requireMaster. */\n      public requireMaster: boolean\n\n      /** DeleteStream hardDelete. */\n      public hardDelete: boolean\n\n      /**\n       * Creates a new DeleteStream instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns DeleteStream instance\n       */\n      public static create(\n        properties?: eventstore.proto.IDeleteStream\n      ): eventstore.proto.DeleteStream\n\n      /**\n       * Encodes the specified DeleteStream message. Does not implicitly {@link eventstore.proto.DeleteStream.verify|verify} messages.\n       * @param message DeleteStream message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.IDeleteStream,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified DeleteStream message, length delimited. Does not implicitly {@link eventstore.proto.DeleteStream.verify|verify} messages.\n       * @param message DeleteStream message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.IDeleteStream,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes a DeleteStream message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns DeleteStream\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.DeleteStream\n\n      /**\n       * Decodes a DeleteStream message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns DeleteStream\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.DeleteStream\n\n      /**\n       * Verifies a DeleteStream message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates a DeleteStream message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns DeleteStream\n       */\n      public static fromObject(object: {[k: string]: any}): eventstore.proto.DeleteStream\n\n      /**\n       * Creates a plain object from a DeleteStream message. Also converts values to other types if specified.\n       * @param message DeleteStream\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.DeleteStream,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this DeleteStream to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    /** Properties of a DeleteStreamCompleted. */\n    interface IDeleteStreamCompleted {\n      /** DeleteStreamCompleted result */\n      result: eventstore.proto.OperationResult\n\n      /** DeleteStreamCompleted message */\n      message?: string | null\n\n      /** DeleteStreamCompleted preparePosition */\n      preparePosition?: number | Long | null\n\n      /** DeleteStreamCompleted commitPosition */\n      commitPosition?: number | Long | null\n    }\n\n    /** Represents a DeleteStreamCompleted. */\n    class DeleteStreamCompleted implements IDeleteStreamCompleted {\n      /**\n       * Constructs a new DeleteStreamCompleted.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.IDeleteStreamCompleted)\n\n      /** DeleteStreamCompleted result. */\n      public result: eventstore.proto.OperationResult\n\n      /** DeleteStreamCompleted message. */\n      public message: string\n\n      /** DeleteStreamCompleted preparePosition. */\n      public preparePosition: number | Long\n\n      /** DeleteStreamCompleted commitPosition. */\n      public commitPosition: number | Long\n\n      /**\n       * Creates a new DeleteStreamCompleted instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns DeleteStreamCompleted instance\n       */\n      public static create(\n        properties?: eventstore.proto.IDeleteStreamCompleted\n      ): eventstore.proto.DeleteStreamCompleted\n\n      /**\n       * Encodes the specified DeleteStreamCompleted message. Does not implicitly {@link eventstore.proto.DeleteStreamCompleted.verify|verify} messages.\n       * @param message DeleteStreamCompleted message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.IDeleteStreamCompleted,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified DeleteStreamCompleted message, length delimited. Does not implicitly {@link eventstore.proto.DeleteStreamCompleted.verify|verify} messages.\n       * @param message DeleteStreamCompleted message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.IDeleteStreamCompleted,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes a DeleteStreamCompleted message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns DeleteStreamCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.DeleteStreamCompleted\n\n      /**\n       * Decodes a DeleteStreamCompleted message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns DeleteStreamCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.DeleteStreamCompleted\n\n      /**\n       * Verifies a DeleteStreamCompleted message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates a DeleteStreamCompleted message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns DeleteStreamCompleted\n       */\n      public static fromObject(object: {[k: string]: any}): eventstore.proto.DeleteStreamCompleted\n\n      /**\n       * Creates a plain object from a DeleteStreamCompleted message. Also converts values to other types if specified.\n       * @param message DeleteStreamCompleted\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.DeleteStreamCompleted,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this DeleteStreamCompleted to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    /** Properties of a TransactionStart. */\n    interface ITransactionStart {\n      /** TransactionStart eventStreamId */\n      eventStreamId: string\n\n      /** TransactionStart expectedVersion */\n      expectedVersion: number | Long\n\n      /** TransactionStart requireMaster */\n      requireMaster: boolean\n    }\n\n    /** Represents a TransactionStart. */\n    class TransactionStart implements ITransactionStart {\n      /**\n       * Constructs a new TransactionStart.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.ITransactionStart)\n\n      /** TransactionStart eventStreamId. */\n      public eventStreamId: string\n\n      /** TransactionStart expectedVersion. */\n      public expectedVersion: number | Long\n\n      /** TransactionStart requireMaster. */\n      public requireMaster: boolean\n\n      /**\n       * Creates a new TransactionStart instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns TransactionStart instance\n       */\n      public static create(\n        properties?: eventstore.proto.ITransactionStart\n      ): eventstore.proto.TransactionStart\n\n      /**\n       * Encodes the specified TransactionStart message. Does not implicitly {@link eventstore.proto.TransactionStart.verify|verify} messages.\n       * @param message TransactionStart message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.ITransactionStart,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified TransactionStart message, length delimited. Does not implicitly {@link eventstore.proto.TransactionStart.verify|verify} messages.\n       * @param message TransactionStart message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.ITransactionStart,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes a TransactionStart message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns TransactionStart\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.TransactionStart\n\n      /**\n       * Decodes a TransactionStart message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns TransactionStart\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.TransactionStart\n\n      /**\n       * Verifies a TransactionStart message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates a TransactionStart message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns TransactionStart\n       */\n      public static fromObject(object: {[k: string]: any}): eventstore.proto.TransactionStart\n\n      /**\n       * Creates a plain object from a TransactionStart message. Also converts values to other types if specified.\n       * @param message TransactionStart\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.TransactionStart,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this TransactionStart to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    /** Properties of a TransactionStartCompleted. */\n    interface ITransactionStartCompleted {\n      /** TransactionStartCompleted transactionId */\n      transactionId: number | Long\n\n      /** TransactionStartCompleted result */\n      result: eventstore.proto.OperationResult\n\n      /** TransactionStartCompleted message */\n      message?: string | null\n    }\n\n    /** Represents a TransactionStartCompleted. */\n    class TransactionStartCompleted implements ITransactionStartCompleted {\n      /**\n       * Constructs a new TransactionStartCompleted.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.ITransactionStartCompleted)\n\n      /** TransactionStartCompleted transactionId. */\n      public transactionId: number | Long\n\n      /** TransactionStartCompleted result. */\n      public result: eventstore.proto.OperationResult\n\n      /** TransactionStartCompleted message. */\n      public message: string\n\n      /**\n       * Creates a new TransactionStartCompleted instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns TransactionStartCompleted instance\n       */\n      public static create(\n        properties?: eventstore.proto.ITransactionStartCompleted\n      ): eventstore.proto.TransactionStartCompleted\n\n      /**\n       * Encodes the specified TransactionStartCompleted message. Does not implicitly {@link eventstore.proto.TransactionStartCompleted.verify|verify} messages.\n       * @param message TransactionStartCompleted message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.ITransactionStartCompleted,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified TransactionStartCompleted message, length delimited. Does not implicitly {@link eventstore.proto.TransactionStartCompleted.verify|verify} messages.\n       * @param message TransactionStartCompleted message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.ITransactionStartCompleted,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes a TransactionStartCompleted message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns TransactionStartCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.TransactionStartCompleted\n\n      /**\n       * Decodes a TransactionStartCompleted message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns TransactionStartCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.TransactionStartCompleted\n\n      /**\n       * Verifies a TransactionStartCompleted message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates a TransactionStartCompleted message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns TransactionStartCompleted\n       */\n      public static fromObject(object: {\n        [k: string]: any\n      }): eventstore.proto.TransactionStartCompleted\n\n      /**\n       * Creates a plain object from a TransactionStartCompleted message. Also converts values to other types if specified.\n       * @param message TransactionStartCompleted\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.TransactionStartCompleted,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this TransactionStartCompleted to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    /** Properties of a TransactionWrite. */\n    interface ITransactionWrite {\n      /** TransactionWrite transactionId */\n      transactionId: number | Long\n\n      /** TransactionWrite events */\n      events?: eventstore.proto.INewEvent[] | null\n\n      /** TransactionWrite requireMaster */\n      requireMaster: boolean\n    }\n\n    /** Represents a TransactionWrite. */\n    class TransactionWrite implements ITransactionWrite {\n      /**\n       * Constructs a new TransactionWrite.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.ITransactionWrite)\n\n      /** TransactionWrite transactionId. */\n      public transactionId: number | Long\n\n      /** TransactionWrite events. */\n      public events: eventstore.proto.INewEvent[]\n\n      /** TransactionWrite requireMaster. */\n      public requireMaster: boolean\n\n      /**\n       * Creates a new TransactionWrite instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns TransactionWrite instance\n       */\n      public static create(\n        properties?: eventstore.proto.ITransactionWrite\n      ): eventstore.proto.TransactionWrite\n\n      /**\n       * Encodes the specified TransactionWrite message. Does not implicitly {@link eventstore.proto.TransactionWrite.verify|verify} messages.\n       * @param message TransactionWrite message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.ITransactionWrite,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified TransactionWrite message, length delimited. Does not implicitly {@link eventstore.proto.TransactionWrite.verify|verify} messages.\n       * @param message TransactionWrite message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.ITransactionWrite,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes a TransactionWrite message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns TransactionWrite\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.TransactionWrite\n\n      /**\n       * Decodes a TransactionWrite message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns TransactionWrite\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.TransactionWrite\n\n      /**\n       * Verifies a TransactionWrite message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates a TransactionWrite message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns TransactionWrite\n       */\n      public static fromObject(object: {[k: string]: any}): eventstore.proto.TransactionWrite\n\n      /**\n       * Creates a plain object from a TransactionWrite message. Also converts values to other types if specified.\n       * @param message TransactionWrite\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.TransactionWrite,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this TransactionWrite to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    /** Properties of a TransactionWriteCompleted. */\n    interface ITransactionWriteCompleted {\n      /** TransactionWriteCompleted transactionId */\n      transactionId: number | Long\n\n      /** TransactionWriteCompleted result */\n      result: eventstore.proto.OperationResult\n\n      /** TransactionWriteCompleted message */\n      message?: string | null\n    }\n\n    /** Represents a TransactionWriteCompleted. */\n    class TransactionWriteCompleted implements ITransactionWriteCompleted {\n      /**\n       * Constructs a new TransactionWriteCompleted.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.ITransactionWriteCompleted)\n\n      /** TransactionWriteCompleted transactionId. */\n      public transactionId: number | Long\n\n      /** TransactionWriteCompleted result. */\n      public result: eventstore.proto.OperationResult\n\n      /** TransactionWriteCompleted message. */\n      public message: string\n\n      /**\n       * Creates a new TransactionWriteCompleted instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns TransactionWriteCompleted instance\n       */\n      public static create(\n        properties?: eventstore.proto.ITransactionWriteCompleted\n      ): eventstore.proto.TransactionWriteCompleted\n\n      /**\n       * Encodes the specified TransactionWriteCompleted message. Does not implicitly {@link eventstore.proto.TransactionWriteCompleted.verify|verify} messages.\n       * @param message TransactionWriteCompleted message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.ITransactionWriteCompleted,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified TransactionWriteCompleted message, length delimited. Does not implicitly {@link eventstore.proto.TransactionWriteCompleted.verify|verify} messages.\n       * @param message TransactionWriteCompleted message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.ITransactionWriteCompleted,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes a TransactionWriteCompleted message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns TransactionWriteCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.TransactionWriteCompleted\n\n      /**\n       * Decodes a TransactionWriteCompleted message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns TransactionWriteCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.TransactionWriteCompleted\n\n      /**\n       * Verifies a TransactionWriteCompleted message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates a TransactionWriteCompleted message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns TransactionWriteCompleted\n       */\n      public static fromObject(object: {\n        [k: string]: any\n      }): eventstore.proto.TransactionWriteCompleted\n\n      /**\n       * Creates a plain object from a TransactionWriteCompleted message. Also converts values to other types if specified.\n       * @param message TransactionWriteCompleted\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.TransactionWriteCompleted,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this TransactionWriteCompleted to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    /** Properties of a TransactionCommit. */\n    interface ITransactionCommit {\n      /** TransactionCommit transactionId */\n      transactionId: number | Long\n\n      /** TransactionCommit requireMaster */\n      requireMaster: boolean\n    }\n\n    /** Represents a TransactionCommit. */\n    class TransactionCommit implements ITransactionCommit {\n      /**\n       * Constructs a new TransactionCommit.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.ITransactionCommit)\n\n      /** TransactionCommit transactionId. */\n      public transactionId: number | Long\n\n      /** TransactionCommit requireMaster. */\n      public requireMaster: boolean\n\n      /**\n       * Creates a new TransactionCommit instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns TransactionCommit instance\n       */\n      public static create(\n        properties?: eventstore.proto.ITransactionCommit\n      ): eventstore.proto.TransactionCommit\n\n      /**\n       * Encodes the specified TransactionCommit message. Does not implicitly {@link eventstore.proto.TransactionCommit.verify|verify} messages.\n       * @param message TransactionCommit message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.ITransactionCommit,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified TransactionCommit message, length delimited. Does not implicitly {@link eventstore.proto.TransactionCommit.verify|verify} messages.\n       * @param message TransactionCommit message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.ITransactionCommit,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes a TransactionCommit message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns TransactionCommit\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.TransactionCommit\n\n      /**\n       * Decodes a TransactionCommit message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns TransactionCommit\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.TransactionCommit\n\n      /**\n       * Verifies a TransactionCommit message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates a TransactionCommit message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns TransactionCommit\n       */\n      public static fromObject(object: {[k: string]: any}): eventstore.proto.TransactionCommit\n\n      /**\n       * Creates a plain object from a TransactionCommit message. Also converts values to other types if specified.\n       * @param message TransactionCommit\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.TransactionCommit,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this TransactionCommit to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    /** Properties of a TransactionCommitCompleted. */\n    interface ITransactionCommitCompleted {\n      /** TransactionCommitCompleted transactionId */\n      transactionId: number | Long\n\n      /** TransactionCommitCompleted result */\n      result: eventstore.proto.OperationResult\n\n      /** TransactionCommitCompleted message */\n      message?: string | null\n\n      /** TransactionCommitCompleted firstEventNumber */\n      firstEventNumber: number | Long\n\n      /** TransactionCommitCompleted lastEventNumber */\n      lastEventNumber: number | Long\n\n      /** TransactionCommitCompleted preparePosition */\n      preparePosition?: number | Long | null\n\n      /** TransactionCommitCompleted commitPosition */\n      commitPosition?: number | Long | null\n    }\n\n    /** Represents a TransactionCommitCompleted. */\n    class TransactionCommitCompleted implements ITransactionCommitCompleted {\n      /**\n       * Constructs a new TransactionCommitCompleted.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.ITransactionCommitCompleted)\n\n      /** TransactionCommitCompleted transactionId. */\n      public transactionId: number | Long\n\n      /** TransactionCommitCompleted result. */\n      public result: eventstore.proto.OperationResult\n\n      /** TransactionCommitCompleted message. */\n      public message: string\n\n      /** TransactionCommitCompleted firstEventNumber. */\n      public firstEventNumber: number | Long\n\n      /** TransactionCommitCompleted lastEventNumber. */\n      public lastEventNumber: number | Long\n\n      /** TransactionCommitCompleted preparePosition. */\n      public preparePosition: number | Long\n\n      /** TransactionCommitCompleted commitPosition. */\n      public commitPosition: number | Long\n\n      /**\n       * Creates a new TransactionCommitCompleted instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns TransactionCommitCompleted instance\n       */\n      public static create(\n        properties?: eventstore.proto.ITransactionCommitCompleted\n      ): eventstore.proto.TransactionCommitCompleted\n\n      /**\n       * Encodes the specified TransactionCommitCompleted message. Does not implicitly {@link eventstore.proto.TransactionCommitCompleted.verify|verify} messages.\n       * @param message TransactionCommitCompleted message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.ITransactionCommitCompleted,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified TransactionCommitCompleted message, length delimited. Does not implicitly {@link eventstore.proto.TransactionCommitCompleted.verify|verify} messages.\n       * @param message TransactionCommitCompleted message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.ITransactionCommitCompleted,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes a TransactionCommitCompleted message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns TransactionCommitCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.TransactionCommitCompleted\n\n      /**\n       * Decodes a TransactionCommitCompleted message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns TransactionCommitCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.TransactionCommitCompleted\n\n      /**\n       * Verifies a TransactionCommitCompleted message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates a TransactionCommitCompleted message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns TransactionCommitCompleted\n       */\n      public static fromObject(object: {\n        [k: string]: any\n      }): eventstore.proto.TransactionCommitCompleted\n\n      /**\n       * Creates a plain object from a TransactionCommitCompleted message. Also converts values to other types if specified.\n       * @param message TransactionCommitCompleted\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.TransactionCommitCompleted,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this TransactionCommitCompleted to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    /** Properties of a ReadEvent. */\n    interface IReadEvent {\n      /** ReadEvent eventStreamId */\n      eventStreamId: string\n\n      /** ReadEvent eventNumber */\n      eventNumber: number | Long\n\n      /** ReadEvent resolveLinkTos */\n      resolveLinkTos: boolean\n\n      /** ReadEvent requireMaster */\n      requireMaster: boolean\n    }\n\n    /** Represents a ReadEvent. */\n    class ReadEvent implements IReadEvent {\n      /**\n       * Constructs a new ReadEvent.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.IReadEvent)\n\n      /** ReadEvent eventStreamId. */\n      public eventStreamId: string\n\n      /** ReadEvent eventNumber. */\n      public eventNumber: number | Long\n\n      /** ReadEvent resolveLinkTos. */\n      public resolveLinkTos: boolean\n\n      /** ReadEvent requireMaster. */\n      public requireMaster: boolean\n\n      /**\n       * Creates a new ReadEvent instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns ReadEvent instance\n       */\n      public static create(properties?: eventstore.proto.IReadEvent): eventstore.proto.ReadEvent\n\n      /**\n       * Encodes the specified ReadEvent message. Does not implicitly {@link eventstore.proto.ReadEvent.verify|verify} messages.\n       * @param message ReadEvent message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.IReadEvent,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified ReadEvent message, length delimited. Does not implicitly {@link eventstore.proto.ReadEvent.verify|verify} messages.\n       * @param message ReadEvent message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.IReadEvent,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes a ReadEvent message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns ReadEvent\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.ReadEvent\n\n      /**\n       * Decodes a ReadEvent message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns ReadEvent\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.ReadEvent\n\n      /**\n       * Verifies a ReadEvent message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates a ReadEvent message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns ReadEvent\n       */\n      public static fromObject(object: {[k: string]: any}): eventstore.proto.ReadEvent\n\n      /**\n       * Creates a plain object from a ReadEvent message. Also converts values to other types if specified.\n       * @param message ReadEvent\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.ReadEvent,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this ReadEvent to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    /** Properties of a ReadEventCompleted. */\n    interface IReadEventCompleted {\n      /** ReadEventCompleted result */\n      result: eventstore.proto.ReadEventCompleted.ReadEventResult\n\n      /** ReadEventCompleted event */\n      event: eventstore.proto.IResolvedIndexedEvent\n\n      /** ReadEventCompleted error */\n      error?: string | null\n    }\n\n    /** Represents a ReadEventCompleted. */\n    class ReadEventCompleted implements IReadEventCompleted {\n      /**\n       * Constructs a new ReadEventCompleted.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.IReadEventCompleted)\n\n      /** ReadEventCompleted result. */\n      public result: eventstore.proto.ReadEventCompleted.ReadEventResult\n\n      /** ReadEventCompleted event. */\n      public event: eventstore.proto.IResolvedIndexedEvent\n\n      /** ReadEventCompleted error. */\n      public error: string\n\n      /**\n       * Creates a new ReadEventCompleted instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns ReadEventCompleted instance\n       */\n      public static create(\n        properties?: eventstore.proto.IReadEventCompleted\n      ): eventstore.proto.ReadEventCompleted\n\n      /**\n       * Encodes the specified ReadEventCompleted message. Does not implicitly {@link eventstore.proto.ReadEventCompleted.verify|verify} messages.\n       * @param message ReadEventCompleted message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.IReadEventCompleted,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified ReadEventCompleted message, length delimited. Does not implicitly {@link eventstore.proto.ReadEventCompleted.verify|verify} messages.\n       * @param message ReadEventCompleted message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.IReadEventCompleted,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes a ReadEventCompleted message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns ReadEventCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.ReadEventCompleted\n\n      /**\n       * Decodes a ReadEventCompleted message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns ReadEventCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.ReadEventCompleted\n\n      /**\n       * Verifies a ReadEventCompleted message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates a ReadEventCompleted message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns ReadEventCompleted\n       */\n      public static fromObject(object: {[k: string]: any}): eventstore.proto.ReadEventCompleted\n\n      /**\n       * Creates a plain object from a ReadEventCompleted message. Also converts values to other types if specified.\n       * @param message ReadEventCompleted\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.ReadEventCompleted,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this ReadEventCompleted to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    namespace ReadEventCompleted {\n      /** ReadEventResult enum. */\n      enum ReadEventResult {\n        Success = 0,\n        NotFound = 1,\n        NoStream = 2,\n        StreamDeleted = 3,\n        Error = 4,\n        AccessDenied = 5\n      }\n    }\n\n    /** Properties of a ReadStreamEvents. */\n    interface IReadStreamEvents {\n      /** ReadStreamEvents eventStreamId */\n      eventStreamId: string\n\n      /** ReadStreamEvents fromEventNumber */\n      fromEventNumber: number | Long\n\n      /** ReadStreamEvents maxCount */\n      maxCount: number\n\n      /** ReadStreamEvents resolveLinkTos */\n      resolveLinkTos: boolean\n\n      /** ReadStreamEvents requireMaster */\n      requireMaster: boolean\n    }\n\n    /** Represents a ReadStreamEvents. */\n    class ReadStreamEvents implements IReadStreamEvents {\n      /**\n       * Constructs a new ReadStreamEvents.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.IReadStreamEvents)\n\n      /** ReadStreamEvents eventStreamId. */\n      public eventStreamId: string\n\n      /** ReadStreamEvents fromEventNumber. */\n      public fromEventNumber: number | Long\n\n      /** ReadStreamEvents maxCount. */\n      public maxCount: number\n\n      /** ReadStreamEvents resolveLinkTos. */\n      public resolveLinkTos: boolean\n\n      /** ReadStreamEvents requireMaster. */\n      public requireMaster: boolean\n\n      /**\n       * Creates a new ReadStreamEvents instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns ReadStreamEvents instance\n       */\n      public static create(\n        properties?: eventstore.proto.IReadStreamEvents\n      ): eventstore.proto.ReadStreamEvents\n\n      /**\n       * Encodes the specified ReadStreamEvents message. Does not implicitly {@link eventstore.proto.ReadStreamEvents.verify|verify} messages.\n       * @param message ReadStreamEvents message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.IReadStreamEvents,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified ReadStreamEvents message, length delimited. Does not implicitly {@link eventstore.proto.ReadStreamEvents.verify|verify} messages.\n       * @param message ReadStreamEvents message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.IReadStreamEvents,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes a ReadStreamEvents message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns ReadStreamEvents\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.ReadStreamEvents\n\n      /**\n       * Decodes a ReadStreamEvents message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns ReadStreamEvents\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.ReadStreamEvents\n\n      /**\n       * Verifies a ReadStreamEvents message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates a ReadStreamEvents message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns ReadStreamEvents\n       */\n      public static fromObject(object: {[k: string]: any}): eventstore.proto.ReadStreamEvents\n\n      /**\n       * Creates a plain object from a ReadStreamEvents message. Also converts values to other types if specified.\n       * @param message ReadStreamEvents\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.ReadStreamEvents,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this ReadStreamEvents to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    /** Properties of a ReadStreamEventsCompleted. */\n    interface IReadStreamEventsCompleted {\n      /** ReadStreamEventsCompleted events */\n      events?: eventstore.proto.IResolvedIndexedEvent[] | null\n\n      /** ReadStreamEventsCompleted result */\n      result: eventstore.proto.ReadStreamEventsCompleted.ReadStreamResult\n\n      /** ReadStreamEventsCompleted nextEventNumber */\n      nextEventNumber: number | Long\n\n      /** ReadStreamEventsCompleted lastEventNumber */\n      lastEventNumber: number | Long\n\n      /** ReadStreamEventsCompleted isEndOfStream */\n      isEndOfStream: boolean\n\n      /** ReadStreamEventsCompleted lastCommitPosition */\n      lastCommitPosition: number | Long\n\n      /** ReadStreamEventsCompleted error */\n      error?: string | null\n    }\n\n    /** Represents a ReadStreamEventsCompleted. */\n    class ReadStreamEventsCompleted implements IReadStreamEventsCompleted {\n      /**\n       * Constructs a new ReadStreamEventsCompleted.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.IReadStreamEventsCompleted)\n\n      /** ReadStreamEventsCompleted events. */\n      public events: eventstore.proto.IResolvedIndexedEvent[]\n\n      /** ReadStreamEventsCompleted result. */\n      public result: eventstore.proto.ReadStreamEventsCompleted.ReadStreamResult\n\n      /** ReadStreamEventsCompleted nextEventNumber. */\n      public nextEventNumber: number | Long\n\n      /** ReadStreamEventsCompleted lastEventNumber. */\n      public lastEventNumber: number | Long\n\n      /** ReadStreamEventsCompleted isEndOfStream. */\n      public isEndOfStream: boolean\n\n      /** ReadStreamEventsCompleted lastCommitPosition. */\n      public lastCommitPosition: number | Long\n\n      /** ReadStreamEventsCompleted error. */\n      public error: string\n\n      /**\n       * Creates a new ReadStreamEventsCompleted instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns ReadStreamEventsCompleted instance\n       */\n      public static create(\n        properties?: eventstore.proto.IReadStreamEventsCompleted\n      ): eventstore.proto.ReadStreamEventsCompleted\n\n      /**\n       * Encodes the specified ReadStreamEventsCompleted message. Does not implicitly {@link eventstore.proto.ReadStreamEventsCompleted.verify|verify} messages.\n       * @param message ReadStreamEventsCompleted message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.IReadStreamEventsCompleted,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified ReadStreamEventsCompleted message, length delimited. Does not implicitly {@link eventstore.proto.ReadStreamEventsCompleted.verify|verify} messages.\n       * @param message ReadStreamEventsCompleted message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.IReadStreamEventsCompleted,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes a ReadStreamEventsCompleted message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns ReadStreamEventsCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.ReadStreamEventsCompleted\n\n      /**\n       * Decodes a ReadStreamEventsCompleted message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns ReadStreamEventsCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.ReadStreamEventsCompleted\n\n      /**\n       * Verifies a ReadStreamEventsCompleted message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates a ReadStreamEventsCompleted message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns ReadStreamEventsCompleted\n       */\n      public static fromObject(object: {\n        [k: string]: any\n      }): eventstore.proto.ReadStreamEventsCompleted\n\n      /**\n       * Creates a plain object from a ReadStreamEventsCompleted message. Also converts values to other types if specified.\n       * @param message ReadStreamEventsCompleted\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.ReadStreamEventsCompleted,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this ReadStreamEventsCompleted to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    namespace ReadStreamEventsCompleted {\n      /** ReadStreamResult enum. */\n      enum ReadStreamResult {\n        Success = 0,\n        NoStream = 1,\n        StreamDeleted = 2,\n        NotModified = 3,\n        Error = 4,\n        AccessDenied = 5\n      }\n    }\n\n    /** Properties of a ReadAllEvents. */\n    interface IReadAllEvents {\n      /** ReadAllEvents commitPosition */\n      commitPosition: number | Long\n\n      /** ReadAllEvents preparePosition */\n      preparePosition: number | Long\n\n      /** ReadAllEvents maxCount */\n      maxCount: number\n\n      /** ReadAllEvents resolveLinkTos */\n      resolveLinkTos: boolean\n\n      /** ReadAllEvents requireMaster */\n      requireMaster: boolean\n    }\n\n    /** Represents a ReadAllEvents. */\n    class ReadAllEvents implements IReadAllEvents {\n      /**\n       * Constructs a new ReadAllEvents.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.IReadAllEvents)\n\n      /** ReadAllEvents commitPosition. */\n      public commitPosition: number | Long\n\n      /** ReadAllEvents preparePosition. */\n      public preparePosition: number | Long\n\n      /** ReadAllEvents maxCount. */\n      public maxCount: number\n\n      /** ReadAllEvents resolveLinkTos. */\n      public resolveLinkTos: boolean\n\n      /** ReadAllEvents requireMaster. */\n      public requireMaster: boolean\n\n      /**\n       * Creates a new ReadAllEvents instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns ReadAllEvents instance\n       */\n      public static create(\n        properties?: eventstore.proto.IReadAllEvents\n      ): eventstore.proto.ReadAllEvents\n\n      /**\n       * Encodes the specified ReadAllEvents message. Does not implicitly {@link eventstore.proto.ReadAllEvents.verify|verify} messages.\n       * @param message ReadAllEvents message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.IReadAllEvents,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified ReadAllEvents message, length delimited. Does not implicitly {@link eventstore.proto.ReadAllEvents.verify|verify} messages.\n       * @param message ReadAllEvents message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.IReadAllEvents,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes a ReadAllEvents message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns ReadAllEvents\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.ReadAllEvents\n\n      /**\n       * Decodes a ReadAllEvents message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns ReadAllEvents\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.ReadAllEvents\n\n      /**\n       * Verifies a ReadAllEvents message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates a ReadAllEvents message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns ReadAllEvents\n       */\n      public static fromObject(object: {[k: string]: any}): eventstore.proto.ReadAllEvents\n\n      /**\n       * Creates a plain object from a ReadAllEvents message. Also converts values to other types if specified.\n       * @param message ReadAllEvents\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.ReadAllEvents,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this ReadAllEvents to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    /** Properties of a ReadAllEventsCompleted. */\n    interface IReadAllEventsCompleted {\n      /** ReadAllEventsCompleted commitPosition */\n      commitPosition: number | Long\n\n      /** ReadAllEventsCompleted preparePosition */\n      preparePosition: number | Long\n\n      /** ReadAllEventsCompleted events */\n      events?: eventstore.proto.IResolvedEvent[] | null\n\n      /** ReadAllEventsCompleted nextCommitPosition */\n      nextCommitPosition: number | Long\n\n      /** ReadAllEventsCompleted nextPreparePosition */\n      nextPreparePosition: number | Long\n\n      /** ReadAllEventsCompleted result */\n      result?: eventstore.proto.ReadAllEventsCompleted.ReadAllResult | null\n\n      /** ReadAllEventsCompleted error */\n      error?: string | null\n    }\n\n    /** Represents a ReadAllEventsCompleted. */\n    class ReadAllEventsCompleted implements IReadAllEventsCompleted {\n      /**\n       * Constructs a new ReadAllEventsCompleted.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.IReadAllEventsCompleted)\n\n      /** ReadAllEventsCompleted commitPosition. */\n      public commitPosition: number | Long\n\n      /** ReadAllEventsCompleted preparePosition. */\n      public preparePosition: number | Long\n\n      /** ReadAllEventsCompleted events. */\n      public events: eventstore.proto.IResolvedEvent[]\n\n      /** ReadAllEventsCompleted nextCommitPosition. */\n      public nextCommitPosition: number | Long\n\n      /** ReadAllEventsCompleted nextPreparePosition. */\n      public nextPreparePosition: number | Long\n\n      /** ReadAllEventsCompleted result. */\n      public result: eventstore.proto.ReadAllEventsCompleted.ReadAllResult\n\n      /** ReadAllEventsCompleted error. */\n      public error: string\n\n      /**\n       * Creates a new ReadAllEventsCompleted instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns ReadAllEventsCompleted instance\n       */\n      public static create(\n        properties?: eventstore.proto.IReadAllEventsCompleted\n      ): eventstore.proto.ReadAllEventsCompleted\n\n      /**\n       * Encodes the specified ReadAllEventsCompleted message. Does not implicitly {@link eventstore.proto.ReadAllEventsCompleted.verify|verify} messages.\n       * @param message ReadAllEventsCompleted message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.IReadAllEventsCompleted,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified ReadAllEventsCompleted message, length delimited. Does not implicitly {@link eventstore.proto.ReadAllEventsCompleted.verify|verify} messages.\n       * @param message ReadAllEventsCompleted message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.IReadAllEventsCompleted,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes a ReadAllEventsCompleted message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns ReadAllEventsCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.ReadAllEventsCompleted\n\n      /**\n       * Decodes a ReadAllEventsCompleted message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns ReadAllEventsCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.ReadAllEventsCompleted\n\n      /**\n       * Verifies a ReadAllEventsCompleted message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates a ReadAllEventsCompleted message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns ReadAllEventsCompleted\n       */\n      public static fromObject(object: {[k: string]: any}): eventstore.proto.ReadAllEventsCompleted\n\n      /**\n       * Creates a plain object from a ReadAllEventsCompleted message. Also converts values to other types if specified.\n       * @param message ReadAllEventsCompleted\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.ReadAllEventsCompleted,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this ReadAllEventsCompleted to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    namespace ReadAllEventsCompleted {\n      /** ReadAllResult enum. */\n      enum ReadAllResult {\n        Success = 0,\n        NotModified = 1,\n        Error = 2,\n        AccessDenied = 3\n      }\n    }\n\n    /** Properties of a CreatePersistentSubscription. */\n    interface ICreatePersistentSubscription {\n      /** CreatePersistentSubscription subscriptionGroupName */\n      subscriptionGroupName: string\n\n      /** CreatePersistentSubscription eventStreamId */\n      eventStreamId: string\n\n      /** CreatePersistentSubscription resolveLinkTos */\n      resolveLinkTos: boolean\n\n      /** CreatePersistentSubscription startFrom */\n      startFrom: number | Long\n\n      /** CreatePersistentSubscription messageTimeoutMilliseconds */\n      messageTimeoutMilliseconds: number\n\n      /** CreatePersistentSubscription recordStatistics */\n      recordStatistics: boolean\n\n      /** CreatePersistentSubscription liveBufferSize */\n      liveBufferSize: number\n\n      /** CreatePersistentSubscription readBatchSize */\n      readBatchSize: number\n\n      /** CreatePersistentSubscription bufferSize */\n      bufferSize: number\n\n      /** CreatePersistentSubscription maxRetryCount */\n      maxRetryCount: number\n\n      /** CreatePersistentSubscription preferRoundRobin */\n      preferRoundRobin: boolean\n\n      /** CreatePersistentSubscription checkpointAfterTime */\n      checkpointAfterTime: number\n\n      /** CreatePersistentSubscription checkpointMaxCount */\n      checkpointMaxCount: number\n\n      /** CreatePersistentSubscription checkpointMinCount */\n      checkpointMinCount: number\n\n      /** CreatePersistentSubscription subscriberMaxCount */\n      subscriberMaxCount: number\n\n      /** CreatePersistentSubscription namedConsumerStrategy */\n      namedConsumerStrategy?: string | null\n    }\n\n    /** Represents a CreatePersistentSubscription. */\n    class CreatePersistentSubscription implements ICreatePersistentSubscription {\n      /**\n       * Constructs a new CreatePersistentSubscription.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.ICreatePersistentSubscription)\n\n      /** CreatePersistentSubscription subscriptionGroupName. */\n      public subscriptionGroupName: string\n\n      /** CreatePersistentSubscription eventStreamId. */\n      public eventStreamId: string\n\n      /** CreatePersistentSubscription resolveLinkTos. */\n      public resolveLinkTos: boolean\n\n      /** CreatePersistentSubscription startFrom. */\n      public startFrom: number | Long\n\n      /** CreatePersistentSubscription messageTimeoutMilliseconds. */\n      public messageTimeoutMilliseconds: number\n\n      /** CreatePersistentSubscription recordStatistics. */\n      public recordStatistics: boolean\n\n      /** CreatePersistentSubscription liveBufferSize. */\n      public liveBufferSize: number\n\n      /** CreatePersistentSubscription readBatchSize. */\n      public readBatchSize: number\n\n      /** CreatePersistentSubscription bufferSize. */\n      public bufferSize: number\n\n      /** CreatePersistentSubscription maxRetryCount. */\n      public maxRetryCount: number\n\n      /** CreatePersistentSubscription preferRoundRobin. */\n      public preferRoundRobin: boolean\n\n      /** CreatePersistentSubscription checkpointAfterTime. */\n      public checkpointAfterTime: number\n\n      /** CreatePersistentSubscription checkpointMaxCount. */\n      public checkpointMaxCount: number\n\n      /** CreatePersistentSubscription checkpointMinCount. */\n      public checkpointMinCount: number\n\n      /** CreatePersistentSubscription subscriberMaxCount. */\n      public subscriberMaxCount: number\n\n      /** CreatePersistentSubscription namedConsumerStrategy. */\n      public namedConsumerStrategy: string\n\n      /**\n       * Creates a new CreatePersistentSubscription instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns CreatePersistentSubscription instance\n       */\n      public static create(\n        properties?: eventstore.proto.ICreatePersistentSubscription\n      ): eventstore.proto.CreatePersistentSubscription\n\n      /**\n       * Encodes the specified CreatePersistentSubscription message. Does not implicitly {@link eventstore.proto.CreatePersistentSubscription.verify|verify} messages.\n       * @param message CreatePersistentSubscription message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.ICreatePersistentSubscription,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified CreatePersistentSubscription message, length delimited. Does not implicitly {@link eventstore.proto.CreatePersistentSubscription.verify|verify} messages.\n       * @param message CreatePersistentSubscription message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.ICreatePersistentSubscription,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes a CreatePersistentSubscription message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns CreatePersistentSubscription\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.CreatePersistentSubscription\n\n      /**\n       * Decodes a CreatePersistentSubscription message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns CreatePersistentSubscription\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.CreatePersistentSubscription\n\n      /**\n       * Verifies a CreatePersistentSubscription message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates a CreatePersistentSubscription message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns CreatePersistentSubscription\n       */\n      public static fromObject(object: {\n        [k: string]: any\n      }): eventstore.proto.CreatePersistentSubscription\n\n      /**\n       * Creates a plain object from a CreatePersistentSubscription message. Also converts values to other types if specified.\n       * @param message CreatePersistentSubscription\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.CreatePersistentSubscription,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this CreatePersistentSubscription to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    /** Properties of a DeletePersistentSubscription. */\n    interface IDeletePersistentSubscription {\n      /** DeletePersistentSubscription subscriptionGroupName */\n      subscriptionGroupName: string\n\n      /** DeletePersistentSubscription eventStreamId */\n      eventStreamId: string\n    }\n\n    /** Represents a DeletePersistentSubscription. */\n    class DeletePersistentSubscription implements IDeletePersistentSubscription {\n      /**\n       * Constructs a new DeletePersistentSubscription.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.IDeletePersistentSubscription)\n\n      /** DeletePersistentSubscription subscriptionGroupName. */\n      public subscriptionGroupName: string\n\n      /** DeletePersistentSubscription eventStreamId. */\n      public eventStreamId: string\n\n      /**\n       * Creates a new DeletePersistentSubscription instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns DeletePersistentSubscription instance\n       */\n      public static create(\n        properties?: eventstore.proto.IDeletePersistentSubscription\n      ): eventstore.proto.DeletePersistentSubscription\n\n      /**\n       * Encodes the specified DeletePersistentSubscription message. Does not implicitly {@link eventstore.proto.DeletePersistentSubscription.verify|verify} messages.\n       * @param message DeletePersistentSubscription message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.IDeletePersistentSubscription,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified DeletePersistentSubscription message, length delimited. Does not implicitly {@link eventstore.proto.DeletePersistentSubscription.verify|verify} messages.\n       * @param message DeletePersistentSubscription message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.IDeletePersistentSubscription,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes a DeletePersistentSubscription message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns DeletePersistentSubscription\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.DeletePersistentSubscription\n\n      /**\n       * Decodes a DeletePersistentSubscription message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns DeletePersistentSubscription\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.DeletePersistentSubscription\n\n      /**\n       * Verifies a DeletePersistentSubscription message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates a DeletePersistentSubscription message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns DeletePersistentSubscription\n       */\n      public static fromObject(object: {\n        [k: string]: any\n      }): eventstore.proto.DeletePersistentSubscription\n\n      /**\n       * Creates a plain object from a DeletePersistentSubscription message. Also converts values to other types if specified.\n       * @param message DeletePersistentSubscription\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.DeletePersistentSubscription,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this DeletePersistentSubscription to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    /** Properties of an UpdatePersistentSubscription. */\n    interface IUpdatePersistentSubscription {\n      /** UpdatePersistentSubscription subscriptionGroupName */\n      subscriptionGroupName: string\n\n      /** UpdatePersistentSubscription eventStreamId */\n      eventStreamId: string\n\n      /** UpdatePersistentSubscription resolveLinkTos */\n      resolveLinkTos: boolean\n\n      /** UpdatePersistentSubscription startFrom */\n      startFrom: number | Long\n\n      /** UpdatePersistentSubscription messageTimeoutMilliseconds */\n      messageTimeoutMilliseconds: number\n\n      /** UpdatePersistentSubscription recordStatistics */\n      recordStatistics: boolean\n\n      /** UpdatePersistentSubscription liveBufferSize */\n      liveBufferSize: number\n\n      /** UpdatePersistentSubscription readBatchSize */\n      readBatchSize: number\n\n      /** UpdatePersistentSubscription bufferSize */\n      bufferSize: number\n\n      /** UpdatePersistentSubscription maxRetryCount */\n      maxRetryCount: number\n\n      /** UpdatePersistentSubscription preferRoundRobin */\n      preferRoundRobin: boolean\n\n      /** UpdatePersistentSubscription checkpointAfterTime */\n      checkpointAfterTime: number\n\n      /** UpdatePersistentSubscription checkpointMaxCount */\n      checkpointMaxCount: number\n\n      /** UpdatePersistentSubscription checkpointMinCount */\n      checkpointMinCount: number\n\n      /** UpdatePersistentSubscription subscriberMaxCount */\n      subscriberMaxCount: number\n\n      /** UpdatePersistentSubscription namedConsumerStrategy */\n      namedConsumerStrategy?: string | null\n    }\n\n    /** Represents an UpdatePersistentSubscription. */\n    class UpdatePersistentSubscription implements IUpdatePersistentSubscription {\n      /**\n       * Constructs a new UpdatePersistentSubscription.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.IUpdatePersistentSubscription)\n\n      /** UpdatePersistentSubscription subscriptionGroupName. */\n      public subscriptionGroupName: string\n\n      /** UpdatePersistentSubscription eventStreamId. */\n      public eventStreamId: string\n\n      /** UpdatePersistentSubscription resolveLinkTos. */\n      public resolveLinkTos: boolean\n\n      /** UpdatePersistentSubscription startFrom. */\n      public startFrom: number | Long\n\n      /** UpdatePersistentSubscription messageTimeoutMilliseconds. */\n      public messageTimeoutMilliseconds: number\n\n      /** UpdatePersistentSubscription recordStatistics. */\n      public recordStatistics: boolean\n\n      /** UpdatePersistentSubscription liveBufferSize. */\n      public liveBufferSize: number\n\n      /** UpdatePersistentSubscription readBatchSize. */\n      public readBatchSize: number\n\n      /** UpdatePersistentSubscription bufferSize. */\n      public bufferSize: number\n\n      /** UpdatePersistentSubscription maxRetryCount. */\n      public maxRetryCount: number\n\n      /** UpdatePersistentSubscription preferRoundRobin. */\n      public preferRoundRobin: boolean\n\n      /** UpdatePersistentSubscription checkpointAfterTime. */\n      public checkpointAfterTime: number\n\n      /** UpdatePersistentSubscription checkpointMaxCount. */\n      public checkpointMaxCount: number\n\n      /** UpdatePersistentSubscription checkpointMinCount. */\n      public checkpointMinCount: number\n\n      /** UpdatePersistentSubscription subscriberMaxCount. */\n      public subscriberMaxCount: number\n\n      /** UpdatePersistentSubscription namedConsumerStrategy. */\n      public namedConsumerStrategy: string\n\n      /**\n       * Creates a new UpdatePersistentSubscription instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns UpdatePersistentSubscription instance\n       */\n      public static create(\n        properties?: eventstore.proto.IUpdatePersistentSubscription\n      ): eventstore.proto.UpdatePersistentSubscription\n\n      /**\n       * Encodes the specified UpdatePersistentSubscription message. Does not implicitly {@link eventstore.proto.UpdatePersistentSubscription.verify|verify} messages.\n       * @param message UpdatePersistentSubscription message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.IUpdatePersistentSubscription,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified UpdatePersistentSubscription message, length delimited. Does not implicitly {@link eventstore.proto.UpdatePersistentSubscription.verify|verify} messages.\n       * @param message UpdatePersistentSubscription message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.IUpdatePersistentSubscription,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes an UpdatePersistentSubscription message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns UpdatePersistentSubscription\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.UpdatePersistentSubscription\n\n      /**\n       * Decodes an UpdatePersistentSubscription message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns UpdatePersistentSubscription\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.UpdatePersistentSubscription\n\n      /**\n       * Verifies an UpdatePersistentSubscription message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates an UpdatePersistentSubscription message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns UpdatePersistentSubscription\n       */\n      public static fromObject(object: {\n        [k: string]: any\n      }): eventstore.proto.UpdatePersistentSubscription\n\n      /**\n       * Creates a plain object from an UpdatePersistentSubscription message. Also converts values to other types if specified.\n       * @param message UpdatePersistentSubscription\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.UpdatePersistentSubscription,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this UpdatePersistentSubscription to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    /** Properties of an UpdatePersistentSubscriptionCompleted. */\n    interface IUpdatePersistentSubscriptionCompleted {\n      /** UpdatePersistentSubscriptionCompleted result */\n      result: eventstore.proto.UpdatePersistentSubscriptionCompleted.UpdatePersistentSubscriptionResult\n\n      /** UpdatePersistentSubscriptionCompleted reason */\n      reason?: string | null\n    }\n\n    /** Represents an UpdatePersistentSubscriptionCompleted. */\n    class UpdatePersistentSubscriptionCompleted implements IUpdatePersistentSubscriptionCompleted {\n      /**\n       * Constructs a new UpdatePersistentSubscriptionCompleted.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.IUpdatePersistentSubscriptionCompleted)\n\n      /** UpdatePersistentSubscriptionCompleted result. */\n      public result: eventstore.proto.UpdatePersistentSubscriptionCompleted.UpdatePersistentSubscriptionResult\n\n      /** UpdatePersistentSubscriptionCompleted reason. */\n      public reason: string\n\n      /**\n       * Creates a new UpdatePersistentSubscriptionCompleted instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns UpdatePersistentSubscriptionCompleted instance\n       */\n      public static create(\n        properties?: eventstore.proto.IUpdatePersistentSubscriptionCompleted\n      ): eventstore.proto.UpdatePersistentSubscriptionCompleted\n\n      /**\n       * Encodes the specified UpdatePersistentSubscriptionCompleted message. Does not implicitly {@link eventstore.proto.UpdatePersistentSubscriptionCompleted.verify|verify} messages.\n       * @param message UpdatePersistentSubscriptionCompleted message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.IUpdatePersistentSubscriptionCompleted,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified UpdatePersistentSubscriptionCompleted message, length delimited. Does not implicitly {@link eventstore.proto.UpdatePersistentSubscriptionCompleted.verify|verify} messages.\n       * @param message UpdatePersistentSubscriptionCompleted message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.IUpdatePersistentSubscriptionCompleted,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes an UpdatePersistentSubscriptionCompleted message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns UpdatePersistentSubscriptionCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.UpdatePersistentSubscriptionCompleted\n\n      /**\n       * Decodes an UpdatePersistentSubscriptionCompleted message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns UpdatePersistentSubscriptionCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.UpdatePersistentSubscriptionCompleted\n\n      /**\n       * Verifies an UpdatePersistentSubscriptionCompleted message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates an UpdatePersistentSubscriptionCompleted message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns UpdatePersistentSubscriptionCompleted\n       */\n      public static fromObject(object: {\n        [k: string]: any\n      }): eventstore.proto.UpdatePersistentSubscriptionCompleted\n\n      /**\n       * Creates a plain object from an UpdatePersistentSubscriptionCompleted message. Also converts values to other types if specified.\n       * @param message UpdatePersistentSubscriptionCompleted\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.UpdatePersistentSubscriptionCompleted,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this UpdatePersistentSubscriptionCompleted to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    namespace UpdatePersistentSubscriptionCompleted {\n      /** UpdatePersistentSubscriptionResult enum. */\n      enum UpdatePersistentSubscriptionResult {\n        Success = 0,\n        DoesNotExist = 1,\n        Fail = 2,\n        AccessDenied = 3\n      }\n    }\n\n    /** Properties of a CreatePersistentSubscriptionCompleted. */\n    interface ICreatePersistentSubscriptionCompleted {\n      /** CreatePersistentSubscriptionCompleted result */\n      result: eventstore.proto.CreatePersistentSubscriptionCompleted.CreatePersistentSubscriptionResult\n\n      /** CreatePersistentSubscriptionCompleted reason */\n      reason?: string | null\n    }\n\n    /** Represents a CreatePersistentSubscriptionCompleted. */\n    class CreatePersistentSubscriptionCompleted implements ICreatePersistentSubscriptionCompleted {\n      /**\n       * Constructs a new CreatePersistentSubscriptionCompleted.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.ICreatePersistentSubscriptionCompleted)\n\n      /** CreatePersistentSubscriptionCompleted result. */\n      public result: eventstore.proto.CreatePersistentSubscriptionCompleted.CreatePersistentSubscriptionResult\n\n      /** CreatePersistentSubscriptionCompleted reason. */\n      public reason: string\n\n      /**\n       * Creates a new CreatePersistentSubscriptionCompleted instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns CreatePersistentSubscriptionCompleted instance\n       */\n      public static create(\n        properties?: eventstore.proto.ICreatePersistentSubscriptionCompleted\n      ): eventstore.proto.CreatePersistentSubscriptionCompleted\n\n      /**\n       * Encodes the specified CreatePersistentSubscriptionCompleted message. Does not implicitly {@link eventstore.proto.CreatePersistentSubscriptionCompleted.verify|verify} messages.\n       * @param message CreatePersistentSubscriptionCompleted message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.ICreatePersistentSubscriptionCompleted,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified CreatePersistentSubscriptionCompleted message, length delimited. Does not implicitly {@link eventstore.proto.CreatePersistentSubscriptionCompleted.verify|verify} messages.\n       * @param message CreatePersistentSubscriptionCompleted message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.ICreatePersistentSubscriptionCompleted,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes a CreatePersistentSubscriptionCompleted message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns CreatePersistentSubscriptionCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.CreatePersistentSubscriptionCompleted\n\n      /**\n       * Decodes a CreatePersistentSubscriptionCompleted message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns CreatePersistentSubscriptionCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.CreatePersistentSubscriptionCompleted\n\n      /**\n       * Verifies a CreatePersistentSubscriptionCompleted message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates a CreatePersistentSubscriptionCompleted message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns CreatePersistentSubscriptionCompleted\n       */\n      public static fromObject(object: {\n        [k: string]: any\n      }): eventstore.proto.CreatePersistentSubscriptionCompleted\n\n      /**\n       * Creates a plain object from a CreatePersistentSubscriptionCompleted message. Also converts values to other types if specified.\n       * @param message CreatePersistentSubscriptionCompleted\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.CreatePersistentSubscriptionCompleted,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this CreatePersistentSubscriptionCompleted to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    namespace CreatePersistentSubscriptionCompleted {\n      /** CreatePersistentSubscriptionResult enum. */\n      enum CreatePersistentSubscriptionResult {\n        Success = 0,\n        AlreadyExists = 1,\n        Fail = 2,\n        AccessDenied = 3\n      }\n    }\n\n    /** Properties of a DeletePersistentSubscriptionCompleted. */\n    interface IDeletePersistentSubscriptionCompleted {\n      /** DeletePersistentSubscriptionCompleted result */\n      result: eventstore.proto.DeletePersistentSubscriptionCompleted.DeletePersistentSubscriptionResult\n\n      /** DeletePersistentSubscriptionCompleted reason */\n      reason?: string | null\n    }\n\n    /** Represents a DeletePersistentSubscriptionCompleted. */\n    class DeletePersistentSubscriptionCompleted implements IDeletePersistentSubscriptionCompleted {\n      /**\n       * Constructs a new DeletePersistentSubscriptionCompleted.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.IDeletePersistentSubscriptionCompleted)\n\n      /** DeletePersistentSubscriptionCompleted result. */\n      public result: eventstore.proto.DeletePersistentSubscriptionCompleted.DeletePersistentSubscriptionResult\n\n      /** DeletePersistentSubscriptionCompleted reason. */\n      public reason: string\n\n      /**\n       * Creates a new DeletePersistentSubscriptionCompleted instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns DeletePersistentSubscriptionCompleted instance\n       */\n      public static create(\n        properties?: eventstore.proto.IDeletePersistentSubscriptionCompleted\n      ): eventstore.proto.DeletePersistentSubscriptionCompleted\n\n      /**\n       * Encodes the specified DeletePersistentSubscriptionCompleted message. Does not implicitly {@link eventstore.proto.DeletePersistentSubscriptionCompleted.verify|verify} messages.\n       * @param message DeletePersistentSubscriptionCompleted message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.IDeletePersistentSubscriptionCompleted,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified DeletePersistentSubscriptionCompleted message, length delimited. Does not implicitly {@link eventstore.proto.DeletePersistentSubscriptionCompleted.verify|verify} messages.\n       * @param message DeletePersistentSubscriptionCompleted message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.IDeletePersistentSubscriptionCompleted,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes a DeletePersistentSubscriptionCompleted message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns DeletePersistentSubscriptionCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.DeletePersistentSubscriptionCompleted\n\n      /**\n       * Decodes a DeletePersistentSubscriptionCompleted message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns DeletePersistentSubscriptionCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.DeletePersistentSubscriptionCompleted\n\n      /**\n       * Verifies a DeletePersistentSubscriptionCompleted message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates a DeletePersistentSubscriptionCompleted message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns DeletePersistentSubscriptionCompleted\n       */\n      public static fromObject(object: {\n        [k: string]: any\n      }): eventstore.proto.DeletePersistentSubscriptionCompleted\n\n      /**\n       * Creates a plain object from a DeletePersistentSubscriptionCompleted message. Also converts values to other types if specified.\n       * @param message DeletePersistentSubscriptionCompleted\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.DeletePersistentSubscriptionCompleted,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this DeletePersistentSubscriptionCompleted to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    namespace DeletePersistentSubscriptionCompleted {\n      /** DeletePersistentSubscriptionResult enum. */\n      enum DeletePersistentSubscriptionResult {\n        Success = 0,\n        DoesNotExist = 1,\n        Fail = 2,\n        AccessDenied = 3\n      }\n    }\n\n    /** Properties of a ConnectToPersistentSubscription. */\n    interface IConnectToPersistentSubscription {\n      /** ConnectToPersistentSubscription subscriptionId */\n      subscriptionId: string\n\n      /** ConnectToPersistentSubscription eventStreamId */\n      eventStreamId: string\n\n      /** ConnectToPersistentSubscription allowedInFlightMessages */\n      allowedInFlightMessages: number\n    }\n\n    /** Represents a ConnectToPersistentSubscription. */\n    class ConnectToPersistentSubscription implements IConnectToPersistentSubscription {\n      /**\n       * Constructs a new ConnectToPersistentSubscription.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.IConnectToPersistentSubscription)\n\n      /** ConnectToPersistentSubscription subscriptionId. */\n      public subscriptionId: string\n\n      /** ConnectToPersistentSubscription eventStreamId. */\n      public eventStreamId: string\n\n      /** ConnectToPersistentSubscription allowedInFlightMessages. */\n      public allowedInFlightMessages: number\n\n      /**\n       * Creates a new ConnectToPersistentSubscription instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns ConnectToPersistentSubscription instance\n       */\n      public static create(\n        properties?: eventstore.proto.IConnectToPersistentSubscription\n      ): eventstore.proto.ConnectToPersistentSubscription\n\n      /**\n       * Encodes the specified ConnectToPersistentSubscription message. Does not implicitly {@link eventstore.proto.ConnectToPersistentSubscription.verify|verify} messages.\n       * @param message ConnectToPersistentSubscription message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.IConnectToPersistentSubscription,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified ConnectToPersistentSubscription message, length delimited. Does not implicitly {@link eventstore.proto.ConnectToPersistentSubscription.verify|verify} messages.\n       * @param message ConnectToPersistentSubscription message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.IConnectToPersistentSubscription,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes a ConnectToPersistentSubscription message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns ConnectToPersistentSubscription\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.ConnectToPersistentSubscription\n\n      /**\n       * Decodes a ConnectToPersistentSubscription message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns ConnectToPersistentSubscription\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.ConnectToPersistentSubscription\n\n      /**\n       * Verifies a ConnectToPersistentSubscription message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates a ConnectToPersistentSubscription message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns ConnectToPersistentSubscription\n       */\n      public static fromObject(object: {\n        [k: string]: any\n      }): eventstore.proto.ConnectToPersistentSubscription\n\n      /**\n       * Creates a plain object from a ConnectToPersistentSubscription message. Also converts values to other types if specified.\n       * @param message ConnectToPersistentSubscription\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.ConnectToPersistentSubscription,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this ConnectToPersistentSubscription to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    /** Properties of a PersistentSubscriptionAckEvents. */\n    interface IPersistentSubscriptionAckEvents {\n      /** PersistentSubscriptionAckEvents subscriptionId */\n      subscriptionId: string\n\n      /** PersistentSubscriptionAckEvents processedEventIds */\n      processedEventIds?: Uint8Array[] | null\n    }\n\n    /** Represents a PersistentSubscriptionAckEvents. */\n    class PersistentSubscriptionAckEvents implements IPersistentSubscriptionAckEvents {\n      /**\n       * Constructs a new PersistentSubscriptionAckEvents.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.IPersistentSubscriptionAckEvents)\n\n      /** PersistentSubscriptionAckEvents subscriptionId. */\n      public subscriptionId: string\n\n      /** PersistentSubscriptionAckEvents processedEventIds. */\n      public processedEventIds: Uint8Array[]\n\n      /**\n       * Creates a new PersistentSubscriptionAckEvents instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns PersistentSubscriptionAckEvents instance\n       */\n      public static create(\n        properties?: eventstore.proto.IPersistentSubscriptionAckEvents\n      ): eventstore.proto.PersistentSubscriptionAckEvents\n\n      /**\n       * Encodes the specified PersistentSubscriptionAckEvents message. Does not implicitly {@link eventstore.proto.PersistentSubscriptionAckEvents.verify|verify} messages.\n       * @param message PersistentSubscriptionAckEvents message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.IPersistentSubscriptionAckEvents,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified PersistentSubscriptionAckEvents message, length delimited. Does not implicitly {@link eventstore.proto.PersistentSubscriptionAckEvents.verify|verify} messages.\n       * @param message PersistentSubscriptionAckEvents message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.IPersistentSubscriptionAckEvents,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes a PersistentSubscriptionAckEvents message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns PersistentSubscriptionAckEvents\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.PersistentSubscriptionAckEvents\n\n      /**\n       * Decodes a PersistentSubscriptionAckEvents message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns PersistentSubscriptionAckEvents\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.PersistentSubscriptionAckEvents\n\n      /**\n       * Verifies a PersistentSubscriptionAckEvents message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates a PersistentSubscriptionAckEvents message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns PersistentSubscriptionAckEvents\n       */\n      public static fromObject(object: {\n        [k: string]: any\n      }): eventstore.proto.PersistentSubscriptionAckEvents\n\n      /**\n       * Creates a plain object from a PersistentSubscriptionAckEvents message. Also converts values to other types if specified.\n       * @param message PersistentSubscriptionAckEvents\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.PersistentSubscriptionAckEvents,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this PersistentSubscriptionAckEvents to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    /** Properties of a PersistentSubscriptionNakEvents. */\n    interface IPersistentSubscriptionNakEvents {\n      /** PersistentSubscriptionNakEvents subscriptionId */\n      subscriptionId: string\n\n      /** PersistentSubscriptionNakEvents processedEventIds */\n      processedEventIds?: Uint8Array[] | null\n\n      /** PersistentSubscriptionNakEvents message */\n      message?: string | null\n\n      /** PersistentSubscriptionNakEvents action */\n      action: eventstore.proto.PersistentSubscriptionNakEvents.NakAction\n    }\n\n    /** Represents a PersistentSubscriptionNakEvents. */\n    class PersistentSubscriptionNakEvents implements IPersistentSubscriptionNakEvents {\n      /**\n       * Constructs a new PersistentSubscriptionNakEvents.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.IPersistentSubscriptionNakEvents)\n\n      /** PersistentSubscriptionNakEvents subscriptionId. */\n      public subscriptionId: string\n\n      /** PersistentSubscriptionNakEvents processedEventIds. */\n      public processedEventIds: Uint8Array[]\n\n      /** PersistentSubscriptionNakEvents message. */\n      public message: string\n\n      /** PersistentSubscriptionNakEvents action. */\n      public action: eventstore.proto.PersistentSubscriptionNakEvents.NakAction\n\n      /**\n       * Creates a new PersistentSubscriptionNakEvents instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns PersistentSubscriptionNakEvents instance\n       */\n      public static create(\n        properties?: eventstore.proto.IPersistentSubscriptionNakEvents\n      ): eventstore.proto.PersistentSubscriptionNakEvents\n\n      /**\n       * Encodes the specified PersistentSubscriptionNakEvents message. Does not implicitly {@link eventstore.proto.PersistentSubscriptionNakEvents.verify|verify} messages.\n       * @param message PersistentSubscriptionNakEvents message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.IPersistentSubscriptionNakEvents,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified PersistentSubscriptionNakEvents message, length delimited. Does not implicitly {@link eventstore.proto.PersistentSubscriptionNakEvents.verify|verify} messages.\n       * @param message PersistentSubscriptionNakEvents message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.IPersistentSubscriptionNakEvents,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes a PersistentSubscriptionNakEvents message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns PersistentSubscriptionNakEvents\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.PersistentSubscriptionNakEvents\n\n      /**\n       * Decodes a PersistentSubscriptionNakEvents message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns PersistentSubscriptionNakEvents\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.PersistentSubscriptionNakEvents\n\n      /**\n       * Verifies a PersistentSubscriptionNakEvents message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates a PersistentSubscriptionNakEvents message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns PersistentSubscriptionNakEvents\n       */\n      public static fromObject(object: {\n        [k: string]: any\n      }): eventstore.proto.PersistentSubscriptionNakEvents\n\n      /**\n       * Creates a plain object from a PersistentSubscriptionNakEvents message. Also converts values to other types if specified.\n       * @param message PersistentSubscriptionNakEvents\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.PersistentSubscriptionNakEvents,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this PersistentSubscriptionNakEvents to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    namespace PersistentSubscriptionNakEvents {\n      /** NakAction enum. */\n      enum NakAction {\n        Unknown = 0,\n        Park = 1,\n        Retry = 2,\n        Skip = 3,\n        Stop = 4\n      }\n    }\n\n    /** Properties of a PersistentSubscriptionConfirmation. */\n    interface IPersistentSubscriptionConfirmation {\n      /** PersistentSubscriptionConfirmation lastCommitPosition */\n      lastCommitPosition: number | Long\n\n      /** PersistentSubscriptionConfirmation subscriptionId */\n      subscriptionId: string\n\n      /** PersistentSubscriptionConfirmation lastEventNumber */\n      lastEventNumber?: number | Long | null\n    }\n\n    /** Represents a PersistentSubscriptionConfirmation. */\n    class PersistentSubscriptionConfirmation implements IPersistentSubscriptionConfirmation {\n      /**\n       * Constructs a new PersistentSubscriptionConfirmation.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.IPersistentSubscriptionConfirmation)\n\n      /** PersistentSubscriptionConfirmation lastCommitPosition. */\n      public lastCommitPosition: number | Long\n\n      /** PersistentSubscriptionConfirmation subscriptionId. */\n      public subscriptionId: string\n\n      /** PersistentSubscriptionConfirmation lastEventNumber. */\n      public lastEventNumber: number | Long\n\n      /**\n       * Creates a new PersistentSubscriptionConfirmation instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns PersistentSubscriptionConfirmation instance\n       */\n      public static create(\n        properties?: eventstore.proto.IPersistentSubscriptionConfirmation\n      ): eventstore.proto.PersistentSubscriptionConfirmation\n\n      /**\n       * Encodes the specified PersistentSubscriptionConfirmation message. Does not implicitly {@link eventstore.proto.PersistentSubscriptionConfirmation.verify|verify} messages.\n       * @param message PersistentSubscriptionConfirmation message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.IPersistentSubscriptionConfirmation,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified PersistentSubscriptionConfirmation message, length delimited. Does not implicitly {@link eventstore.proto.PersistentSubscriptionConfirmation.verify|verify} messages.\n       * @param message PersistentSubscriptionConfirmation message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.IPersistentSubscriptionConfirmation,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes a PersistentSubscriptionConfirmation message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns PersistentSubscriptionConfirmation\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.PersistentSubscriptionConfirmation\n\n      /**\n       * Decodes a PersistentSubscriptionConfirmation message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns PersistentSubscriptionConfirmation\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.PersistentSubscriptionConfirmation\n\n      /**\n       * Verifies a PersistentSubscriptionConfirmation message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates a PersistentSubscriptionConfirmation message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns PersistentSubscriptionConfirmation\n       */\n      public static fromObject(object: {\n        [k: string]: any\n      }): eventstore.proto.PersistentSubscriptionConfirmation\n\n      /**\n       * Creates a plain object from a PersistentSubscriptionConfirmation message. Also converts values to other types if specified.\n       * @param message PersistentSubscriptionConfirmation\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.PersistentSubscriptionConfirmation,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this PersistentSubscriptionConfirmation to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    /** Properties of a PersistentSubscriptionStreamEventAppeared. */\n    interface IPersistentSubscriptionStreamEventAppeared {\n      /** PersistentSubscriptionStreamEventAppeared event */\n      event: eventstore.proto.IResolvedIndexedEvent\n    }\n\n    /** Represents a PersistentSubscriptionStreamEventAppeared. */\n    class PersistentSubscriptionStreamEventAppeared\n      implements IPersistentSubscriptionStreamEventAppeared {\n      /**\n       * Constructs a new PersistentSubscriptionStreamEventAppeared.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.IPersistentSubscriptionStreamEventAppeared)\n\n      /** PersistentSubscriptionStreamEventAppeared event. */\n      public event: eventstore.proto.IResolvedIndexedEvent\n\n      /**\n       * Creates a new PersistentSubscriptionStreamEventAppeared instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns PersistentSubscriptionStreamEventAppeared instance\n       */\n      public static create(\n        properties?: eventstore.proto.IPersistentSubscriptionStreamEventAppeared\n      ): eventstore.proto.PersistentSubscriptionStreamEventAppeared\n\n      /**\n       * Encodes the specified PersistentSubscriptionStreamEventAppeared message. Does not implicitly {@link eventstore.proto.PersistentSubscriptionStreamEventAppeared.verify|verify} messages.\n       * @param message PersistentSubscriptionStreamEventAppeared message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.IPersistentSubscriptionStreamEventAppeared,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified PersistentSubscriptionStreamEventAppeared message, length delimited. Does not implicitly {@link eventstore.proto.PersistentSubscriptionStreamEventAppeared.verify|verify} messages.\n       * @param message PersistentSubscriptionStreamEventAppeared message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.IPersistentSubscriptionStreamEventAppeared,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes a PersistentSubscriptionStreamEventAppeared message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns PersistentSubscriptionStreamEventAppeared\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.PersistentSubscriptionStreamEventAppeared\n\n      /**\n       * Decodes a PersistentSubscriptionStreamEventAppeared message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns PersistentSubscriptionStreamEventAppeared\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.PersistentSubscriptionStreamEventAppeared\n\n      /**\n       * Verifies a PersistentSubscriptionStreamEventAppeared message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates a PersistentSubscriptionStreamEventAppeared message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns PersistentSubscriptionStreamEventAppeared\n       */\n      public static fromObject(object: {\n        [k: string]: any\n      }): eventstore.proto.PersistentSubscriptionStreamEventAppeared\n\n      /**\n       * Creates a plain object from a PersistentSubscriptionStreamEventAppeared message. Also converts values to other types if specified.\n       * @param message PersistentSubscriptionStreamEventAppeared\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.PersistentSubscriptionStreamEventAppeared,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this PersistentSubscriptionStreamEventAppeared to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    /** Properties of a SubscribeToStream. */\n    interface ISubscribeToStream {\n      /** SubscribeToStream eventStreamId */\n      eventStreamId: string\n\n      /** SubscribeToStream resolveLinkTos */\n      resolveLinkTos: boolean\n    }\n\n    /** Represents a SubscribeToStream. */\n    class SubscribeToStream implements ISubscribeToStream {\n      /**\n       * Constructs a new SubscribeToStream.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.ISubscribeToStream)\n\n      /** SubscribeToStream eventStreamId. */\n      public eventStreamId: string\n\n      /** SubscribeToStream resolveLinkTos. */\n      public resolveLinkTos: boolean\n\n      /**\n       * Creates a new SubscribeToStream instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns SubscribeToStream instance\n       */\n      public static create(\n        properties?: eventstore.proto.ISubscribeToStream\n      ): eventstore.proto.SubscribeToStream\n\n      /**\n       * Encodes the specified SubscribeToStream message. Does not implicitly {@link eventstore.proto.SubscribeToStream.verify|verify} messages.\n       * @param message SubscribeToStream message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.ISubscribeToStream,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified SubscribeToStream message, length delimited. Does not implicitly {@link eventstore.proto.SubscribeToStream.verify|verify} messages.\n       * @param message SubscribeToStream message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.ISubscribeToStream,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes a SubscribeToStream message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns SubscribeToStream\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.SubscribeToStream\n\n      /**\n       * Decodes a SubscribeToStream message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns SubscribeToStream\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.SubscribeToStream\n\n      /**\n       * Verifies a SubscribeToStream message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates a SubscribeToStream message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns SubscribeToStream\n       */\n      public static fromObject(object: {[k: string]: any}): eventstore.proto.SubscribeToStream\n\n      /**\n       * Creates a plain object from a SubscribeToStream message. Also converts values to other types if specified.\n       * @param message SubscribeToStream\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.SubscribeToStream,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this SubscribeToStream to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    /** Properties of a SubscriptionConfirmation. */\n    interface ISubscriptionConfirmation {\n      /** SubscriptionConfirmation lastCommitPosition */\n      lastCommitPosition: number | Long\n\n      /** SubscriptionConfirmation lastEventNumber */\n      lastEventNumber?: number | Long | null\n    }\n\n    /** Represents a SubscriptionConfirmation. */\n    class SubscriptionConfirmation implements ISubscriptionConfirmation {\n      /**\n       * Constructs a new SubscriptionConfirmation.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.ISubscriptionConfirmation)\n\n      /** SubscriptionConfirmation lastCommitPosition. */\n      public lastCommitPosition: number | Long\n\n      /** SubscriptionConfirmation lastEventNumber. */\n      public lastEventNumber: number | Long\n\n      /**\n       * Creates a new SubscriptionConfirmation instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns SubscriptionConfirmation instance\n       */\n      public static create(\n        properties?: eventstore.proto.ISubscriptionConfirmation\n      ): eventstore.proto.SubscriptionConfirmation\n\n      /**\n       * Encodes the specified SubscriptionConfirmation message. Does not implicitly {@link eventstore.proto.SubscriptionConfirmation.verify|verify} messages.\n       * @param message SubscriptionConfirmation message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.ISubscriptionConfirmation,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified SubscriptionConfirmation message, length delimited. Does not implicitly {@link eventstore.proto.SubscriptionConfirmation.verify|verify} messages.\n       * @param message SubscriptionConfirmation message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.ISubscriptionConfirmation,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes a SubscriptionConfirmation message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns SubscriptionConfirmation\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.SubscriptionConfirmation\n\n      /**\n       * Decodes a SubscriptionConfirmation message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns SubscriptionConfirmation\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.SubscriptionConfirmation\n\n      /**\n       * Verifies a SubscriptionConfirmation message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates a SubscriptionConfirmation message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns SubscriptionConfirmation\n       */\n      public static fromObject(object: {\n        [k: string]: any\n      }): eventstore.proto.SubscriptionConfirmation\n\n      /**\n       * Creates a plain object from a SubscriptionConfirmation message. Also converts values to other types if specified.\n       * @param message SubscriptionConfirmation\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.SubscriptionConfirmation,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this SubscriptionConfirmation to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    /** Properties of a StreamEventAppeared. */\n    interface IStreamEventAppeared {\n      /** StreamEventAppeared event */\n      event: eventstore.proto.IResolvedEvent\n    }\n\n    /** Represents a StreamEventAppeared. */\n    class StreamEventAppeared implements IStreamEventAppeared {\n      /**\n       * Constructs a new StreamEventAppeared.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.IStreamEventAppeared)\n\n      /** StreamEventAppeared event. */\n      public event: eventstore.proto.IResolvedEvent\n\n      /**\n       * Creates a new StreamEventAppeared instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns StreamEventAppeared instance\n       */\n      public static create(\n        properties?: eventstore.proto.IStreamEventAppeared\n      ): eventstore.proto.StreamEventAppeared\n\n      /**\n       * Encodes the specified StreamEventAppeared message. Does not implicitly {@link eventstore.proto.StreamEventAppeared.verify|verify} messages.\n       * @param message StreamEventAppeared message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.IStreamEventAppeared,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified StreamEventAppeared message, length delimited. Does not implicitly {@link eventstore.proto.StreamEventAppeared.verify|verify} messages.\n       * @param message StreamEventAppeared message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.IStreamEventAppeared,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes a StreamEventAppeared message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns StreamEventAppeared\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.StreamEventAppeared\n\n      /**\n       * Decodes a StreamEventAppeared message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns StreamEventAppeared\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.StreamEventAppeared\n\n      /**\n       * Verifies a StreamEventAppeared message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates a StreamEventAppeared message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns StreamEventAppeared\n       */\n      public static fromObject(object: {[k: string]: any}): eventstore.proto.StreamEventAppeared\n\n      /**\n       * Creates a plain object from a StreamEventAppeared message. Also converts values to other types if specified.\n       * @param message StreamEventAppeared\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.StreamEventAppeared,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this StreamEventAppeared to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    /** Properties of an UnsubscribeFromStream. */\n    interface IUnsubscribeFromStream {}\n\n    /** Represents an UnsubscribeFromStream. */\n    class UnsubscribeFromStream implements IUnsubscribeFromStream {\n      /**\n       * Constructs a new UnsubscribeFromStream.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.IUnsubscribeFromStream)\n\n      /**\n       * Creates a new UnsubscribeFromStream instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns UnsubscribeFromStream instance\n       */\n      public static create(\n        properties?: eventstore.proto.IUnsubscribeFromStream\n      ): eventstore.proto.UnsubscribeFromStream\n\n      /**\n       * Encodes the specified UnsubscribeFromStream message. Does not implicitly {@link eventstore.proto.UnsubscribeFromStream.verify|verify} messages.\n       * @param message UnsubscribeFromStream message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.IUnsubscribeFromStream,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified UnsubscribeFromStream message, length delimited. Does not implicitly {@link eventstore.proto.UnsubscribeFromStream.verify|verify} messages.\n       * @param message UnsubscribeFromStream message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.IUnsubscribeFromStream,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes an UnsubscribeFromStream message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns UnsubscribeFromStream\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.UnsubscribeFromStream\n\n      /**\n       * Decodes an UnsubscribeFromStream message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns UnsubscribeFromStream\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.UnsubscribeFromStream\n\n      /**\n       * Verifies an UnsubscribeFromStream message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates an UnsubscribeFromStream message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns UnsubscribeFromStream\n       */\n      public static fromObject(object: {[k: string]: any}): eventstore.proto.UnsubscribeFromStream\n\n      /**\n       * Creates a plain object from an UnsubscribeFromStream message. Also converts values to other types if specified.\n       * @param message UnsubscribeFromStream\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.UnsubscribeFromStream,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this UnsubscribeFromStream to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    /** Properties of a SubscriptionDropped. */\n    interface ISubscriptionDropped {\n      /** SubscriptionDropped reason */\n      reason?: eventstore.proto.SubscriptionDropped.SubscriptionDropReason | null\n    }\n\n    /** Represents a SubscriptionDropped. */\n    class SubscriptionDropped implements ISubscriptionDropped {\n      /**\n       * Constructs a new SubscriptionDropped.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.ISubscriptionDropped)\n\n      /** SubscriptionDropped reason. */\n      public reason: eventstore.proto.SubscriptionDropped.SubscriptionDropReason\n\n      /**\n       * Creates a new SubscriptionDropped instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns SubscriptionDropped instance\n       */\n      public static create(\n        properties?: eventstore.proto.ISubscriptionDropped\n      ): eventstore.proto.SubscriptionDropped\n\n      /**\n       * Encodes the specified SubscriptionDropped message. Does not implicitly {@link eventstore.proto.SubscriptionDropped.verify|verify} messages.\n       * @param message SubscriptionDropped message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.ISubscriptionDropped,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified SubscriptionDropped message, length delimited. Does not implicitly {@link eventstore.proto.SubscriptionDropped.verify|verify} messages.\n       * @param message SubscriptionDropped message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.ISubscriptionDropped,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes a SubscriptionDropped message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns SubscriptionDropped\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.SubscriptionDropped\n\n      /**\n       * Decodes a SubscriptionDropped message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns SubscriptionDropped\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.SubscriptionDropped\n\n      /**\n       * Verifies a SubscriptionDropped message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates a SubscriptionDropped message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns SubscriptionDropped\n       */\n      public static fromObject(object: {[k: string]: any}): eventstore.proto.SubscriptionDropped\n\n      /**\n       * Creates a plain object from a SubscriptionDropped message. Also converts values to other types if specified.\n       * @param message SubscriptionDropped\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.SubscriptionDropped,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this SubscriptionDropped to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    namespace SubscriptionDropped {\n      /** SubscriptionDropReason enum. */\n      enum SubscriptionDropReason {\n        Unsubscribed = 0,\n        AccessDenied = 1,\n        NotFound = 2,\n        PersistentSubscriptionDeleted = 3,\n        SubscriberMaxCountReached = 4\n      }\n    }\n\n    /** Properties of a NotHandled. */\n    interface INotHandled {\n      /** NotHandled reason */\n      reason: eventstore.proto.NotHandled.NotHandledReason\n\n      /** NotHandled additionalInfo */\n      additionalInfo?: eventstore.proto.NotHandled.IMasterInfo | null\n    }\n\n    /** Represents a NotHandled. */\n    class NotHandled implements INotHandled {\n      /**\n       * Constructs a new NotHandled.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.INotHandled)\n\n      /** NotHandled reason. */\n      public reason: eventstore.proto.NotHandled.NotHandledReason\n\n      /** NotHandled additionalInfo. */\n      public additionalInfo?: eventstore.proto.NotHandled.IMasterInfo | null\n\n      /**\n       * Creates a new NotHandled instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns NotHandled instance\n       */\n      public static create(properties?: eventstore.proto.INotHandled): eventstore.proto.NotHandled\n\n      /**\n       * Encodes the specified NotHandled message. Does not implicitly {@link eventstore.proto.NotHandled.verify|verify} messages.\n       * @param message NotHandled message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.INotHandled,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified NotHandled message, length delimited. Does not implicitly {@link eventstore.proto.NotHandled.verify|verify} messages.\n       * @param message NotHandled message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.INotHandled,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes a NotHandled message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns NotHandled\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.NotHandled\n\n      /**\n       * Decodes a NotHandled message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns NotHandled\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.NotHandled\n\n      /**\n       * Verifies a NotHandled message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates a NotHandled message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns NotHandled\n       */\n      public static fromObject(object: {[k: string]: any}): eventstore.proto.NotHandled\n\n      /**\n       * Creates a plain object from a NotHandled message. Also converts values to other types if specified.\n       * @param message NotHandled\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.NotHandled,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this NotHandled to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    namespace NotHandled {\n      /** NotHandledReason enum. */\n      enum NotHandledReason {\n        NotReady = 0,\n        TooBusy = 1,\n        NotMaster = 2\n      }\n\n      /** Properties of a MasterInfo. */\n      interface IMasterInfo {\n        /** MasterInfo externalTcpAddress */\n        externalTcpAddress: string\n\n        /** MasterInfo externalTcpPort */\n        externalTcpPort: number\n\n        /** MasterInfo externalHttpAddress */\n        externalHttpAddress: string\n\n        /** MasterInfo externalHttpPort */\n        externalHttpPort: number\n\n        /** MasterInfo externalSecureTcpAddress */\n        externalSecureTcpAddress?: string | null\n\n        /** MasterInfo externalSecureTcpPort */\n        externalSecureTcpPort?: number | null\n      }\n\n      /** Represents a MasterInfo. */\n      class MasterInfo implements IMasterInfo {\n        /**\n         * Constructs a new MasterInfo.\n         * @param [properties] Properties to set\n         */\n        constructor(properties?: eventstore.proto.NotHandled.IMasterInfo)\n\n        /** MasterInfo externalTcpAddress. */\n        public externalTcpAddress: string\n\n        /** MasterInfo externalTcpPort. */\n        public externalTcpPort: number\n\n        /** MasterInfo externalHttpAddress. */\n        public externalHttpAddress: string\n\n        /** MasterInfo externalHttpPort. */\n        public externalHttpPort: number\n\n        /** MasterInfo externalSecureTcpAddress. */\n        public externalSecureTcpAddress: string\n\n        /** MasterInfo externalSecureTcpPort. */\n        public externalSecureTcpPort: number\n\n        /**\n         * Creates a new MasterInfo instance using the specified properties.\n         * @param [properties] Properties to set\n         * @returns MasterInfo instance\n         */\n        public static create(\n          properties?: eventstore.proto.NotHandled.IMasterInfo\n        ): eventstore.proto.NotHandled.MasterInfo\n\n        /**\n         * Encodes the specified MasterInfo message. Does not implicitly {@link eventstore.proto.NotHandled.MasterInfo.verify|verify} messages.\n         * @param message MasterInfo message or plain object to encode\n         * @param [writer] Writer to encode to\n         * @returns Writer\n         */\n        public static encode(\n          message: eventstore.proto.NotHandled.IMasterInfo,\n          writer?: $protobuf.Writer\n        ): $protobuf.Writer\n\n        /**\n         * Encodes the specified MasterInfo message, length delimited. Does not implicitly {@link eventstore.proto.NotHandled.MasterInfo.verify|verify} messages.\n         * @param message MasterInfo message or plain object to encode\n         * @param [writer] Writer to encode to\n         * @returns Writer\n         */\n        public static encodeDelimited(\n          message: eventstore.proto.NotHandled.IMasterInfo,\n          writer?: $protobuf.Writer\n        ): $protobuf.Writer\n\n        /**\n         * Decodes a MasterInfo message from the specified reader or buffer.\n         * @param reader Reader or buffer to decode from\n         * @param [length] Message length if known beforehand\n         * @returns MasterInfo\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        public static decode(\n          reader: $protobuf.Reader | Uint8Array,\n          length?: number\n        ): eventstore.proto.NotHandled.MasterInfo\n\n        /**\n         * Decodes a MasterInfo message from the specified reader or buffer, length delimited.\n         * @param reader Reader or buffer to decode from\n         * @returns MasterInfo\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        public static decodeDelimited(\n          reader: $protobuf.Reader | Uint8Array\n        ): eventstore.proto.NotHandled.MasterInfo\n\n        /**\n         * Verifies a MasterInfo message.\n         * @param message Plain object to verify\n         * @returns `null` if valid, otherwise the reason why it is not\n         */\n        public static verify(message: {[k: string]: any}): string | null\n\n        /**\n         * Creates a MasterInfo message from a plain object. Also converts values to their respective internal types.\n         * @param object Plain object\n         * @returns MasterInfo\n         */\n        public static fromObject(object: {[k: string]: any}): eventstore.proto.NotHandled.MasterInfo\n\n        /**\n         * Creates a plain object from a MasterInfo message. Also converts values to other types if specified.\n         * @param message MasterInfo\n         * @param [options] Conversion options\n         * @returns Plain object\n         */\n        public static toObject(\n          message: eventstore.proto.NotHandled.MasterInfo,\n          options?: $protobuf.IConversionOptions\n        ): {[k: string]: any}\n\n        /**\n         * Converts this MasterInfo to JSON.\n         * @returns JSON object\n         */\n        public toJSON(): {[k: string]: any}\n      }\n    }\n\n    /** Properties of a ScavengeDatabase. */\n    interface IScavengeDatabase {}\n\n    /** Represents a ScavengeDatabase. */\n    class ScavengeDatabase implements IScavengeDatabase {\n      /**\n       * Constructs a new ScavengeDatabase.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.IScavengeDatabase)\n\n      /**\n       * Creates a new ScavengeDatabase instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns ScavengeDatabase instance\n       */\n      public static create(\n        properties?: eventstore.proto.IScavengeDatabase\n      ): eventstore.proto.ScavengeDatabase\n\n      /**\n       * Encodes the specified ScavengeDatabase message. Does not implicitly {@link eventstore.proto.ScavengeDatabase.verify|verify} messages.\n       * @param message ScavengeDatabase message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.IScavengeDatabase,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified ScavengeDatabase message, length delimited. Does not implicitly {@link eventstore.proto.ScavengeDatabase.verify|verify} messages.\n       * @param message ScavengeDatabase message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.IScavengeDatabase,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes a ScavengeDatabase message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns ScavengeDatabase\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.ScavengeDatabase\n\n      /**\n       * Decodes a ScavengeDatabase message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns ScavengeDatabase\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.ScavengeDatabase\n\n      /**\n       * Verifies a ScavengeDatabase message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates a ScavengeDatabase message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns ScavengeDatabase\n       */\n      public static fromObject(object: {[k: string]: any}): eventstore.proto.ScavengeDatabase\n\n      /**\n       * Creates a plain object from a ScavengeDatabase message. Also converts values to other types if specified.\n       * @param message ScavengeDatabase\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.ScavengeDatabase,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this ScavengeDatabase to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    /** Properties of a ScavengeDatabaseResponse. */\n    interface IScavengeDatabaseResponse {\n      /** ScavengeDatabaseResponse result */\n      result: eventstore.proto.ScavengeDatabaseResponse.ScavengeResult\n\n      /** ScavengeDatabaseResponse scavengeId */\n      scavengeId?: string | null\n    }\n\n    /** Represents a ScavengeDatabaseResponse. */\n    class ScavengeDatabaseResponse implements IScavengeDatabaseResponse {\n      /**\n       * Constructs a new ScavengeDatabaseResponse.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.IScavengeDatabaseResponse)\n\n      /** ScavengeDatabaseResponse result. */\n      public result: eventstore.proto.ScavengeDatabaseResponse.ScavengeResult\n\n      /** ScavengeDatabaseResponse scavengeId. */\n      public scavengeId: string\n\n      /**\n       * Creates a new ScavengeDatabaseResponse instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns ScavengeDatabaseResponse instance\n       */\n      public static create(\n        properties?: eventstore.proto.IScavengeDatabaseResponse\n      ): eventstore.proto.ScavengeDatabaseResponse\n\n      /**\n       * Encodes the specified ScavengeDatabaseResponse message. Does not implicitly {@link eventstore.proto.ScavengeDatabaseResponse.verify|verify} messages.\n       * @param message ScavengeDatabaseResponse message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.IScavengeDatabaseResponse,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified ScavengeDatabaseResponse message, length delimited. Does not implicitly {@link eventstore.proto.ScavengeDatabaseResponse.verify|verify} messages.\n       * @param message ScavengeDatabaseResponse message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.IScavengeDatabaseResponse,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes a ScavengeDatabaseResponse message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns ScavengeDatabaseResponse\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.ScavengeDatabaseResponse\n\n      /**\n       * Decodes a ScavengeDatabaseResponse message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns ScavengeDatabaseResponse\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.ScavengeDatabaseResponse\n\n      /**\n       * Verifies a ScavengeDatabaseResponse message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates a ScavengeDatabaseResponse message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns ScavengeDatabaseResponse\n       */\n      public static fromObject(object: {\n        [k: string]: any\n      }): eventstore.proto.ScavengeDatabaseResponse\n\n      /**\n       * Creates a plain object from a ScavengeDatabaseResponse message. Also converts values to other types if specified.\n       * @param message ScavengeDatabaseResponse\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.ScavengeDatabaseResponse,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this ScavengeDatabaseResponse to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    namespace ScavengeDatabaseResponse {\n      /** ScavengeResult enum. */\n      enum ScavengeResult {\n        Started = 0,\n        InProgress = 1,\n        Unauthorized = 2\n      }\n    }\n\n    /** Properties of an IdentifyClient. */\n    interface IIdentifyClient {\n      /** IdentifyClient version */\n      version: number\n\n      /** IdentifyClient connectionName */\n      connectionName?: string | null\n    }\n\n    /** Represents an IdentifyClient. */\n    class IdentifyClient implements IIdentifyClient {\n      /**\n       * Constructs a new IdentifyClient.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.IIdentifyClient)\n\n      /** IdentifyClient version. */\n      public version: number\n\n      /** IdentifyClient connectionName. */\n      public connectionName: string\n\n      /**\n       * Creates a new IdentifyClient instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns IdentifyClient instance\n       */\n      public static create(\n        properties?: eventstore.proto.IIdentifyClient\n      ): eventstore.proto.IdentifyClient\n\n      /**\n       * Encodes the specified IdentifyClient message. Does not implicitly {@link eventstore.proto.IdentifyClient.verify|verify} messages.\n       * @param message IdentifyClient message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.IIdentifyClient,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified IdentifyClient message, length delimited. Does not implicitly {@link eventstore.proto.IdentifyClient.verify|verify} messages.\n       * @param message IdentifyClient message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.IIdentifyClient,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes an IdentifyClient message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns IdentifyClient\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.IdentifyClient\n\n      /**\n       * Decodes an IdentifyClient message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns IdentifyClient\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.IdentifyClient\n\n      /**\n       * Verifies an IdentifyClient message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates an IdentifyClient message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns IdentifyClient\n       */\n      public static fromObject(object: {[k: string]: any}): eventstore.proto.IdentifyClient\n\n      /**\n       * Creates a plain object from an IdentifyClient message. Also converts values to other types if specified.\n       * @param message IdentifyClient\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.IdentifyClient,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this IdentifyClient to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n\n    /** Properties of a ClientIdentified. */\n    interface IClientIdentified {}\n\n    /** Represents a ClientIdentified. */\n    class ClientIdentified implements IClientIdentified {\n      /**\n       * Constructs a new ClientIdentified.\n       * @param [properties] Properties to set\n       */\n      constructor(properties?: eventstore.proto.IClientIdentified)\n\n      /**\n       * Creates a new ClientIdentified instance using the specified properties.\n       * @param [properties] Properties to set\n       * @returns ClientIdentified instance\n       */\n      public static create(\n        properties?: eventstore.proto.IClientIdentified\n      ): eventstore.proto.ClientIdentified\n\n      /**\n       * Encodes the specified ClientIdentified message. Does not implicitly {@link eventstore.proto.ClientIdentified.verify|verify} messages.\n       * @param message ClientIdentified message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encode(\n        message: eventstore.proto.IClientIdentified,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Encodes the specified ClientIdentified message, length delimited. Does not implicitly {@link eventstore.proto.ClientIdentified.verify|verify} messages.\n       * @param message ClientIdentified message or plain object to encode\n       * @param [writer] Writer to encode to\n       * @returns Writer\n       */\n      public static encodeDelimited(\n        message: eventstore.proto.IClientIdentified,\n        writer?: $protobuf.Writer\n      ): $protobuf.Writer\n\n      /**\n       * Decodes a ClientIdentified message from the specified reader or buffer.\n       * @param reader Reader or buffer to decode from\n       * @param [length] Message length if known beforehand\n       * @returns ClientIdentified\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decode(\n        reader: $protobuf.Reader | Uint8Array,\n        length?: number\n      ): eventstore.proto.ClientIdentified\n\n      /**\n       * Decodes a ClientIdentified message from the specified reader or buffer, length delimited.\n       * @param reader Reader or buffer to decode from\n       * @returns ClientIdentified\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      public static decodeDelimited(\n        reader: $protobuf.Reader | Uint8Array\n      ): eventstore.proto.ClientIdentified\n\n      /**\n       * Verifies a ClientIdentified message.\n       * @param message Plain object to verify\n       * @returns `null` if valid, otherwise the reason why it is not\n       */\n      public static verify(message: {[k: string]: any}): string | null\n\n      /**\n       * Creates a ClientIdentified message from a plain object. Also converts values to their respective internal types.\n       * @param object Plain object\n       * @returns ClientIdentified\n       */\n      public static fromObject(object: {[k: string]: any}): eventstore.proto.ClientIdentified\n\n      /**\n       * Creates a plain object from a ClientIdentified message. Also converts values to other types if specified.\n       * @param message ClientIdentified\n       * @param [options] Conversion options\n       * @returns Plain object\n       */\n      public static toObject(\n        message: eventstore.proto.ClientIdentified,\n        options?: $protobuf.IConversionOptions\n      ): {[k: string]: any}\n\n      /**\n       * Converts this ClientIdentified to JSON.\n       * @returns JSON object\n       */\n      public toJSON(): {[k: string]: any}\n    }\n  }\n}\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/src/protobuf/model.d.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 299,
    "kind": "file",
    "name": "src/protobuf/model.js",
    "content": "/* eslint-disable */\n'use strict'\n\nvar $protobuf = require('protobufjs/minimal')\n\n// Common aliases\nvar $Reader = $protobuf.Reader,\n  $Writer = $protobuf.Writer,\n  $util = $protobuf.util\n\n// Exported root namespace\nvar $root = $protobuf.roots['default'] || ($protobuf.roots['default'] = {})\n\n$root.eventstore = (function() {\n  /**\n   * Namespace eventstore.\n   * @exports eventstore\n   * @namespace\n   */\n  var eventstore = {}\n\n  eventstore.proto = (function() {\n    /**\n     * Namespace proto.\n     * @memberof eventstore\n     * @namespace\n     */\n    var proto = {}\n\n    /**\n     * OperationResult enum.\n     * @name eventstore.proto.OperationResult\n     * @enum {string}\n     * @property {number} Success=0 Success value\n     * @property {number} PrepareTimeout=1 PrepareTimeout value\n     * @property {number} CommitTimeout=2 CommitTimeout value\n     * @property {number} ForwardTimeout=3 ForwardTimeout value\n     * @property {number} WrongExpectedVersion=4 WrongExpectedVersion value\n     * @property {number} StreamDeleted=5 StreamDeleted value\n     * @property {number} InvalidTransaction=6 InvalidTransaction value\n     * @property {number} AccessDenied=7 AccessDenied value\n     */\n    proto.OperationResult = (function() {\n      var valuesById = {},\n        values = Object.create(valuesById)\n      values[(valuesById[0] = 'Success')] = 0\n      values[(valuesById[1] = 'PrepareTimeout')] = 1\n      values[(valuesById[2] = 'CommitTimeout')] = 2\n      values[(valuesById[3] = 'ForwardTimeout')] = 3\n      values[(valuesById[4] = 'WrongExpectedVersion')] = 4\n      values[(valuesById[5] = 'StreamDeleted')] = 5\n      values[(valuesById[6] = 'InvalidTransaction')] = 6\n      values[(valuesById[7] = 'AccessDenied')] = 7\n      return values\n    })()\n\n    proto.NewEvent = (function() {\n      /**\n       * Properties of a NewEvent.\n       * @memberof eventstore.proto\n       * @interface INewEvent\n       * @property {Uint8Array} eventId NewEvent eventId\n       * @property {string} eventType NewEvent eventType\n       * @property {number} dataContentType NewEvent dataContentType\n       * @property {number} metadataContentType NewEvent metadataContentType\n       * @property {Uint8Array} data NewEvent data\n       * @property {Uint8Array|null} [metadata] NewEvent metadata\n       */\n\n      /**\n       * Constructs a new NewEvent.\n       * @memberof eventstore.proto\n       * @classdesc Represents a NewEvent.\n       * @implements INewEvent\n       * @constructor\n       * @param {eventstore.proto.INewEvent=} [properties] Properties to set\n       */\n      function NewEvent(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * NewEvent eventId.\n       * @member {Uint8Array} eventId\n       * @memberof eventstore.proto.NewEvent\n       * @instance\n       */\n      NewEvent.prototype.eventId = $util.newBuffer([])\n\n      /**\n       * NewEvent eventType.\n       * @member {string} eventType\n       * @memberof eventstore.proto.NewEvent\n       * @instance\n       */\n      NewEvent.prototype.eventType = ''\n\n      /**\n       * NewEvent dataContentType.\n       * @member {number} dataContentType\n       * @memberof eventstore.proto.NewEvent\n       * @instance\n       */\n      NewEvent.prototype.dataContentType = 0\n\n      /**\n       * NewEvent metadataContentType.\n       * @member {number} metadataContentType\n       * @memberof eventstore.proto.NewEvent\n       * @instance\n       */\n      NewEvent.prototype.metadataContentType = 0\n\n      /**\n       * NewEvent data.\n       * @member {Uint8Array} data\n       * @memberof eventstore.proto.NewEvent\n       * @instance\n       */\n      NewEvent.prototype.data = $util.newBuffer([])\n\n      /**\n       * NewEvent metadata.\n       * @member {Uint8Array} metadata\n       * @memberof eventstore.proto.NewEvent\n       * @instance\n       */\n      NewEvent.prototype.metadata = $util.newBuffer([])\n\n      /**\n       * Creates a new NewEvent instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.NewEvent\n       * @static\n       * @param {eventstore.proto.INewEvent=} [properties] Properties to set\n       * @returns {eventstore.proto.NewEvent} NewEvent instance\n       */\n      NewEvent.create = function create(properties) {\n        return new NewEvent(properties)\n      }\n\n      /**\n       * Encodes the specified NewEvent message. Does not implicitly {@link eventstore.proto.NewEvent.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.NewEvent\n       * @static\n       * @param {eventstore.proto.INewEvent} message NewEvent message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      NewEvent.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.eventId)\n        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.eventType)\n        writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.dataContentType)\n        writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.metadataContentType)\n        writer.uint32(/* id 5, wireType 2 =*/ 42).bytes(message.data)\n        if (message.metadata != null && message.hasOwnProperty('metadata'))\n          writer.uint32(/* id 6, wireType 2 =*/ 50).bytes(message.metadata)\n        return writer\n      }\n\n      /**\n       * Encodes the specified NewEvent message, length delimited. Does not implicitly {@link eventstore.proto.NewEvent.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.NewEvent\n       * @static\n       * @param {eventstore.proto.INewEvent} message NewEvent message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      NewEvent.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes a NewEvent message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.NewEvent\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.NewEvent} NewEvent\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      NewEvent.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.NewEvent()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              message.eventId = reader.bytes()\n              break\n            case 2:\n              message.eventType = reader.string()\n              break\n            case 3:\n              message.dataContentType = reader.int32()\n              break\n            case 4:\n              message.metadataContentType = reader.int32()\n              break\n            case 5:\n              message.data = reader.bytes()\n              break\n            case 6:\n              message.metadata = reader.bytes()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        if (!message.hasOwnProperty('eventId'))\n          throw $util.ProtocolError(\"missing required 'eventId'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('eventType'))\n          throw $util.ProtocolError(\"missing required 'eventType'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('dataContentType'))\n          throw $util.ProtocolError(\"missing required 'dataContentType'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('metadataContentType'))\n          throw $util.ProtocolError(\"missing required 'metadataContentType'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('data'))\n          throw $util.ProtocolError(\"missing required 'data'\", {\n            instance: message\n          })\n        return message\n      }\n\n      /**\n       * Decodes a NewEvent message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.NewEvent\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.NewEvent} NewEvent\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      NewEvent.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies a NewEvent message.\n       * @function verify\n       * @memberof eventstore.proto.NewEvent\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      NewEvent.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        if (\n          !(\n            (message.eventId && typeof message.eventId.length === 'number') ||\n            $util.isString(message.eventId)\n          )\n        )\n          return 'eventId: buffer expected'\n        if (!$util.isString(message.eventType)) return 'eventType: string expected'\n        if (!$util.isInteger(message.dataContentType)) return 'dataContentType: integer expected'\n        if (!$util.isInteger(message.metadataContentType))\n          return 'metadataContentType: integer expected'\n        if (\n          !(\n            (message.data && typeof message.data.length === 'number') ||\n            $util.isString(message.data)\n          )\n        )\n          return 'data: buffer expected'\n        if (message.metadata != null && message.hasOwnProperty('metadata'))\n          if (\n            !(\n              (message.metadata && typeof message.metadata.length === 'number') ||\n              $util.isString(message.metadata)\n            )\n          )\n            return 'metadata: buffer expected'\n        return null\n      }\n\n      /**\n       * Creates a NewEvent message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.NewEvent\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.NewEvent} NewEvent\n       */\n      NewEvent.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.NewEvent) return object\n        var message = new $root.eventstore.proto.NewEvent()\n        if (object.eventId != null)\n          if (typeof object.eventId === 'string')\n            $util.base64.decode(\n              object.eventId,\n              (message.eventId = $util.newBuffer($util.base64.length(object.eventId))),\n              0\n            )\n          else if (object.eventId.length) message.eventId = object.eventId\n        if (object.eventType != null) message.eventType = String(object.eventType)\n        if (object.dataContentType != null) message.dataContentType = object.dataContentType | 0\n        if (object.metadataContentType != null)\n          message.metadataContentType = object.metadataContentType | 0\n        if (object.data != null)\n          if (typeof object.data === 'string')\n            $util.base64.decode(\n              object.data,\n              (message.data = $util.newBuffer($util.base64.length(object.data))),\n              0\n            )\n          else if (object.data.length) message.data = object.data\n        if (object.metadata != null)\n          if (typeof object.metadata === 'string')\n            $util.base64.decode(\n              object.metadata,\n              (message.metadata = $util.newBuffer($util.base64.length(object.metadata))),\n              0\n            )\n          else if (object.metadata.length) message.metadata = object.metadata\n        return message\n      }\n\n      /**\n       * Creates a plain object from a NewEvent message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.NewEvent\n       * @static\n       * @param {eventstore.proto.NewEvent} message NewEvent\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      NewEvent.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.defaults) {\n          if (options.bytes === String) object.eventId = ''\n          else {\n            object.eventId = []\n            if (options.bytes !== Array) object.eventId = $util.newBuffer(object.eventId)\n          }\n          object.eventType = ''\n          object.dataContentType = 0\n          object.metadataContentType = 0\n          if (options.bytes === String) object.data = ''\n          else {\n            object.data = []\n            if (options.bytes !== Array) object.data = $util.newBuffer(object.data)\n          }\n          if (options.bytes === String) object.metadata = ''\n          else {\n            object.metadata = []\n            if (options.bytes !== Array) object.metadata = $util.newBuffer(object.metadata)\n          }\n        }\n        if (message.eventId != null && message.hasOwnProperty('eventId'))\n          object.eventId =\n            options.bytes === String\n              ? $util.base64.encode(message.eventId, 0, message.eventId.length)\n              : options.bytes === Array\n              ? Array.prototype.slice.call(message.eventId)\n              : message.eventId\n        if (message.eventType != null && message.hasOwnProperty('eventType'))\n          object.eventType = message.eventType\n        if (message.dataContentType != null && message.hasOwnProperty('dataContentType'))\n          object.dataContentType = message.dataContentType\n        if (message.metadataContentType != null && message.hasOwnProperty('metadataContentType'))\n          object.metadataContentType = message.metadataContentType\n        if (message.data != null && message.hasOwnProperty('data'))\n          object.data =\n            options.bytes === String\n              ? $util.base64.encode(message.data, 0, message.data.length)\n              : options.bytes === Array\n              ? Array.prototype.slice.call(message.data)\n              : message.data\n        if (message.metadata != null && message.hasOwnProperty('metadata'))\n          object.metadata =\n            options.bytes === String\n              ? $util.base64.encode(message.metadata, 0, message.metadata.length)\n              : options.bytes === Array\n              ? Array.prototype.slice.call(message.metadata)\n              : message.metadata\n        return object\n      }\n\n      /**\n       * Converts this NewEvent to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.NewEvent\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      NewEvent.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      return NewEvent\n    })()\n\n    proto.EventRecord = (function() {\n      /**\n       * Properties of an EventRecord.\n       * @memberof eventstore.proto\n       * @interface IEventRecord\n       * @property {string} eventStreamId EventRecord eventStreamId\n       * @property {number|Long} eventNumber EventRecord eventNumber\n       * @property {Uint8Array} eventId EventRecord eventId\n       * @property {string} eventType EventRecord eventType\n       * @property {number} dataContentType EventRecord dataContentType\n       * @property {number} metadataContentType EventRecord metadataContentType\n       * @property {Uint8Array} data EventRecord data\n       * @property {Uint8Array|null} [metadata] EventRecord metadata\n       * @property {number|Long|null} [created] EventRecord created\n       * @property {number|Long|null} [createdEpoch] EventRecord createdEpoch\n       */\n\n      /**\n       * Constructs a new EventRecord.\n       * @memberof eventstore.proto\n       * @classdesc Represents an EventRecord.\n       * @implements IEventRecord\n       * @constructor\n       * @param {eventstore.proto.IEventRecord=} [properties] Properties to set\n       */\n      function EventRecord(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * EventRecord eventStreamId.\n       * @member {string} eventStreamId\n       * @memberof eventstore.proto.EventRecord\n       * @instance\n       */\n      EventRecord.prototype.eventStreamId = ''\n\n      /**\n       * EventRecord eventNumber.\n       * @member {number|Long} eventNumber\n       * @memberof eventstore.proto.EventRecord\n       * @instance\n       */\n      EventRecord.prototype.eventNumber = $util.Long ? $util.Long.fromBits(0, 0, false) : 0\n\n      /**\n       * EventRecord eventId.\n       * @member {Uint8Array} eventId\n       * @memberof eventstore.proto.EventRecord\n       * @instance\n       */\n      EventRecord.prototype.eventId = $util.newBuffer([])\n\n      /**\n       * EventRecord eventType.\n       * @member {string} eventType\n       * @memberof eventstore.proto.EventRecord\n       * @instance\n       */\n      EventRecord.prototype.eventType = ''\n\n      /**\n       * EventRecord dataContentType.\n       * @member {number} dataContentType\n       * @memberof eventstore.proto.EventRecord\n       * @instance\n       */\n      EventRecord.prototype.dataContentType = 0\n\n      /**\n       * EventRecord metadataContentType.\n       * @member {number} metadataContentType\n       * @memberof eventstore.proto.EventRecord\n       * @instance\n       */\n      EventRecord.prototype.metadataContentType = 0\n\n      /**\n       * EventRecord data.\n       * @member {Uint8Array} data\n       * @memberof eventstore.proto.EventRecord\n       * @instance\n       */\n      EventRecord.prototype.data = $util.newBuffer([])\n\n      /**\n       * EventRecord metadata.\n       * @member {Uint8Array} metadata\n       * @memberof eventstore.proto.EventRecord\n       * @instance\n       */\n      EventRecord.prototype.metadata = $util.newBuffer([])\n\n      /**\n       * EventRecord created.\n       * @member {number|Long} created\n       * @memberof eventstore.proto.EventRecord\n       * @instance\n       */\n      EventRecord.prototype.created = $util.Long ? $util.Long.fromBits(0, 0, false) : 0\n\n      /**\n       * EventRecord createdEpoch.\n       * @member {number|Long} createdEpoch\n       * @memberof eventstore.proto.EventRecord\n       * @instance\n       */\n      EventRecord.prototype.createdEpoch = $util.Long ? $util.Long.fromBits(0, 0, false) : 0\n\n      /**\n       * Creates a new EventRecord instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.EventRecord\n       * @static\n       * @param {eventstore.proto.IEventRecord=} [properties] Properties to set\n       * @returns {eventstore.proto.EventRecord} EventRecord instance\n       */\n      EventRecord.create = function create(properties) {\n        return new EventRecord(properties)\n      }\n\n      /**\n       * Encodes the specified EventRecord message. Does not implicitly {@link eventstore.proto.EventRecord.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.EventRecord\n       * @static\n       * @param {eventstore.proto.IEventRecord} message EventRecord message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      EventRecord.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.eventStreamId)\n        writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.eventNumber)\n        writer.uint32(/* id 3, wireType 2 =*/ 26).bytes(message.eventId)\n        writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.eventType)\n        writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.dataContentType)\n        writer.uint32(/* id 6, wireType 0 =*/ 48).int32(message.metadataContentType)\n        writer.uint32(/* id 7, wireType 2 =*/ 58).bytes(message.data)\n        if (message.metadata != null && message.hasOwnProperty('metadata'))\n          writer.uint32(/* id 8, wireType 2 =*/ 66).bytes(message.metadata)\n        if (message.created != null && message.hasOwnProperty('created'))\n          writer.uint32(/* id 9, wireType 0 =*/ 72).int64(message.created)\n        if (message.createdEpoch != null && message.hasOwnProperty('createdEpoch'))\n          writer.uint32(/* id 10, wireType 0 =*/ 80).int64(message.createdEpoch)\n        return writer\n      }\n\n      /**\n       * Encodes the specified EventRecord message, length delimited. Does not implicitly {@link eventstore.proto.EventRecord.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.EventRecord\n       * @static\n       * @param {eventstore.proto.IEventRecord} message EventRecord message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      EventRecord.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes an EventRecord message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.EventRecord\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.EventRecord} EventRecord\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      EventRecord.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.EventRecord()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              message.eventStreamId = reader.string()\n              break\n            case 2:\n              message.eventNumber = reader.int64()\n              break\n            case 3:\n              message.eventId = reader.bytes()\n              break\n            case 4:\n              message.eventType = reader.string()\n              break\n            case 5:\n              message.dataContentType = reader.int32()\n              break\n            case 6:\n              message.metadataContentType = reader.int32()\n              break\n            case 7:\n              message.data = reader.bytes()\n              break\n            case 8:\n              message.metadata = reader.bytes()\n              break\n            case 9:\n              message.created = reader.int64()\n              break\n            case 10:\n              message.createdEpoch = reader.int64()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        if (!message.hasOwnProperty('eventStreamId'))\n          throw $util.ProtocolError(\"missing required 'eventStreamId'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('eventNumber'))\n          throw $util.ProtocolError(\"missing required 'eventNumber'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('eventId'))\n          throw $util.ProtocolError(\"missing required 'eventId'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('eventType'))\n          throw $util.ProtocolError(\"missing required 'eventType'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('dataContentType'))\n          throw $util.ProtocolError(\"missing required 'dataContentType'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('metadataContentType'))\n          throw $util.ProtocolError(\"missing required 'metadataContentType'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('data'))\n          throw $util.ProtocolError(\"missing required 'data'\", {\n            instance: message\n          })\n        return message\n      }\n\n      /**\n       * Decodes an EventRecord message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.EventRecord\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.EventRecord} EventRecord\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      EventRecord.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies an EventRecord message.\n       * @function verify\n       * @memberof eventstore.proto.EventRecord\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      EventRecord.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        if (!$util.isString(message.eventStreamId)) return 'eventStreamId: string expected'\n        if (\n          !$util.isInteger(message.eventNumber) &&\n          !(\n            message.eventNumber &&\n            $util.isInteger(message.eventNumber.low) &&\n            $util.isInteger(message.eventNumber.high)\n          )\n        )\n          return 'eventNumber: integer|Long expected'\n        if (\n          !(\n            (message.eventId && typeof message.eventId.length === 'number') ||\n            $util.isString(message.eventId)\n          )\n        )\n          return 'eventId: buffer expected'\n        if (!$util.isString(message.eventType)) return 'eventType: string expected'\n        if (!$util.isInteger(message.dataContentType)) return 'dataContentType: integer expected'\n        if (!$util.isInteger(message.metadataContentType))\n          return 'metadataContentType: integer expected'\n        if (\n          !(\n            (message.data && typeof message.data.length === 'number') ||\n            $util.isString(message.data)\n          )\n        )\n          return 'data: buffer expected'\n        if (message.metadata != null && message.hasOwnProperty('metadata'))\n          if (\n            !(\n              (message.metadata && typeof message.metadata.length === 'number') ||\n              $util.isString(message.metadata)\n            )\n          )\n            return 'metadata: buffer expected'\n        if (message.created != null && message.hasOwnProperty('created'))\n          if (\n            !$util.isInteger(message.created) &&\n            !(\n              message.created &&\n              $util.isInteger(message.created.low) &&\n              $util.isInteger(message.created.high)\n            )\n          )\n            return 'created: integer|Long expected'\n        if (message.createdEpoch != null && message.hasOwnProperty('createdEpoch'))\n          if (\n            !$util.isInteger(message.createdEpoch) &&\n            !(\n              message.createdEpoch &&\n              $util.isInteger(message.createdEpoch.low) &&\n              $util.isInteger(message.createdEpoch.high)\n            )\n          )\n            return 'createdEpoch: integer|Long expected'\n        return null\n      }\n\n      /**\n       * Creates an EventRecord message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.EventRecord\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.EventRecord} EventRecord\n       */\n      EventRecord.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.EventRecord) return object\n        var message = new $root.eventstore.proto.EventRecord()\n        if (object.eventStreamId != null) message.eventStreamId = String(object.eventStreamId)\n        if (object.eventNumber != null)\n          if ($util.Long)\n            (message.eventNumber = $util.Long.fromValue(object.eventNumber)).unsigned = false\n          else if (typeof object.eventNumber === 'string')\n            message.eventNumber = parseInt(object.eventNumber, 10)\n          else if (typeof object.eventNumber === 'number') message.eventNumber = object.eventNumber\n          else if (typeof object.eventNumber === 'object')\n            message.eventNumber = new $util.LongBits(\n              object.eventNumber.low >>> 0,\n              object.eventNumber.high >>> 0\n            ).toNumber()\n        if (object.eventId != null)\n          if (typeof object.eventId === 'string')\n            $util.base64.decode(\n              object.eventId,\n              (message.eventId = $util.newBuffer($util.base64.length(object.eventId))),\n              0\n            )\n          else if (object.eventId.length) message.eventId = object.eventId\n        if (object.eventType != null) message.eventType = String(object.eventType)\n        if (object.dataContentType != null) message.dataContentType = object.dataContentType | 0\n        if (object.metadataContentType != null)\n          message.metadataContentType = object.metadataContentType | 0\n        if (object.data != null)\n          if (typeof object.data === 'string')\n            $util.base64.decode(\n              object.data,\n              (message.data = $util.newBuffer($util.base64.length(object.data))),\n              0\n            )\n          else if (object.data.length) message.data = object.data\n        if (object.metadata != null)\n          if (typeof object.metadata === 'string')\n            $util.base64.decode(\n              object.metadata,\n              (message.metadata = $util.newBuffer($util.base64.length(object.metadata))),\n              0\n            )\n          else if (object.metadata.length) message.metadata = object.metadata\n        if (object.created != null)\n          if ($util.Long) (message.created = $util.Long.fromValue(object.created)).unsigned = false\n          else if (typeof object.created === 'string')\n            message.created = parseInt(object.created, 10)\n          else if (typeof object.created === 'number') message.created = object.created\n          else if (typeof object.created === 'object')\n            message.created = new $util.LongBits(\n              object.created.low >>> 0,\n              object.created.high >>> 0\n            ).toNumber()\n        if (object.createdEpoch != null)\n          if ($util.Long)\n            (message.createdEpoch = $util.Long.fromValue(object.createdEpoch)).unsigned = false\n          else if (typeof object.createdEpoch === 'string')\n            message.createdEpoch = parseInt(object.createdEpoch, 10)\n          else if (typeof object.createdEpoch === 'number')\n            message.createdEpoch = object.createdEpoch\n          else if (typeof object.createdEpoch === 'object')\n            message.createdEpoch = new $util.LongBits(\n              object.createdEpoch.low >>> 0,\n              object.createdEpoch.high >>> 0\n            ).toNumber()\n        return message\n      }\n\n      /**\n       * Creates a plain object from an EventRecord message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.EventRecord\n       * @static\n       * @param {eventstore.proto.EventRecord} message EventRecord\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      EventRecord.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.defaults) {\n          object.eventStreamId = ''\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.eventNumber =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.eventNumber = options.longs === String ? '0' : 0\n          if (options.bytes === String) object.eventId = ''\n          else {\n            object.eventId = []\n            if (options.bytes !== Array) object.eventId = $util.newBuffer(object.eventId)\n          }\n          object.eventType = ''\n          object.dataContentType = 0\n          object.metadataContentType = 0\n          if (options.bytes === String) object.data = ''\n          else {\n            object.data = []\n            if (options.bytes !== Array) object.data = $util.newBuffer(object.data)\n          }\n          if (options.bytes === String) object.metadata = ''\n          else {\n            object.metadata = []\n            if (options.bytes !== Array) object.metadata = $util.newBuffer(object.metadata)\n          }\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.created =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.created = options.longs === String ? '0' : 0\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.createdEpoch =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.createdEpoch = options.longs === String ? '0' : 0\n        }\n        if (message.eventStreamId != null && message.hasOwnProperty('eventStreamId'))\n          object.eventStreamId = message.eventStreamId\n        if (message.eventNumber != null && message.hasOwnProperty('eventNumber'))\n          if (typeof message.eventNumber === 'number')\n            object.eventNumber =\n              options.longs === String ? String(message.eventNumber) : message.eventNumber\n          else\n            object.eventNumber =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.eventNumber)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.eventNumber.low >>> 0,\n                    message.eventNumber.high >>> 0\n                  ).toNumber()\n                : message.eventNumber\n        if (message.eventId != null && message.hasOwnProperty('eventId'))\n          object.eventId =\n            options.bytes === String\n              ? $util.base64.encode(message.eventId, 0, message.eventId.length)\n              : options.bytes === Array\n              ? Array.prototype.slice.call(message.eventId)\n              : message.eventId\n        if (message.eventType != null && message.hasOwnProperty('eventType'))\n          object.eventType = message.eventType\n        if (message.dataContentType != null && message.hasOwnProperty('dataContentType'))\n          object.dataContentType = message.dataContentType\n        if (message.metadataContentType != null && message.hasOwnProperty('metadataContentType'))\n          object.metadataContentType = message.metadataContentType\n        if (message.data != null && message.hasOwnProperty('data'))\n          object.data =\n            options.bytes === String\n              ? $util.base64.encode(message.data, 0, message.data.length)\n              : options.bytes === Array\n              ? Array.prototype.slice.call(message.data)\n              : message.data\n        if (message.metadata != null && message.hasOwnProperty('metadata'))\n          object.metadata =\n            options.bytes === String\n              ? $util.base64.encode(message.metadata, 0, message.metadata.length)\n              : options.bytes === Array\n              ? Array.prototype.slice.call(message.metadata)\n              : message.metadata\n        if (message.created != null && message.hasOwnProperty('created'))\n          if (typeof message.created === 'number')\n            object.created = options.longs === String ? String(message.created) : message.created\n          else\n            object.created =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.created)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.created.low >>> 0,\n                    message.created.high >>> 0\n                  ).toNumber()\n                : message.created\n        if (message.createdEpoch != null && message.hasOwnProperty('createdEpoch'))\n          if (typeof message.createdEpoch === 'number')\n            object.createdEpoch =\n              options.longs === String ? String(message.createdEpoch) : message.createdEpoch\n          else\n            object.createdEpoch =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.createdEpoch)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.createdEpoch.low >>> 0,\n                    message.createdEpoch.high >>> 0\n                  ).toNumber()\n                : message.createdEpoch\n        return object\n      }\n\n      /**\n       * Converts this EventRecord to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.EventRecord\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      EventRecord.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      return EventRecord\n    })()\n\n    proto.ResolvedIndexedEvent = (function() {\n      /**\n       * Properties of a ResolvedIndexedEvent.\n       * @memberof eventstore.proto\n       * @interface IResolvedIndexedEvent\n       * @property {eventstore.proto.IEventRecord|null} [event] ResolvedIndexedEvent event\n       * @property {eventstore.proto.IEventRecord|null} [link] ResolvedIndexedEvent link\n       */\n\n      /**\n       * Constructs a new ResolvedIndexedEvent.\n       * @memberof eventstore.proto\n       * @classdesc Represents a ResolvedIndexedEvent.\n       * @implements IResolvedIndexedEvent\n       * @constructor\n       * @param {eventstore.proto.IResolvedIndexedEvent=} [properties] Properties to set\n       */\n      function ResolvedIndexedEvent(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * ResolvedIndexedEvent event.\n       * @member {eventstore.proto.IEventRecord|null|undefined} event\n       * @memberof eventstore.proto.ResolvedIndexedEvent\n       * @instance\n       */\n      ResolvedIndexedEvent.prototype.event = null\n\n      /**\n       * ResolvedIndexedEvent link.\n       * @member {eventstore.proto.IEventRecord|null|undefined} link\n       * @memberof eventstore.proto.ResolvedIndexedEvent\n       * @instance\n       */\n      ResolvedIndexedEvent.prototype.link = null\n\n      /**\n       * Creates a new ResolvedIndexedEvent instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.ResolvedIndexedEvent\n       * @static\n       * @param {eventstore.proto.IResolvedIndexedEvent=} [properties] Properties to set\n       * @returns {eventstore.proto.ResolvedIndexedEvent} ResolvedIndexedEvent instance\n       */\n      ResolvedIndexedEvent.create = function create(properties) {\n        return new ResolvedIndexedEvent(properties)\n      }\n\n      /**\n       * Encodes the specified ResolvedIndexedEvent message. Does not implicitly {@link eventstore.proto.ResolvedIndexedEvent.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.ResolvedIndexedEvent\n       * @static\n       * @param {eventstore.proto.IResolvedIndexedEvent} message ResolvedIndexedEvent message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      ResolvedIndexedEvent.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        if (message.event != null && message.hasOwnProperty('event'))\n          $root.eventstore.proto.EventRecord.encode(\n            message.event,\n            writer.uint32(/* id 1, wireType 2 =*/ 10).fork()\n          ).ldelim()\n        if (message.link != null && message.hasOwnProperty('link'))\n          $root.eventstore.proto.EventRecord.encode(\n            message.link,\n            writer.uint32(/* id 2, wireType 2 =*/ 18).fork()\n          ).ldelim()\n        return writer\n      }\n\n      /**\n       * Encodes the specified ResolvedIndexedEvent message, length delimited. Does not implicitly {@link eventstore.proto.ResolvedIndexedEvent.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.ResolvedIndexedEvent\n       * @static\n       * @param {eventstore.proto.IResolvedIndexedEvent} message ResolvedIndexedEvent message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      ResolvedIndexedEvent.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes a ResolvedIndexedEvent message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.ResolvedIndexedEvent\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.ResolvedIndexedEvent} ResolvedIndexedEvent\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      ResolvedIndexedEvent.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.ResolvedIndexedEvent()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              message.event = $root.eventstore.proto.EventRecord.decode(reader, reader.uint32())\n              break\n            case 2:\n              message.link = $root.eventstore.proto.EventRecord.decode(reader, reader.uint32())\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        return message\n      }\n\n      /**\n       * Decodes a ResolvedIndexedEvent message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.ResolvedIndexedEvent\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.ResolvedIndexedEvent} ResolvedIndexedEvent\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      ResolvedIndexedEvent.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies a ResolvedIndexedEvent message.\n       * @function verify\n       * @memberof eventstore.proto.ResolvedIndexedEvent\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      ResolvedIndexedEvent.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        if (message.event != null && message.hasOwnProperty('event')) {\n          var error = $root.eventstore.proto.EventRecord.verify(message.event)\n          if (error) return 'event.' + error\n        }\n        if (message.link != null && message.hasOwnProperty('link')) {\n          var error = $root.eventstore.proto.EventRecord.verify(message.link)\n          if (error) return 'link.' + error\n        }\n        return null\n      }\n\n      /**\n       * Creates a ResolvedIndexedEvent message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.ResolvedIndexedEvent\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.ResolvedIndexedEvent} ResolvedIndexedEvent\n       */\n      ResolvedIndexedEvent.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.ResolvedIndexedEvent) return object\n        var message = new $root.eventstore.proto.ResolvedIndexedEvent()\n        if (object.event != null) {\n          if (typeof object.event !== 'object')\n            throw TypeError('.eventstore.proto.ResolvedIndexedEvent.event: object expected')\n          message.event = $root.eventstore.proto.EventRecord.fromObject(object.event)\n        }\n        if (object.link != null) {\n          if (typeof object.link !== 'object')\n            throw TypeError('.eventstore.proto.ResolvedIndexedEvent.link: object expected')\n          message.link = $root.eventstore.proto.EventRecord.fromObject(object.link)\n        }\n        return message\n      }\n\n      /**\n       * Creates a plain object from a ResolvedIndexedEvent message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.ResolvedIndexedEvent\n       * @static\n       * @param {eventstore.proto.ResolvedIndexedEvent} message ResolvedIndexedEvent\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      ResolvedIndexedEvent.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.defaults) {\n          object.event = null\n          object.link = null\n        }\n        if (message.event != null && message.hasOwnProperty('event'))\n          object.event = $root.eventstore.proto.EventRecord.toObject(message.event, options)\n        if (message.link != null && message.hasOwnProperty('link'))\n          object.link = $root.eventstore.proto.EventRecord.toObject(message.link, options)\n        return object\n      }\n\n      /**\n       * Converts this ResolvedIndexedEvent to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.ResolvedIndexedEvent\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      ResolvedIndexedEvent.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      return ResolvedIndexedEvent\n    })()\n\n    proto.ResolvedEvent = (function() {\n      /**\n       * Properties of a ResolvedEvent.\n       * @memberof eventstore.proto\n       * @interface IResolvedEvent\n       * @property {eventstore.proto.IEventRecord|null} [event] ResolvedEvent event\n       * @property {eventstore.proto.IEventRecord|null} [link] ResolvedEvent link\n       * @property {number|Long} commitPosition ResolvedEvent commitPosition\n       * @property {number|Long} preparePosition ResolvedEvent preparePosition\n       */\n\n      /**\n       * Constructs a new ResolvedEvent.\n       * @memberof eventstore.proto\n       * @classdesc Represents a ResolvedEvent.\n       * @implements IResolvedEvent\n       * @constructor\n       * @param {eventstore.proto.IResolvedEvent=} [properties] Properties to set\n       */\n      function ResolvedEvent(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * ResolvedEvent event.\n       * @member {eventstore.proto.IEventRecord|null|undefined} event\n       * @memberof eventstore.proto.ResolvedEvent\n       * @instance\n       */\n      ResolvedEvent.prototype.event = null\n\n      /**\n       * ResolvedEvent link.\n       * @member {eventstore.proto.IEventRecord|null|undefined} link\n       * @memberof eventstore.proto.ResolvedEvent\n       * @instance\n       */\n      ResolvedEvent.prototype.link = null\n\n      /**\n       * ResolvedEvent commitPosition.\n       * @member {number|Long} commitPosition\n       * @memberof eventstore.proto.ResolvedEvent\n       * @instance\n       */\n      ResolvedEvent.prototype.commitPosition = $util.Long ? $util.Long.fromBits(0, 0, false) : 0\n\n      /**\n       * ResolvedEvent preparePosition.\n       * @member {number|Long} preparePosition\n       * @memberof eventstore.proto.ResolvedEvent\n       * @instance\n       */\n      ResolvedEvent.prototype.preparePosition = $util.Long ? $util.Long.fromBits(0, 0, false) : 0\n\n      /**\n       * Creates a new ResolvedEvent instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.ResolvedEvent\n       * @static\n       * @param {eventstore.proto.IResolvedEvent=} [properties] Properties to set\n       * @returns {eventstore.proto.ResolvedEvent} ResolvedEvent instance\n       */\n      ResolvedEvent.create = function create(properties) {\n        return new ResolvedEvent(properties)\n      }\n\n      /**\n       * Encodes the specified ResolvedEvent message. Does not implicitly {@link eventstore.proto.ResolvedEvent.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.ResolvedEvent\n       * @static\n       * @param {eventstore.proto.IResolvedEvent} message ResolvedEvent message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      ResolvedEvent.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        if (message.event != null && message.hasOwnProperty('event'))\n          $root.eventstore.proto.EventRecord.encode(\n            message.event,\n            writer.uint32(/* id 1, wireType 2 =*/ 10).fork()\n          ).ldelim()\n        if (message.link != null && message.hasOwnProperty('link'))\n          $root.eventstore.proto.EventRecord.encode(\n            message.link,\n            writer.uint32(/* id 2, wireType 2 =*/ 18).fork()\n          ).ldelim()\n        writer.uint32(/* id 3, wireType 0 =*/ 24).int64(message.commitPosition)\n        writer.uint32(/* id 4, wireType 0 =*/ 32).int64(message.preparePosition)\n        return writer\n      }\n\n      /**\n       * Encodes the specified ResolvedEvent message, length delimited. Does not implicitly {@link eventstore.proto.ResolvedEvent.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.ResolvedEvent\n       * @static\n       * @param {eventstore.proto.IResolvedEvent} message ResolvedEvent message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      ResolvedEvent.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes a ResolvedEvent message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.ResolvedEvent\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.ResolvedEvent} ResolvedEvent\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      ResolvedEvent.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.ResolvedEvent()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              message.event = $root.eventstore.proto.EventRecord.decode(reader, reader.uint32())\n              break\n            case 2:\n              message.link = $root.eventstore.proto.EventRecord.decode(reader, reader.uint32())\n              break\n            case 3:\n              message.commitPosition = reader.int64()\n              break\n            case 4:\n              message.preparePosition = reader.int64()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        if (!message.hasOwnProperty('commitPosition'))\n          throw $util.ProtocolError(\"missing required 'commitPosition'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('preparePosition'))\n          throw $util.ProtocolError(\"missing required 'preparePosition'\", {\n            instance: message\n          })\n        return message\n      }\n\n      /**\n       * Decodes a ResolvedEvent message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.ResolvedEvent\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.ResolvedEvent} ResolvedEvent\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      ResolvedEvent.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies a ResolvedEvent message.\n       * @function verify\n       * @memberof eventstore.proto.ResolvedEvent\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      ResolvedEvent.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        if (message.event != null && message.hasOwnProperty('event')) {\n          var error = $root.eventstore.proto.EventRecord.verify(message.event)\n          if (error) return 'event.' + error\n        }\n        if (message.link != null && message.hasOwnProperty('link')) {\n          var error = $root.eventstore.proto.EventRecord.verify(message.link)\n          if (error) return 'link.' + error\n        }\n        if (\n          !$util.isInteger(message.commitPosition) &&\n          !(\n            message.commitPosition &&\n            $util.isInteger(message.commitPosition.low) &&\n            $util.isInteger(message.commitPosition.high)\n          )\n        )\n          return 'commitPosition: integer|Long expected'\n        if (\n          !$util.isInteger(message.preparePosition) &&\n          !(\n            message.preparePosition &&\n            $util.isInteger(message.preparePosition.low) &&\n            $util.isInteger(message.preparePosition.high)\n          )\n        )\n          return 'preparePosition: integer|Long expected'\n        return null\n      }\n\n      /**\n       * Creates a ResolvedEvent message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.ResolvedEvent\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.ResolvedEvent} ResolvedEvent\n       */\n      ResolvedEvent.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.ResolvedEvent) return object\n        var message = new $root.eventstore.proto.ResolvedEvent()\n        if (object.event != null) {\n          if (typeof object.event !== 'object')\n            throw TypeError('.eventstore.proto.ResolvedEvent.event: object expected')\n          message.event = $root.eventstore.proto.EventRecord.fromObject(object.event)\n        }\n        if (object.link != null) {\n          if (typeof object.link !== 'object')\n            throw TypeError('.eventstore.proto.ResolvedEvent.link: object expected')\n          message.link = $root.eventstore.proto.EventRecord.fromObject(object.link)\n        }\n        if (object.commitPosition != null)\n          if ($util.Long)\n            (message.commitPosition = $util.Long.fromValue(object.commitPosition)).unsigned = false\n          else if (typeof object.commitPosition === 'string')\n            message.commitPosition = parseInt(object.commitPosition, 10)\n          else if (typeof object.commitPosition === 'number')\n            message.commitPosition = object.commitPosition\n          else if (typeof object.commitPosition === 'object')\n            message.commitPosition = new $util.LongBits(\n              object.commitPosition.low >>> 0,\n              object.commitPosition.high >>> 0\n            ).toNumber()\n        if (object.preparePosition != null)\n          if ($util.Long)\n            (message.preparePosition = $util.Long.fromValue(\n              object.preparePosition\n            )).unsigned = false\n          else if (typeof object.preparePosition === 'string')\n            message.preparePosition = parseInt(object.preparePosition, 10)\n          else if (typeof object.preparePosition === 'number')\n            message.preparePosition = object.preparePosition\n          else if (typeof object.preparePosition === 'object')\n            message.preparePosition = new $util.LongBits(\n              object.preparePosition.low >>> 0,\n              object.preparePosition.high >>> 0\n            ).toNumber()\n        return message\n      }\n\n      /**\n       * Creates a plain object from a ResolvedEvent message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.ResolvedEvent\n       * @static\n       * @param {eventstore.proto.ResolvedEvent} message ResolvedEvent\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      ResolvedEvent.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.defaults) {\n          object.event = null\n          object.link = null\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.commitPosition =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.commitPosition = options.longs === String ? '0' : 0\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.preparePosition =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.preparePosition = options.longs === String ? '0' : 0\n        }\n        if (message.event != null && message.hasOwnProperty('event'))\n          object.event = $root.eventstore.proto.EventRecord.toObject(message.event, options)\n        if (message.link != null && message.hasOwnProperty('link'))\n          object.link = $root.eventstore.proto.EventRecord.toObject(message.link, options)\n        if (message.commitPosition != null && message.hasOwnProperty('commitPosition'))\n          if (typeof message.commitPosition === 'number')\n            object.commitPosition =\n              options.longs === String ? String(message.commitPosition) : message.commitPosition\n          else\n            object.commitPosition =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.commitPosition)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.commitPosition.low >>> 0,\n                    message.commitPosition.high >>> 0\n                  ).toNumber()\n                : message.commitPosition\n        if (message.preparePosition != null && message.hasOwnProperty('preparePosition'))\n          if (typeof message.preparePosition === 'number')\n            object.preparePosition =\n              options.longs === String ? String(message.preparePosition) : message.preparePosition\n          else\n            object.preparePosition =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.preparePosition)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.preparePosition.low >>> 0,\n                    message.preparePosition.high >>> 0\n                  ).toNumber()\n                : message.preparePosition\n        return object\n      }\n\n      /**\n       * Converts this ResolvedEvent to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.ResolvedEvent\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      ResolvedEvent.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      return ResolvedEvent\n    })()\n\n    proto.WriteEvents = (function() {\n      /**\n       * Properties of a WriteEvents.\n       * @memberof eventstore.proto\n       * @interface IWriteEvents\n       * @property {string} eventStreamId WriteEvents eventStreamId\n       * @property {number|Long} expectedVersion WriteEvents expectedVersion\n       * @property {Array.<eventstore.proto.INewEvent>|null} [events] WriteEvents events\n       * @property {boolean} requireMaster WriteEvents requireMaster\n       */\n\n      /**\n       * Constructs a new WriteEvents.\n       * @memberof eventstore.proto\n       * @classdesc Represents a WriteEvents.\n       * @implements IWriteEvents\n       * @constructor\n       * @param {eventstore.proto.IWriteEvents=} [properties] Properties to set\n       */\n      function WriteEvents(properties) {\n        this.events = []\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * WriteEvents eventStreamId.\n       * @member {string} eventStreamId\n       * @memberof eventstore.proto.WriteEvents\n       * @instance\n       */\n      WriteEvents.prototype.eventStreamId = ''\n\n      /**\n       * WriteEvents expectedVersion.\n       * @member {number|Long} expectedVersion\n       * @memberof eventstore.proto.WriteEvents\n       * @instance\n       */\n      WriteEvents.prototype.expectedVersion = $util.Long ? $util.Long.fromBits(0, 0, false) : 0\n\n      /**\n       * WriteEvents events.\n       * @member {Array.<eventstore.proto.INewEvent>} events\n       * @memberof eventstore.proto.WriteEvents\n       * @instance\n       */\n      WriteEvents.prototype.events = $util.emptyArray\n\n      /**\n       * WriteEvents requireMaster.\n       * @member {boolean} requireMaster\n       * @memberof eventstore.proto.WriteEvents\n       * @instance\n       */\n      WriteEvents.prototype.requireMaster = false\n\n      /**\n       * Creates a new WriteEvents instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.WriteEvents\n       * @static\n       * @param {eventstore.proto.IWriteEvents=} [properties] Properties to set\n       * @returns {eventstore.proto.WriteEvents} WriteEvents instance\n       */\n      WriteEvents.create = function create(properties) {\n        return new WriteEvents(properties)\n      }\n\n      /**\n       * Encodes the specified WriteEvents message. Does not implicitly {@link eventstore.proto.WriteEvents.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.WriteEvents\n       * @static\n       * @param {eventstore.proto.IWriteEvents} message WriteEvents message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      WriteEvents.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.eventStreamId)\n        writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.expectedVersion)\n        if (message.events != null && message.events.length)\n          for (var i = 0; i < message.events.length; ++i)\n            $root.eventstore.proto.NewEvent.encode(\n              message.events[i],\n              writer.uint32(/* id 3, wireType 2 =*/ 26).fork()\n            ).ldelim()\n        writer.uint32(/* id 4, wireType 0 =*/ 32).bool(message.requireMaster)\n        return writer\n      }\n\n      /**\n       * Encodes the specified WriteEvents message, length delimited. Does not implicitly {@link eventstore.proto.WriteEvents.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.WriteEvents\n       * @static\n       * @param {eventstore.proto.IWriteEvents} message WriteEvents message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      WriteEvents.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes a WriteEvents message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.WriteEvents\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.WriteEvents} WriteEvents\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      WriteEvents.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.WriteEvents()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              message.eventStreamId = reader.string()\n              break\n            case 2:\n              message.expectedVersion = reader.int64()\n              break\n            case 3:\n              if (!(message.events && message.events.length)) message.events = []\n              message.events.push($root.eventstore.proto.NewEvent.decode(reader, reader.uint32()))\n              break\n            case 4:\n              message.requireMaster = reader.bool()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        if (!message.hasOwnProperty('eventStreamId'))\n          throw $util.ProtocolError(\"missing required 'eventStreamId'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('expectedVersion'))\n          throw $util.ProtocolError(\"missing required 'expectedVersion'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('requireMaster'))\n          throw $util.ProtocolError(\"missing required 'requireMaster'\", {\n            instance: message\n          })\n        return message\n      }\n\n      /**\n       * Decodes a WriteEvents message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.WriteEvents\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.WriteEvents} WriteEvents\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      WriteEvents.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies a WriteEvents message.\n       * @function verify\n       * @memberof eventstore.proto.WriteEvents\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      WriteEvents.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        if (!$util.isString(message.eventStreamId)) return 'eventStreamId: string expected'\n        if (\n          !$util.isInteger(message.expectedVersion) &&\n          !(\n            message.expectedVersion &&\n            $util.isInteger(message.expectedVersion.low) &&\n            $util.isInteger(message.expectedVersion.high)\n          )\n        )\n          return 'expectedVersion: integer|Long expected'\n        if (message.events != null && message.hasOwnProperty('events')) {\n          if (!Array.isArray(message.events)) return 'events: array expected'\n          for (var i = 0; i < message.events.length; ++i) {\n            var error = $root.eventstore.proto.NewEvent.verify(message.events[i])\n            if (error) return 'events.' + error\n          }\n        }\n        if (typeof message.requireMaster !== 'boolean') return 'requireMaster: boolean expected'\n        return null\n      }\n\n      /**\n       * Creates a WriteEvents message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.WriteEvents\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.WriteEvents} WriteEvents\n       */\n      WriteEvents.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.WriteEvents) return object\n        var message = new $root.eventstore.proto.WriteEvents()\n        if (object.eventStreamId != null) message.eventStreamId = String(object.eventStreamId)\n        if (object.expectedVersion != null)\n          if ($util.Long)\n            (message.expectedVersion = $util.Long.fromValue(\n              object.expectedVersion\n            )).unsigned = false\n          else if (typeof object.expectedVersion === 'string')\n            message.expectedVersion = parseInt(object.expectedVersion, 10)\n          else if (typeof object.expectedVersion === 'number')\n            message.expectedVersion = object.expectedVersion\n          else if (typeof object.expectedVersion === 'object')\n            message.expectedVersion = new $util.LongBits(\n              object.expectedVersion.low >>> 0,\n              object.expectedVersion.high >>> 0\n            ).toNumber()\n        if (object.events) {\n          if (!Array.isArray(object.events))\n            throw TypeError('.eventstore.proto.WriteEvents.events: array expected')\n          message.events = []\n          for (var i = 0; i < object.events.length; ++i) {\n            if (typeof object.events[i] !== 'object')\n              throw TypeError('.eventstore.proto.WriteEvents.events: object expected')\n            message.events[i] = $root.eventstore.proto.NewEvent.fromObject(object.events[i])\n          }\n        }\n        if (object.requireMaster != null) message.requireMaster = Boolean(object.requireMaster)\n        return message\n      }\n\n      /**\n       * Creates a plain object from a WriteEvents message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.WriteEvents\n       * @static\n       * @param {eventstore.proto.WriteEvents} message WriteEvents\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      WriteEvents.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.arrays || options.defaults) object.events = []\n        if (options.defaults) {\n          object.eventStreamId = ''\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.expectedVersion =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.expectedVersion = options.longs === String ? '0' : 0\n          object.requireMaster = false\n        }\n        if (message.eventStreamId != null && message.hasOwnProperty('eventStreamId'))\n          object.eventStreamId = message.eventStreamId\n        if (message.expectedVersion != null && message.hasOwnProperty('expectedVersion'))\n          if (typeof message.expectedVersion === 'number')\n            object.expectedVersion =\n              options.longs === String ? String(message.expectedVersion) : message.expectedVersion\n          else\n            object.expectedVersion =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.expectedVersion)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.expectedVersion.low >>> 0,\n                    message.expectedVersion.high >>> 0\n                  ).toNumber()\n                : message.expectedVersion\n        if (message.events && message.events.length) {\n          object.events = []\n          for (var j = 0; j < message.events.length; ++j)\n            object.events[j] = $root.eventstore.proto.NewEvent.toObject(message.events[j], options)\n        }\n        if (message.requireMaster != null && message.hasOwnProperty('requireMaster'))\n          object.requireMaster = message.requireMaster\n        return object\n      }\n\n      /**\n       * Converts this WriteEvents to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.WriteEvents\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      WriteEvents.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      return WriteEvents\n    })()\n\n    proto.WriteEventsCompleted = (function() {\n      /**\n       * Properties of a WriteEventsCompleted.\n       * @memberof eventstore.proto\n       * @interface IWriteEventsCompleted\n       * @property {eventstore.proto.OperationResult} result WriteEventsCompleted result\n       * @property {string|null} [message] WriteEventsCompleted message\n       * @property {number|Long} firstEventNumber WriteEventsCompleted firstEventNumber\n       * @property {number|Long} lastEventNumber WriteEventsCompleted lastEventNumber\n       * @property {number|Long|null} [preparePosition] WriteEventsCompleted preparePosition\n       * @property {number|Long|null} [commitPosition] WriteEventsCompleted commitPosition\n       */\n\n      /**\n       * Constructs a new WriteEventsCompleted.\n       * @memberof eventstore.proto\n       * @classdesc Represents a WriteEventsCompleted.\n       * @implements IWriteEventsCompleted\n       * @constructor\n       * @param {eventstore.proto.IWriteEventsCompleted=} [properties] Properties to set\n       */\n      function WriteEventsCompleted(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * WriteEventsCompleted result.\n       * @member {eventstore.proto.OperationResult} result\n       * @memberof eventstore.proto.WriteEventsCompleted\n       * @instance\n       */\n      WriteEventsCompleted.prototype.result = 0\n\n      /**\n       * WriteEventsCompleted message.\n       * @member {string} message\n       * @memberof eventstore.proto.WriteEventsCompleted\n       * @instance\n       */\n      WriteEventsCompleted.prototype.message = ''\n\n      /**\n       * WriteEventsCompleted firstEventNumber.\n       * @member {number|Long} firstEventNumber\n       * @memberof eventstore.proto.WriteEventsCompleted\n       * @instance\n       */\n      WriteEventsCompleted.prototype.firstEventNumber = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0\n\n      /**\n       * WriteEventsCompleted lastEventNumber.\n       * @member {number|Long} lastEventNumber\n       * @memberof eventstore.proto.WriteEventsCompleted\n       * @instance\n       */\n      WriteEventsCompleted.prototype.lastEventNumber = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0\n\n      /**\n       * WriteEventsCompleted preparePosition.\n       * @member {number|Long} preparePosition\n       * @memberof eventstore.proto.WriteEventsCompleted\n       * @instance\n       */\n      WriteEventsCompleted.prototype.preparePosition = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0\n\n      /**\n       * WriteEventsCompleted commitPosition.\n       * @member {number|Long} commitPosition\n       * @memberof eventstore.proto.WriteEventsCompleted\n       * @instance\n       */\n      WriteEventsCompleted.prototype.commitPosition = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0\n\n      /**\n       * Creates a new WriteEventsCompleted instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.WriteEventsCompleted\n       * @static\n       * @param {eventstore.proto.IWriteEventsCompleted=} [properties] Properties to set\n       * @returns {eventstore.proto.WriteEventsCompleted} WriteEventsCompleted instance\n       */\n      WriteEventsCompleted.create = function create(properties) {\n        return new WriteEventsCompleted(properties)\n      }\n\n      /**\n       * Encodes the specified WriteEventsCompleted message. Does not implicitly {@link eventstore.proto.WriteEventsCompleted.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.WriteEventsCompleted\n       * @static\n       * @param {eventstore.proto.IWriteEventsCompleted} message WriteEventsCompleted message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      WriteEventsCompleted.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.result)\n        if (message.message != null && message.hasOwnProperty('message'))\n          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.message)\n        writer.uint32(/* id 3, wireType 0 =*/ 24).int64(message.firstEventNumber)\n        writer.uint32(/* id 4, wireType 0 =*/ 32).int64(message.lastEventNumber)\n        if (message.preparePosition != null && message.hasOwnProperty('preparePosition'))\n          writer.uint32(/* id 5, wireType 0 =*/ 40).int64(message.preparePosition)\n        if (message.commitPosition != null && message.hasOwnProperty('commitPosition'))\n          writer.uint32(/* id 6, wireType 0 =*/ 48).int64(message.commitPosition)\n        return writer\n      }\n\n      /**\n       * Encodes the specified WriteEventsCompleted message, length delimited. Does not implicitly {@link eventstore.proto.WriteEventsCompleted.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.WriteEventsCompleted\n       * @static\n       * @param {eventstore.proto.IWriteEventsCompleted} message WriteEventsCompleted message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      WriteEventsCompleted.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes a WriteEventsCompleted message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.WriteEventsCompleted\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.WriteEventsCompleted} WriteEventsCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      WriteEventsCompleted.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.WriteEventsCompleted()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              message.result = reader.int32()\n              break\n            case 2:\n              message.message = reader.string()\n              break\n            case 3:\n              message.firstEventNumber = reader.int64()\n              break\n            case 4:\n              message.lastEventNumber = reader.int64()\n              break\n            case 5:\n              message.preparePosition = reader.int64()\n              break\n            case 6:\n              message.commitPosition = reader.int64()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        if (!message.hasOwnProperty('result'))\n          throw $util.ProtocolError(\"missing required 'result'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('firstEventNumber'))\n          throw $util.ProtocolError(\"missing required 'firstEventNumber'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('lastEventNumber'))\n          throw $util.ProtocolError(\"missing required 'lastEventNumber'\", {\n            instance: message\n          })\n        return message\n      }\n\n      /**\n       * Decodes a WriteEventsCompleted message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.WriteEventsCompleted\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.WriteEventsCompleted} WriteEventsCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      WriteEventsCompleted.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies a WriteEventsCompleted message.\n       * @function verify\n       * @memberof eventstore.proto.WriteEventsCompleted\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      WriteEventsCompleted.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        switch (message.result) {\n          default:\n            return 'result: enum value expected'\n          case 0:\n          case 1:\n          case 2:\n          case 3:\n          case 4:\n          case 5:\n          case 6:\n          case 7:\n            break\n        }\n        if (message.message != null && message.hasOwnProperty('message'))\n          if (!$util.isString(message.message)) return 'message: string expected'\n        if (\n          !$util.isInteger(message.firstEventNumber) &&\n          !(\n            message.firstEventNumber &&\n            $util.isInteger(message.firstEventNumber.low) &&\n            $util.isInteger(message.firstEventNumber.high)\n          )\n        )\n          return 'firstEventNumber: integer|Long expected'\n        if (\n          !$util.isInteger(message.lastEventNumber) &&\n          !(\n            message.lastEventNumber &&\n            $util.isInteger(message.lastEventNumber.low) &&\n            $util.isInteger(message.lastEventNumber.high)\n          )\n        )\n          return 'lastEventNumber: integer|Long expected'\n        if (message.preparePosition != null && message.hasOwnProperty('preparePosition'))\n          if (\n            !$util.isInteger(message.preparePosition) &&\n            !(\n              message.preparePosition &&\n              $util.isInteger(message.preparePosition.low) &&\n              $util.isInteger(message.preparePosition.high)\n            )\n          )\n            return 'preparePosition: integer|Long expected'\n        if (message.commitPosition != null && message.hasOwnProperty('commitPosition'))\n          if (\n            !$util.isInteger(message.commitPosition) &&\n            !(\n              message.commitPosition &&\n              $util.isInteger(message.commitPosition.low) &&\n              $util.isInteger(message.commitPosition.high)\n            )\n          )\n            return 'commitPosition: integer|Long expected'\n        return null\n      }\n\n      /**\n       * Creates a WriteEventsCompleted message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.WriteEventsCompleted\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.WriteEventsCompleted} WriteEventsCompleted\n       */\n      WriteEventsCompleted.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.WriteEventsCompleted) return object\n        var message = new $root.eventstore.proto.WriteEventsCompleted()\n        switch (object.result) {\n          case 'Success':\n          case 0:\n            message.result = 0\n            break\n          case 'PrepareTimeout':\n          case 1:\n            message.result = 1\n            break\n          case 'CommitTimeout':\n          case 2:\n            message.result = 2\n            break\n          case 'ForwardTimeout':\n          case 3:\n            message.result = 3\n            break\n          case 'WrongExpectedVersion':\n          case 4:\n            message.result = 4\n            break\n          case 'StreamDeleted':\n          case 5:\n            message.result = 5\n            break\n          case 'InvalidTransaction':\n          case 6:\n            message.result = 6\n            break\n          case 'AccessDenied':\n          case 7:\n            message.result = 7\n            break\n        }\n        if (object.message != null) message.message = String(object.message)\n        if (object.firstEventNumber != null)\n          if ($util.Long)\n            (message.firstEventNumber = $util.Long.fromValue(\n              object.firstEventNumber\n            )).unsigned = false\n          else if (typeof object.firstEventNumber === 'string')\n            message.firstEventNumber = parseInt(object.firstEventNumber, 10)\n          else if (typeof object.firstEventNumber === 'number')\n            message.firstEventNumber = object.firstEventNumber\n          else if (typeof object.firstEventNumber === 'object')\n            message.firstEventNumber = new $util.LongBits(\n              object.firstEventNumber.low >>> 0,\n              object.firstEventNumber.high >>> 0\n            ).toNumber()\n        if (object.lastEventNumber != null)\n          if ($util.Long)\n            (message.lastEventNumber = $util.Long.fromValue(\n              object.lastEventNumber\n            )).unsigned = false\n          else if (typeof object.lastEventNumber === 'string')\n            message.lastEventNumber = parseInt(object.lastEventNumber, 10)\n          else if (typeof object.lastEventNumber === 'number')\n            message.lastEventNumber = object.lastEventNumber\n          else if (typeof object.lastEventNumber === 'object')\n            message.lastEventNumber = new $util.LongBits(\n              object.lastEventNumber.low >>> 0,\n              object.lastEventNumber.high >>> 0\n            ).toNumber()\n        if (object.preparePosition != null)\n          if ($util.Long)\n            (message.preparePosition = $util.Long.fromValue(\n              object.preparePosition\n            )).unsigned = false\n          else if (typeof object.preparePosition === 'string')\n            message.preparePosition = parseInt(object.preparePosition, 10)\n          else if (typeof object.preparePosition === 'number')\n            message.preparePosition = object.preparePosition\n          else if (typeof object.preparePosition === 'object')\n            message.preparePosition = new $util.LongBits(\n              object.preparePosition.low >>> 0,\n              object.preparePosition.high >>> 0\n            ).toNumber()\n        if (object.commitPosition != null)\n          if ($util.Long)\n            (message.commitPosition = $util.Long.fromValue(object.commitPosition)).unsigned = false\n          else if (typeof object.commitPosition === 'string')\n            message.commitPosition = parseInt(object.commitPosition, 10)\n          else if (typeof object.commitPosition === 'number')\n            message.commitPosition = object.commitPosition\n          else if (typeof object.commitPosition === 'object')\n            message.commitPosition = new $util.LongBits(\n              object.commitPosition.low >>> 0,\n              object.commitPosition.high >>> 0\n            ).toNumber()\n        return message\n      }\n\n      /**\n       * Creates a plain object from a WriteEventsCompleted message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.WriteEventsCompleted\n       * @static\n       * @param {eventstore.proto.WriteEventsCompleted} message WriteEventsCompleted\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      WriteEventsCompleted.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.defaults) {\n          object.result = options.enums === String ? 'Success' : 0\n          object.message = ''\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.firstEventNumber =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.firstEventNumber = options.longs === String ? '0' : 0\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.lastEventNumber =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.lastEventNumber = options.longs === String ? '0' : 0\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.preparePosition =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.preparePosition = options.longs === String ? '0' : 0\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.commitPosition =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.commitPosition = options.longs === String ? '0' : 0\n        }\n        if (message.result != null && message.hasOwnProperty('result'))\n          object.result =\n            options.enums === String\n              ? $root.eventstore.proto.OperationResult[message.result]\n              : message.result\n        if (message.message != null && message.hasOwnProperty('message'))\n          object.message = message.message\n        if (message.firstEventNumber != null && message.hasOwnProperty('firstEventNumber'))\n          if (typeof message.firstEventNumber === 'number')\n            object.firstEventNumber =\n              options.longs === String ? String(message.firstEventNumber) : message.firstEventNumber\n          else\n            object.firstEventNumber =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.firstEventNumber)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.firstEventNumber.low >>> 0,\n                    message.firstEventNumber.high >>> 0\n                  ).toNumber()\n                : message.firstEventNumber\n        if (message.lastEventNumber != null && message.hasOwnProperty('lastEventNumber'))\n          if (typeof message.lastEventNumber === 'number')\n            object.lastEventNumber =\n              options.longs === String ? String(message.lastEventNumber) : message.lastEventNumber\n          else\n            object.lastEventNumber =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.lastEventNumber)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.lastEventNumber.low >>> 0,\n                    message.lastEventNumber.high >>> 0\n                  ).toNumber()\n                : message.lastEventNumber\n        if (message.preparePosition != null && message.hasOwnProperty('preparePosition'))\n          if (typeof message.preparePosition === 'number')\n            object.preparePosition =\n              options.longs === String ? String(message.preparePosition) : message.preparePosition\n          else\n            object.preparePosition =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.preparePosition)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.preparePosition.low >>> 0,\n                    message.preparePosition.high >>> 0\n                  ).toNumber()\n                : message.preparePosition\n        if (message.commitPosition != null && message.hasOwnProperty('commitPosition'))\n          if (typeof message.commitPosition === 'number')\n            object.commitPosition =\n              options.longs === String ? String(message.commitPosition) : message.commitPosition\n          else\n            object.commitPosition =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.commitPosition)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.commitPosition.low >>> 0,\n                    message.commitPosition.high >>> 0\n                  ).toNumber()\n                : message.commitPosition\n        return object\n      }\n\n      /**\n       * Converts this WriteEventsCompleted to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.WriteEventsCompleted\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      WriteEventsCompleted.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      return WriteEventsCompleted\n    })()\n\n    proto.DeleteStream = (function() {\n      /**\n       * Properties of a DeleteStream.\n       * @memberof eventstore.proto\n       * @interface IDeleteStream\n       * @property {string} eventStreamId DeleteStream eventStreamId\n       * @property {number|Long} expectedVersion DeleteStream expectedVersion\n       * @property {boolean} requireMaster DeleteStream requireMaster\n       * @property {boolean|null} [hardDelete] DeleteStream hardDelete\n       */\n\n      /**\n       * Constructs a new DeleteStream.\n       * @memberof eventstore.proto\n       * @classdesc Represents a DeleteStream.\n       * @implements IDeleteStream\n       * @constructor\n       * @param {eventstore.proto.IDeleteStream=} [properties] Properties to set\n       */\n      function DeleteStream(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * DeleteStream eventStreamId.\n       * @member {string} eventStreamId\n       * @memberof eventstore.proto.DeleteStream\n       * @instance\n       */\n      DeleteStream.prototype.eventStreamId = ''\n\n      /**\n       * DeleteStream expectedVersion.\n       * @member {number|Long} expectedVersion\n       * @memberof eventstore.proto.DeleteStream\n       * @instance\n       */\n      DeleteStream.prototype.expectedVersion = $util.Long ? $util.Long.fromBits(0, 0, false) : 0\n\n      /**\n       * DeleteStream requireMaster.\n       * @member {boolean} requireMaster\n       * @memberof eventstore.proto.DeleteStream\n       * @instance\n       */\n      DeleteStream.prototype.requireMaster = false\n\n      /**\n       * DeleteStream hardDelete.\n       * @member {boolean} hardDelete\n       * @memberof eventstore.proto.DeleteStream\n       * @instance\n       */\n      DeleteStream.prototype.hardDelete = false\n\n      /**\n       * Creates a new DeleteStream instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.DeleteStream\n       * @static\n       * @param {eventstore.proto.IDeleteStream=} [properties] Properties to set\n       * @returns {eventstore.proto.DeleteStream} DeleteStream instance\n       */\n      DeleteStream.create = function create(properties) {\n        return new DeleteStream(properties)\n      }\n\n      /**\n       * Encodes the specified DeleteStream message. Does not implicitly {@link eventstore.proto.DeleteStream.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.DeleteStream\n       * @static\n       * @param {eventstore.proto.IDeleteStream} message DeleteStream message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      DeleteStream.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.eventStreamId)\n        writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.expectedVersion)\n        writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.requireMaster)\n        if (message.hardDelete != null && message.hasOwnProperty('hardDelete'))\n          writer.uint32(/* id 4, wireType 0 =*/ 32).bool(message.hardDelete)\n        return writer\n      }\n\n      /**\n       * Encodes the specified DeleteStream message, length delimited. Does not implicitly {@link eventstore.proto.DeleteStream.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.DeleteStream\n       * @static\n       * @param {eventstore.proto.IDeleteStream} message DeleteStream message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      DeleteStream.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes a DeleteStream message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.DeleteStream\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.DeleteStream} DeleteStream\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      DeleteStream.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.DeleteStream()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              message.eventStreamId = reader.string()\n              break\n            case 2:\n              message.expectedVersion = reader.int64()\n              break\n            case 3:\n              message.requireMaster = reader.bool()\n              break\n            case 4:\n              message.hardDelete = reader.bool()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        if (!message.hasOwnProperty('eventStreamId'))\n          throw $util.ProtocolError(\"missing required 'eventStreamId'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('expectedVersion'))\n          throw $util.ProtocolError(\"missing required 'expectedVersion'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('requireMaster'))\n          throw $util.ProtocolError(\"missing required 'requireMaster'\", {\n            instance: message\n          })\n        return message\n      }\n\n      /**\n       * Decodes a DeleteStream message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.DeleteStream\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.DeleteStream} DeleteStream\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      DeleteStream.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies a DeleteStream message.\n       * @function verify\n       * @memberof eventstore.proto.DeleteStream\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      DeleteStream.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        if (!$util.isString(message.eventStreamId)) return 'eventStreamId: string expected'\n        if (\n          !$util.isInteger(message.expectedVersion) &&\n          !(\n            message.expectedVersion &&\n            $util.isInteger(message.expectedVersion.low) &&\n            $util.isInteger(message.expectedVersion.high)\n          )\n        )\n          return 'expectedVersion: integer|Long expected'\n        if (typeof message.requireMaster !== 'boolean') return 'requireMaster: boolean expected'\n        if (message.hardDelete != null && message.hasOwnProperty('hardDelete'))\n          if (typeof message.hardDelete !== 'boolean') return 'hardDelete: boolean expected'\n        return null\n      }\n\n      /**\n       * Creates a DeleteStream message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.DeleteStream\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.DeleteStream} DeleteStream\n       */\n      DeleteStream.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.DeleteStream) return object\n        var message = new $root.eventstore.proto.DeleteStream()\n        if (object.eventStreamId != null) message.eventStreamId = String(object.eventStreamId)\n        if (object.expectedVersion != null)\n          if ($util.Long)\n            (message.expectedVersion = $util.Long.fromValue(\n              object.expectedVersion\n            )).unsigned = false\n          else if (typeof object.expectedVersion === 'string')\n            message.expectedVersion = parseInt(object.expectedVersion, 10)\n          else if (typeof object.expectedVersion === 'number')\n            message.expectedVersion = object.expectedVersion\n          else if (typeof object.expectedVersion === 'object')\n            message.expectedVersion = new $util.LongBits(\n              object.expectedVersion.low >>> 0,\n              object.expectedVersion.high >>> 0\n            ).toNumber()\n        if (object.requireMaster != null) message.requireMaster = Boolean(object.requireMaster)\n        if (object.hardDelete != null) message.hardDelete = Boolean(object.hardDelete)\n        return message\n      }\n\n      /**\n       * Creates a plain object from a DeleteStream message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.DeleteStream\n       * @static\n       * @param {eventstore.proto.DeleteStream} message DeleteStream\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      DeleteStream.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.defaults) {\n          object.eventStreamId = ''\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.expectedVersion =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.expectedVersion = options.longs === String ? '0' : 0\n          object.requireMaster = false\n          object.hardDelete = false\n        }\n        if (message.eventStreamId != null && message.hasOwnProperty('eventStreamId'))\n          object.eventStreamId = message.eventStreamId\n        if (message.expectedVersion != null && message.hasOwnProperty('expectedVersion'))\n          if (typeof message.expectedVersion === 'number')\n            object.expectedVersion =\n              options.longs === String ? String(message.expectedVersion) : message.expectedVersion\n          else\n            object.expectedVersion =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.expectedVersion)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.expectedVersion.low >>> 0,\n                    message.expectedVersion.high >>> 0\n                  ).toNumber()\n                : message.expectedVersion\n        if (message.requireMaster != null && message.hasOwnProperty('requireMaster'))\n          object.requireMaster = message.requireMaster\n        if (message.hardDelete != null && message.hasOwnProperty('hardDelete'))\n          object.hardDelete = message.hardDelete\n        return object\n      }\n\n      /**\n       * Converts this DeleteStream to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.DeleteStream\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      DeleteStream.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      return DeleteStream\n    })()\n\n    proto.DeleteStreamCompleted = (function() {\n      /**\n       * Properties of a DeleteStreamCompleted.\n       * @memberof eventstore.proto\n       * @interface IDeleteStreamCompleted\n       * @property {eventstore.proto.OperationResult} result DeleteStreamCompleted result\n       * @property {string|null} [message] DeleteStreamCompleted message\n       * @property {number|Long|null} [preparePosition] DeleteStreamCompleted preparePosition\n       * @property {number|Long|null} [commitPosition] DeleteStreamCompleted commitPosition\n       */\n\n      /**\n       * Constructs a new DeleteStreamCompleted.\n       * @memberof eventstore.proto\n       * @classdesc Represents a DeleteStreamCompleted.\n       * @implements IDeleteStreamCompleted\n       * @constructor\n       * @param {eventstore.proto.IDeleteStreamCompleted=} [properties] Properties to set\n       */\n      function DeleteStreamCompleted(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * DeleteStreamCompleted result.\n       * @member {eventstore.proto.OperationResult} result\n       * @memberof eventstore.proto.DeleteStreamCompleted\n       * @instance\n       */\n      DeleteStreamCompleted.prototype.result = 0\n\n      /**\n       * DeleteStreamCompleted message.\n       * @member {string} message\n       * @memberof eventstore.proto.DeleteStreamCompleted\n       * @instance\n       */\n      DeleteStreamCompleted.prototype.message = ''\n\n      /**\n       * DeleteStreamCompleted preparePosition.\n       * @member {number|Long} preparePosition\n       * @memberof eventstore.proto.DeleteStreamCompleted\n       * @instance\n       */\n      DeleteStreamCompleted.prototype.preparePosition = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0\n\n      /**\n       * DeleteStreamCompleted commitPosition.\n       * @member {number|Long} commitPosition\n       * @memberof eventstore.proto.DeleteStreamCompleted\n       * @instance\n       */\n      DeleteStreamCompleted.prototype.commitPosition = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0\n\n      /**\n       * Creates a new DeleteStreamCompleted instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.DeleteStreamCompleted\n       * @static\n       * @param {eventstore.proto.IDeleteStreamCompleted=} [properties] Properties to set\n       * @returns {eventstore.proto.DeleteStreamCompleted} DeleteStreamCompleted instance\n       */\n      DeleteStreamCompleted.create = function create(properties) {\n        return new DeleteStreamCompleted(properties)\n      }\n\n      /**\n       * Encodes the specified DeleteStreamCompleted message. Does not implicitly {@link eventstore.proto.DeleteStreamCompleted.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.DeleteStreamCompleted\n       * @static\n       * @param {eventstore.proto.IDeleteStreamCompleted} message DeleteStreamCompleted message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      DeleteStreamCompleted.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.result)\n        if (message.message != null && message.hasOwnProperty('message'))\n          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.message)\n        if (message.preparePosition != null && message.hasOwnProperty('preparePosition'))\n          writer.uint32(/* id 3, wireType 0 =*/ 24).int64(message.preparePosition)\n        if (message.commitPosition != null && message.hasOwnProperty('commitPosition'))\n          writer.uint32(/* id 4, wireType 0 =*/ 32).int64(message.commitPosition)\n        return writer\n      }\n\n      /**\n       * Encodes the specified DeleteStreamCompleted message, length delimited. Does not implicitly {@link eventstore.proto.DeleteStreamCompleted.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.DeleteStreamCompleted\n       * @static\n       * @param {eventstore.proto.IDeleteStreamCompleted} message DeleteStreamCompleted message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      DeleteStreamCompleted.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes a DeleteStreamCompleted message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.DeleteStreamCompleted\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.DeleteStreamCompleted} DeleteStreamCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      DeleteStreamCompleted.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.DeleteStreamCompleted()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              message.result = reader.int32()\n              break\n            case 2:\n              message.message = reader.string()\n              break\n            case 3:\n              message.preparePosition = reader.int64()\n              break\n            case 4:\n              message.commitPosition = reader.int64()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        if (!message.hasOwnProperty('result'))\n          throw $util.ProtocolError(\"missing required 'result'\", {\n            instance: message\n          })\n        return message\n      }\n\n      /**\n       * Decodes a DeleteStreamCompleted message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.DeleteStreamCompleted\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.DeleteStreamCompleted} DeleteStreamCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      DeleteStreamCompleted.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies a DeleteStreamCompleted message.\n       * @function verify\n       * @memberof eventstore.proto.DeleteStreamCompleted\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      DeleteStreamCompleted.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        switch (message.result) {\n          default:\n            return 'result: enum value expected'\n          case 0:\n          case 1:\n          case 2:\n          case 3:\n          case 4:\n          case 5:\n          case 6:\n          case 7:\n            break\n        }\n        if (message.message != null && message.hasOwnProperty('message'))\n          if (!$util.isString(message.message)) return 'message: string expected'\n        if (message.preparePosition != null && message.hasOwnProperty('preparePosition'))\n          if (\n            !$util.isInteger(message.preparePosition) &&\n            !(\n              message.preparePosition &&\n              $util.isInteger(message.preparePosition.low) &&\n              $util.isInteger(message.preparePosition.high)\n            )\n          )\n            return 'preparePosition: integer|Long expected'\n        if (message.commitPosition != null && message.hasOwnProperty('commitPosition'))\n          if (\n            !$util.isInteger(message.commitPosition) &&\n            !(\n              message.commitPosition &&\n              $util.isInteger(message.commitPosition.low) &&\n              $util.isInteger(message.commitPosition.high)\n            )\n          )\n            return 'commitPosition: integer|Long expected'\n        return null\n      }\n\n      /**\n       * Creates a DeleteStreamCompleted message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.DeleteStreamCompleted\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.DeleteStreamCompleted} DeleteStreamCompleted\n       */\n      DeleteStreamCompleted.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.DeleteStreamCompleted) return object\n        var message = new $root.eventstore.proto.DeleteStreamCompleted()\n        switch (object.result) {\n          case 'Success':\n          case 0:\n            message.result = 0\n            break\n          case 'PrepareTimeout':\n          case 1:\n            message.result = 1\n            break\n          case 'CommitTimeout':\n          case 2:\n            message.result = 2\n            break\n          case 'ForwardTimeout':\n          case 3:\n            message.result = 3\n            break\n          case 'WrongExpectedVersion':\n          case 4:\n            message.result = 4\n            break\n          case 'StreamDeleted':\n          case 5:\n            message.result = 5\n            break\n          case 'InvalidTransaction':\n          case 6:\n            message.result = 6\n            break\n          case 'AccessDenied':\n          case 7:\n            message.result = 7\n            break\n        }\n        if (object.message != null) message.message = String(object.message)\n        if (object.preparePosition != null)\n          if ($util.Long)\n            (message.preparePosition = $util.Long.fromValue(\n              object.preparePosition\n            )).unsigned = false\n          else if (typeof object.preparePosition === 'string')\n            message.preparePosition = parseInt(object.preparePosition, 10)\n          else if (typeof object.preparePosition === 'number')\n            message.preparePosition = object.preparePosition\n          else if (typeof object.preparePosition === 'object')\n            message.preparePosition = new $util.LongBits(\n              object.preparePosition.low >>> 0,\n              object.preparePosition.high >>> 0\n            ).toNumber()\n        if (object.commitPosition != null)\n          if ($util.Long)\n            (message.commitPosition = $util.Long.fromValue(object.commitPosition)).unsigned = false\n          else if (typeof object.commitPosition === 'string')\n            message.commitPosition = parseInt(object.commitPosition, 10)\n          else if (typeof object.commitPosition === 'number')\n            message.commitPosition = object.commitPosition\n          else if (typeof object.commitPosition === 'object')\n            message.commitPosition = new $util.LongBits(\n              object.commitPosition.low >>> 0,\n              object.commitPosition.high >>> 0\n            ).toNumber()\n        return message\n      }\n\n      /**\n       * Creates a plain object from a DeleteStreamCompleted message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.DeleteStreamCompleted\n       * @static\n       * @param {eventstore.proto.DeleteStreamCompleted} message DeleteStreamCompleted\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      DeleteStreamCompleted.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.defaults) {\n          object.result = options.enums === String ? 'Success' : 0\n          object.message = ''\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.preparePosition =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.preparePosition = options.longs === String ? '0' : 0\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.commitPosition =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.commitPosition = options.longs === String ? '0' : 0\n        }\n        if (message.result != null && message.hasOwnProperty('result'))\n          object.result =\n            options.enums === String\n              ? $root.eventstore.proto.OperationResult[message.result]\n              : message.result\n        if (message.message != null && message.hasOwnProperty('message'))\n          object.message = message.message\n        if (message.preparePosition != null && message.hasOwnProperty('preparePosition'))\n          if (typeof message.preparePosition === 'number')\n            object.preparePosition =\n              options.longs === String ? String(message.preparePosition) : message.preparePosition\n          else\n            object.preparePosition =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.preparePosition)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.preparePosition.low >>> 0,\n                    message.preparePosition.high >>> 0\n                  ).toNumber()\n                : message.preparePosition\n        if (message.commitPosition != null && message.hasOwnProperty('commitPosition'))\n          if (typeof message.commitPosition === 'number')\n            object.commitPosition =\n              options.longs === String ? String(message.commitPosition) : message.commitPosition\n          else\n            object.commitPosition =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.commitPosition)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.commitPosition.low >>> 0,\n                    message.commitPosition.high >>> 0\n                  ).toNumber()\n                : message.commitPosition\n        return object\n      }\n\n      /**\n       * Converts this DeleteStreamCompleted to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.DeleteStreamCompleted\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      DeleteStreamCompleted.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      return DeleteStreamCompleted\n    })()\n\n    proto.TransactionStart = (function() {\n      /**\n       * Properties of a TransactionStart.\n       * @memberof eventstore.proto\n       * @interface ITransactionStart\n       * @property {string} eventStreamId TransactionStart eventStreamId\n       * @property {number|Long} expectedVersion TransactionStart expectedVersion\n       * @property {boolean} requireMaster TransactionStart requireMaster\n       */\n\n      /**\n       * Constructs a new TransactionStart.\n       * @memberof eventstore.proto\n       * @classdesc Represents a TransactionStart.\n       * @implements ITransactionStart\n       * @constructor\n       * @param {eventstore.proto.ITransactionStart=} [properties] Properties to set\n       */\n      function TransactionStart(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * TransactionStart eventStreamId.\n       * @member {string} eventStreamId\n       * @memberof eventstore.proto.TransactionStart\n       * @instance\n       */\n      TransactionStart.prototype.eventStreamId = ''\n\n      /**\n       * TransactionStart expectedVersion.\n       * @member {number|Long} expectedVersion\n       * @memberof eventstore.proto.TransactionStart\n       * @instance\n       */\n      TransactionStart.prototype.expectedVersion = $util.Long ? $util.Long.fromBits(0, 0, false) : 0\n\n      /**\n       * TransactionStart requireMaster.\n       * @member {boolean} requireMaster\n       * @memberof eventstore.proto.TransactionStart\n       * @instance\n       */\n      TransactionStart.prototype.requireMaster = false\n\n      /**\n       * Creates a new TransactionStart instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.TransactionStart\n       * @static\n       * @param {eventstore.proto.ITransactionStart=} [properties] Properties to set\n       * @returns {eventstore.proto.TransactionStart} TransactionStart instance\n       */\n      TransactionStart.create = function create(properties) {\n        return new TransactionStart(properties)\n      }\n\n      /**\n       * Encodes the specified TransactionStart message. Does not implicitly {@link eventstore.proto.TransactionStart.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.TransactionStart\n       * @static\n       * @param {eventstore.proto.ITransactionStart} message TransactionStart message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      TransactionStart.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.eventStreamId)\n        writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.expectedVersion)\n        writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.requireMaster)\n        return writer\n      }\n\n      /**\n       * Encodes the specified TransactionStart message, length delimited. Does not implicitly {@link eventstore.proto.TransactionStart.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.TransactionStart\n       * @static\n       * @param {eventstore.proto.ITransactionStart} message TransactionStart message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      TransactionStart.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes a TransactionStart message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.TransactionStart\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.TransactionStart} TransactionStart\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      TransactionStart.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.TransactionStart()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              message.eventStreamId = reader.string()\n              break\n            case 2:\n              message.expectedVersion = reader.int64()\n              break\n            case 3:\n              message.requireMaster = reader.bool()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        if (!message.hasOwnProperty('eventStreamId'))\n          throw $util.ProtocolError(\"missing required 'eventStreamId'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('expectedVersion'))\n          throw $util.ProtocolError(\"missing required 'expectedVersion'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('requireMaster'))\n          throw $util.ProtocolError(\"missing required 'requireMaster'\", {\n            instance: message\n          })\n        return message\n      }\n\n      /**\n       * Decodes a TransactionStart message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.TransactionStart\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.TransactionStart} TransactionStart\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      TransactionStart.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies a TransactionStart message.\n       * @function verify\n       * @memberof eventstore.proto.TransactionStart\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      TransactionStart.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        if (!$util.isString(message.eventStreamId)) return 'eventStreamId: string expected'\n        if (\n          !$util.isInteger(message.expectedVersion) &&\n          !(\n            message.expectedVersion &&\n            $util.isInteger(message.expectedVersion.low) &&\n            $util.isInteger(message.expectedVersion.high)\n          )\n        )\n          return 'expectedVersion: integer|Long expected'\n        if (typeof message.requireMaster !== 'boolean') return 'requireMaster: boolean expected'\n        return null\n      }\n\n      /**\n       * Creates a TransactionStart message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.TransactionStart\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.TransactionStart} TransactionStart\n       */\n      TransactionStart.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.TransactionStart) return object\n        var message = new $root.eventstore.proto.TransactionStart()\n        if (object.eventStreamId != null) message.eventStreamId = String(object.eventStreamId)\n        if (object.expectedVersion != null)\n          if ($util.Long)\n            (message.expectedVersion = $util.Long.fromValue(\n              object.expectedVersion\n            )).unsigned = false\n          else if (typeof object.expectedVersion === 'string')\n            message.expectedVersion = parseInt(object.expectedVersion, 10)\n          else if (typeof object.expectedVersion === 'number')\n            message.expectedVersion = object.expectedVersion\n          else if (typeof object.expectedVersion === 'object')\n            message.expectedVersion = new $util.LongBits(\n              object.expectedVersion.low >>> 0,\n              object.expectedVersion.high >>> 0\n            ).toNumber()\n        if (object.requireMaster != null) message.requireMaster = Boolean(object.requireMaster)\n        return message\n      }\n\n      /**\n       * Creates a plain object from a TransactionStart message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.TransactionStart\n       * @static\n       * @param {eventstore.proto.TransactionStart} message TransactionStart\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      TransactionStart.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.defaults) {\n          object.eventStreamId = ''\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.expectedVersion =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.expectedVersion = options.longs === String ? '0' : 0\n          object.requireMaster = false\n        }\n        if (message.eventStreamId != null && message.hasOwnProperty('eventStreamId'))\n          object.eventStreamId = message.eventStreamId\n        if (message.expectedVersion != null && message.hasOwnProperty('expectedVersion'))\n          if (typeof message.expectedVersion === 'number')\n            object.expectedVersion =\n              options.longs === String ? String(message.expectedVersion) : message.expectedVersion\n          else\n            object.expectedVersion =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.expectedVersion)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.expectedVersion.low >>> 0,\n                    message.expectedVersion.high >>> 0\n                  ).toNumber()\n                : message.expectedVersion\n        if (message.requireMaster != null && message.hasOwnProperty('requireMaster'))\n          object.requireMaster = message.requireMaster\n        return object\n      }\n\n      /**\n       * Converts this TransactionStart to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.TransactionStart\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      TransactionStart.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      return TransactionStart\n    })()\n\n    proto.TransactionStartCompleted = (function() {\n      /**\n       * Properties of a TransactionStartCompleted.\n       * @memberof eventstore.proto\n       * @interface ITransactionStartCompleted\n       * @property {number|Long} transactionId TransactionStartCompleted transactionId\n       * @property {eventstore.proto.OperationResult} result TransactionStartCompleted result\n       * @property {string|null} [message] TransactionStartCompleted message\n       */\n\n      /**\n       * Constructs a new TransactionStartCompleted.\n       * @memberof eventstore.proto\n       * @classdesc Represents a TransactionStartCompleted.\n       * @implements ITransactionStartCompleted\n       * @constructor\n       * @param {eventstore.proto.ITransactionStartCompleted=} [properties] Properties to set\n       */\n      function TransactionStartCompleted(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * TransactionStartCompleted transactionId.\n       * @member {number|Long} transactionId\n       * @memberof eventstore.proto.TransactionStartCompleted\n       * @instance\n       */\n      TransactionStartCompleted.prototype.transactionId = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0\n\n      /**\n       * TransactionStartCompleted result.\n       * @member {eventstore.proto.OperationResult} result\n       * @memberof eventstore.proto.TransactionStartCompleted\n       * @instance\n       */\n      TransactionStartCompleted.prototype.result = 0\n\n      /**\n       * TransactionStartCompleted message.\n       * @member {string} message\n       * @memberof eventstore.proto.TransactionStartCompleted\n       * @instance\n       */\n      TransactionStartCompleted.prototype.message = ''\n\n      /**\n       * Creates a new TransactionStartCompleted instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.TransactionStartCompleted\n       * @static\n       * @param {eventstore.proto.ITransactionStartCompleted=} [properties] Properties to set\n       * @returns {eventstore.proto.TransactionStartCompleted} TransactionStartCompleted instance\n       */\n      TransactionStartCompleted.create = function create(properties) {\n        return new TransactionStartCompleted(properties)\n      }\n\n      /**\n       * Encodes the specified TransactionStartCompleted message. Does not implicitly {@link eventstore.proto.TransactionStartCompleted.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.TransactionStartCompleted\n       * @static\n       * @param {eventstore.proto.ITransactionStartCompleted} message TransactionStartCompleted message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      TransactionStartCompleted.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.transactionId)\n        writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.result)\n        if (message.message != null && message.hasOwnProperty('message'))\n          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.message)\n        return writer\n      }\n\n      /**\n       * Encodes the specified TransactionStartCompleted message, length delimited. Does not implicitly {@link eventstore.proto.TransactionStartCompleted.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.TransactionStartCompleted\n       * @static\n       * @param {eventstore.proto.ITransactionStartCompleted} message TransactionStartCompleted message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      TransactionStartCompleted.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes a TransactionStartCompleted message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.TransactionStartCompleted\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.TransactionStartCompleted} TransactionStartCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      TransactionStartCompleted.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.TransactionStartCompleted()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              message.transactionId = reader.int64()\n              break\n            case 2:\n              message.result = reader.int32()\n              break\n            case 3:\n              message.message = reader.string()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        if (!message.hasOwnProperty('transactionId'))\n          throw $util.ProtocolError(\"missing required 'transactionId'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('result'))\n          throw $util.ProtocolError(\"missing required 'result'\", {\n            instance: message\n          })\n        return message\n      }\n\n      /**\n       * Decodes a TransactionStartCompleted message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.TransactionStartCompleted\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.TransactionStartCompleted} TransactionStartCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      TransactionStartCompleted.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies a TransactionStartCompleted message.\n       * @function verify\n       * @memberof eventstore.proto.TransactionStartCompleted\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      TransactionStartCompleted.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        if (\n          !$util.isInteger(message.transactionId) &&\n          !(\n            message.transactionId &&\n            $util.isInteger(message.transactionId.low) &&\n            $util.isInteger(message.transactionId.high)\n          )\n        )\n          return 'transactionId: integer|Long expected'\n        switch (message.result) {\n          default:\n            return 'result: enum value expected'\n          case 0:\n          case 1:\n          case 2:\n          case 3:\n          case 4:\n          case 5:\n          case 6:\n          case 7:\n            break\n        }\n        if (message.message != null && message.hasOwnProperty('message'))\n          if (!$util.isString(message.message)) return 'message: string expected'\n        return null\n      }\n\n      /**\n       * Creates a TransactionStartCompleted message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.TransactionStartCompleted\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.TransactionStartCompleted} TransactionStartCompleted\n       */\n      TransactionStartCompleted.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.TransactionStartCompleted) return object\n        var message = new $root.eventstore.proto.TransactionStartCompleted()\n        if (object.transactionId != null)\n          if ($util.Long)\n            (message.transactionId = $util.Long.fromValue(object.transactionId)).unsigned = false\n          else if (typeof object.transactionId === 'string')\n            message.transactionId = parseInt(object.transactionId, 10)\n          else if (typeof object.transactionId === 'number')\n            message.transactionId = object.transactionId\n          else if (typeof object.transactionId === 'object')\n            message.transactionId = new $util.LongBits(\n              object.transactionId.low >>> 0,\n              object.transactionId.high >>> 0\n            ).toNumber()\n        switch (object.result) {\n          case 'Success':\n          case 0:\n            message.result = 0\n            break\n          case 'PrepareTimeout':\n          case 1:\n            message.result = 1\n            break\n          case 'CommitTimeout':\n          case 2:\n            message.result = 2\n            break\n          case 'ForwardTimeout':\n          case 3:\n            message.result = 3\n            break\n          case 'WrongExpectedVersion':\n          case 4:\n            message.result = 4\n            break\n          case 'StreamDeleted':\n          case 5:\n            message.result = 5\n            break\n          case 'InvalidTransaction':\n          case 6:\n            message.result = 6\n            break\n          case 'AccessDenied':\n          case 7:\n            message.result = 7\n            break\n        }\n        if (object.message != null) message.message = String(object.message)\n        return message\n      }\n\n      /**\n       * Creates a plain object from a TransactionStartCompleted message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.TransactionStartCompleted\n       * @static\n       * @param {eventstore.proto.TransactionStartCompleted} message TransactionStartCompleted\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      TransactionStartCompleted.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.defaults) {\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.transactionId =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.transactionId = options.longs === String ? '0' : 0\n          object.result = options.enums === String ? 'Success' : 0\n          object.message = ''\n        }\n        if (message.transactionId != null && message.hasOwnProperty('transactionId'))\n          if (typeof message.transactionId === 'number')\n            object.transactionId =\n              options.longs === String ? String(message.transactionId) : message.transactionId\n          else\n            object.transactionId =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.transactionId)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.transactionId.low >>> 0,\n                    message.transactionId.high >>> 0\n                  ).toNumber()\n                : message.transactionId\n        if (message.result != null && message.hasOwnProperty('result'))\n          object.result =\n            options.enums === String\n              ? $root.eventstore.proto.OperationResult[message.result]\n              : message.result\n        if (message.message != null && message.hasOwnProperty('message'))\n          object.message = message.message\n        return object\n      }\n\n      /**\n       * Converts this TransactionStartCompleted to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.TransactionStartCompleted\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      TransactionStartCompleted.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      return TransactionStartCompleted\n    })()\n\n    proto.TransactionWrite = (function() {\n      /**\n       * Properties of a TransactionWrite.\n       * @memberof eventstore.proto\n       * @interface ITransactionWrite\n       * @property {number|Long} transactionId TransactionWrite transactionId\n       * @property {Array.<eventstore.proto.INewEvent>|null} [events] TransactionWrite events\n       * @property {boolean} requireMaster TransactionWrite requireMaster\n       */\n\n      /**\n       * Constructs a new TransactionWrite.\n       * @memberof eventstore.proto\n       * @classdesc Represents a TransactionWrite.\n       * @implements ITransactionWrite\n       * @constructor\n       * @param {eventstore.proto.ITransactionWrite=} [properties] Properties to set\n       */\n      function TransactionWrite(properties) {\n        this.events = []\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * TransactionWrite transactionId.\n       * @member {number|Long} transactionId\n       * @memberof eventstore.proto.TransactionWrite\n       * @instance\n       */\n      TransactionWrite.prototype.transactionId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0\n\n      /**\n       * TransactionWrite events.\n       * @member {Array.<eventstore.proto.INewEvent>} events\n       * @memberof eventstore.proto.TransactionWrite\n       * @instance\n       */\n      TransactionWrite.prototype.events = $util.emptyArray\n\n      /**\n       * TransactionWrite requireMaster.\n       * @member {boolean} requireMaster\n       * @memberof eventstore.proto.TransactionWrite\n       * @instance\n       */\n      TransactionWrite.prototype.requireMaster = false\n\n      /**\n       * Creates a new TransactionWrite instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.TransactionWrite\n       * @static\n       * @param {eventstore.proto.ITransactionWrite=} [properties] Properties to set\n       * @returns {eventstore.proto.TransactionWrite} TransactionWrite instance\n       */\n      TransactionWrite.create = function create(properties) {\n        return new TransactionWrite(properties)\n      }\n\n      /**\n       * Encodes the specified TransactionWrite message. Does not implicitly {@link eventstore.proto.TransactionWrite.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.TransactionWrite\n       * @static\n       * @param {eventstore.proto.ITransactionWrite} message TransactionWrite message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      TransactionWrite.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.transactionId)\n        if (message.events != null && message.events.length)\n          for (var i = 0; i < message.events.length; ++i)\n            $root.eventstore.proto.NewEvent.encode(\n              message.events[i],\n              writer.uint32(/* id 2, wireType 2 =*/ 18).fork()\n            ).ldelim()\n        writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.requireMaster)\n        return writer\n      }\n\n      /**\n       * Encodes the specified TransactionWrite message, length delimited. Does not implicitly {@link eventstore.proto.TransactionWrite.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.TransactionWrite\n       * @static\n       * @param {eventstore.proto.ITransactionWrite} message TransactionWrite message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      TransactionWrite.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes a TransactionWrite message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.TransactionWrite\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.TransactionWrite} TransactionWrite\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      TransactionWrite.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.TransactionWrite()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              message.transactionId = reader.int64()\n              break\n            case 2:\n              if (!(message.events && message.events.length)) message.events = []\n              message.events.push($root.eventstore.proto.NewEvent.decode(reader, reader.uint32()))\n              break\n            case 3:\n              message.requireMaster = reader.bool()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        if (!message.hasOwnProperty('transactionId'))\n          throw $util.ProtocolError(\"missing required 'transactionId'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('requireMaster'))\n          throw $util.ProtocolError(\"missing required 'requireMaster'\", {\n            instance: message\n          })\n        return message\n      }\n\n      /**\n       * Decodes a TransactionWrite message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.TransactionWrite\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.TransactionWrite} TransactionWrite\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      TransactionWrite.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies a TransactionWrite message.\n       * @function verify\n       * @memberof eventstore.proto.TransactionWrite\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      TransactionWrite.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        if (\n          !$util.isInteger(message.transactionId) &&\n          !(\n            message.transactionId &&\n            $util.isInteger(message.transactionId.low) &&\n            $util.isInteger(message.transactionId.high)\n          )\n        )\n          return 'transactionId: integer|Long expected'\n        if (message.events != null && message.hasOwnProperty('events')) {\n          if (!Array.isArray(message.events)) return 'events: array expected'\n          for (var i = 0; i < message.events.length; ++i) {\n            var error = $root.eventstore.proto.NewEvent.verify(message.events[i])\n            if (error) return 'events.' + error\n          }\n        }\n        if (typeof message.requireMaster !== 'boolean') return 'requireMaster: boolean expected'\n        return null\n      }\n\n      /**\n       * Creates a TransactionWrite message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.TransactionWrite\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.TransactionWrite} TransactionWrite\n       */\n      TransactionWrite.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.TransactionWrite) return object\n        var message = new $root.eventstore.proto.TransactionWrite()\n        if (object.transactionId != null)\n          if ($util.Long)\n            (message.transactionId = $util.Long.fromValue(object.transactionId)).unsigned = false\n          else if (typeof object.transactionId === 'string')\n            message.transactionId = parseInt(object.transactionId, 10)\n          else if (typeof object.transactionId === 'number')\n            message.transactionId = object.transactionId\n          else if (typeof object.transactionId === 'object')\n            message.transactionId = new $util.LongBits(\n              object.transactionId.low >>> 0,\n              object.transactionId.high >>> 0\n            ).toNumber()\n        if (object.events) {\n          if (!Array.isArray(object.events))\n            throw TypeError('.eventstore.proto.TransactionWrite.events: array expected')\n          message.events = []\n          for (var i = 0; i < object.events.length; ++i) {\n            if (typeof object.events[i] !== 'object')\n              throw TypeError('.eventstore.proto.TransactionWrite.events: object expected')\n            message.events[i] = $root.eventstore.proto.NewEvent.fromObject(object.events[i])\n          }\n        }\n        if (object.requireMaster != null) message.requireMaster = Boolean(object.requireMaster)\n        return message\n      }\n\n      /**\n       * Creates a plain object from a TransactionWrite message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.TransactionWrite\n       * @static\n       * @param {eventstore.proto.TransactionWrite} message TransactionWrite\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      TransactionWrite.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.arrays || options.defaults) object.events = []\n        if (options.defaults) {\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.transactionId =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.transactionId = options.longs === String ? '0' : 0\n          object.requireMaster = false\n        }\n        if (message.transactionId != null && message.hasOwnProperty('transactionId'))\n          if (typeof message.transactionId === 'number')\n            object.transactionId =\n              options.longs === String ? String(message.transactionId) : message.transactionId\n          else\n            object.transactionId =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.transactionId)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.transactionId.low >>> 0,\n                    message.transactionId.high >>> 0\n                  ).toNumber()\n                : message.transactionId\n        if (message.events && message.events.length) {\n          object.events = []\n          for (var j = 0; j < message.events.length; ++j)\n            object.events[j] = $root.eventstore.proto.NewEvent.toObject(message.events[j], options)\n        }\n        if (message.requireMaster != null && message.hasOwnProperty('requireMaster'))\n          object.requireMaster = message.requireMaster\n        return object\n      }\n\n      /**\n       * Converts this TransactionWrite to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.TransactionWrite\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      TransactionWrite.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      return TransactionWrite\n    })()\n\n    proto.TransactionWriteCompleted = (function() {\n      /**\n       * Properties of a TransactionWriteCompleted.\n       * @memberof eventstore.proto\n       * @interface ITransactionWriteCompleted\n       * @property {number|Long} transactionId TransactionWriteCompleted transactionId\n       * @property {eventstore.proto.OperationResult} result TransactionWriteCompleted result\n       * @property {string|null} [message] TransactionWriteCompleted message\n       */\n\n      /**\n       * Constructs a new TransactionWriteCompleted.\n       * @memberof eventstore.proto\n       * @classdesc Represents a TransactionWriteCompleted.\n       * @implements ITransactionWriteCompleted\n       * @constructor\n       * @param {eventstore.proto.ITransactionWriteCompleted=} [properties] Properties to set\n       */\n      function TransactionWriteCompleted(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * TransactionWriteCompleted transactionId.\n       * @member {number|Long} transactionId\n       * @memberof eventstore.proto.TransactionWriteCompleted\n       * @instance\n       */\n      TransactionWriteCompleted.prototype.transactionId = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0\n\n      /**\n       * TransactionWriteCompleted result.\n       * @member {eventstore.proto.OperationResult} result\n       * @memberof eventstore.proto.TransactionWriteCompleted\n       * @instance\n       */\n      TransactionWriteCompleted.prototype.result = 0\n\n      /**\n       * TransactionWriteCompleted message.\n       * @member {string} message\n       * @memberof eventstore.proto.TransactionWriteCompleted\n       * @instance\n       */\n      TransactionWriteCompleted.prototype.message = ''\n\n      /**\n       * Creates a new TransactionWriteCompleted instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.TransactionWriteCompleted\n       * @static\n       * @param {eventstore.proto.ITransactionWriteCompleted=} [properties] Properties to set\n       * @returns {eventstore.proto.TransactionWriteCompleted} TransactionWriteCompleted instance\n       */\n      TransactionWriteCompleted.create = function create(properties) {\n        return new TransactionWriteCompleted(properties)\n      }\n\n      /**\n       * Encodes the specified TransactionWriteCompleted message. Does not implicitly {@link eventstore.proto.TransactionWriteCompleted.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.TransactionWriteCompleted\n       * @static\n       * @param {eventstore.proto.ITransactionWriteCompleted} message TransactionWriteCompleted message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      TransactionWriteCompleted.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.transactionId)\n        writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.result)\n        if (message.message != null && message.hasOwnProperty('message'))\n          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.message)\n        return writer\n      }\n\n      /**\n       * Encodes the specified TransactionWriteCompleted message, length delimited. Does not implicitly {@link eventstore.proto.TransactionWriteCompleted.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.TransactionWriteCompleted\n       * @static\n       * @param {eventstore.proto.ITransactionWriteCompleted} message TransactionWriteCompleted message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      TransactionWriteCompleted.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes a TransactionWriteCompleted message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.TransactionWriteCompleted\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.TransactionWriteCompleted} TransactionWriteCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      TransactionWriteCompleted.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.TransactionWriteCompleted()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              message.transactionId = reader.int64()\n              break\n            case 2:\n              message.result = reader.int32()\n              break\n            case 3:\n              message.message = reader.string()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        if (!message.hasOwnProperty('transactionId'))\n          throw $util.ProtocolError(\"missing required 'transactionId'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('result'))\n          throw $util.ProtocolError(\"missing required 'result'\", {\n            instance: message\n          })\n        return message\n      }\n\n      /**\n       * Decodes a TransactionWriteCompleted message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.TransactionWriteCompleted\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.TransactionWriteCompleted} TransactionWriteCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      TransactionWriteCompleted.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies a TransactionWriteCompleted message.\n       * @function verify\n       * @memberof eventstore.proto.TransactionWriteCompleted\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      TransactionWriteCompleted.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        if (\n          !$util.isInteger(message.transactionId) &&\n          !(\n            message.transactionId &&\n            $util.isInteger(message.transactionId.low) &&\n            $util.isInteger(message.transactionId.high)\n          )\n        )\n          return 'transactionId: integer|Long expected'\n        switch (message.result) {\n          default:\n            return 'result: enum value expected'\n          case 0:\n          case 1:\n          case 2:\n          case 3:\n          case 4:\n          case 5:\n          case 6:\n          case 7:\n            break\n        }\n        if (message.message != null && message.hasOwnProperty('message'))\n          if (!$util.isString(message.message)) return 'message: string expected'\n        return null\n      }\n\n      /**\n       * Creates a TransactionWriteCompleted message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.TransactionWriteCompleted\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.TransactionWriteCompleted} TransactionWriteCompleted\n       */\n      TransactionWriteCompleted.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.TransactionWriteCompleted) return object\n        var message = new $root.eventstore.proto.TransactionWriteCompleted()\n        if (object.transactionId != null)\n          if ($util.Long)\n            (message.transactionId = $util.Long.fromValue(object.transactionId)).unsigned = false\n          else if (typeof object.transactionId === 'string')\n            message.transactionId = parseInt(object.transactionId, 10)\n          else if (typeof object.transactionId === 'number')\n            message.transactionId = object.transactionId\n          else if (typeof object.transactionId === 'object')\n            message.transactionId = new $util.LongBits(\n              object.transactionId.low >>> 0,\n              object.transactionId.high >>> 0\n            ).toNumber()\n        switch (object.result) {\n          case 'Success':\n          case 0:\n            message.result = 0\n            break\n          case 'PrepareTimeout':\n          case 1:\n            message.result = 1\n            break\n          case 'CommitTimeout':\n          case 2:\n            message.result = 2\n            break\n          case 'ForwardTimeout':\n          case 3:\n            message.result = 3\n            break\n          case 'WrongExpectedVersion':\n          case 4:\n            message.result = 4\n            break\n          case 'StreamDeleted':\n          case 5:\n            message.result = 5\n            break\n          case 'InvalidTransaction':\n          case 6:\n            message.result = 6\n            break\n          case 'AccessDenied':\n          case 7:\n            message.result = 7\n            break\n        }\n        if (object.message != null) message.message = String(object.message)\n        return message\n      }\n\n      /**\n       * Creates a plain object from a TransactionWriteCompleted message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.TransactionWriteCompleted\n       * @static\n       * @param {eventstore.proto.TransactionWriteCompleted} message TransactionWriteCompleted\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      TransactionWriteCompleted.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.defaults) {\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.transactionId =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.transactionId = options.longs === String ? '0' : 0\n          object.result = options.enums === String ? 'Success' : 0\n          object.message = ''\n        }\n        if (message.transactionId != null && message.hasOwnProperty('transactionId'))\n          if (typeof message.transactionId === 'number')\n            object.transactionId =\n              options.longs === String ? String(message.transactionId) : message.transactionId\n          else\n            object.transactionId =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.transactionId)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.transactionId.low >>> 0,\n                    message.transactionId.high >>> 0\n                  ).toNumber()\n                : message.transactionId\n        if (message.result != null && message.hasOwnProperty('result'))\n          object.result =\n            options.enums === String\n              ? $root.eventstore.proto.OperationResult[message.result]\n              : message.result\n        if (message.message != null && message.hasOwnProperty('message'))\n          object.message = message.message\n        return object\n      }\n\n      /**\n       * Converts this TransactionWriteCompleted to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.TransactionWriteCompleted\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      TransactionWriteCompleted.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      return TransactionWriteCompleted\n    })()\n\n    proto.TransactionCommit = (function() {\n      /**\n       * Properties of a TransactionCommit.\n       * @memberof eventstore.proto\n       * @interface ITransactionCommit\n       * @property {number|Long} transactionId TransactionCommit transactionId\n       * @property {boolean} requireMaster TransactionCommit requireMaster\n       */\n\n      /**\n       * Constructs a new TransactionCommit.\n       * @memberof eventstore.proto\n       * @classdesc Represents a TransactionCommit.\n       * @implements ITransactionCommit\n       * @constructor\n       * @param {eventstore.proto.ITransactionCommit=} [properties] Properties to set\n       */\n      function TransactionCommit(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * TransactionCommit transactionId.\n       * @member {number|Long} transactionId\n       * @memberof eventstore.proto.TransactionCommit\n       * @instance\n       */\n      TransactionCommit.prototype.transactionId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0\n\n      /**\n       * TransactionCommit requireMaster.\n       * @member {boolean} requireMaster\n       * @memberof eventstore.proto.TransactionCommit\n       * @instance\n       */\n      TransactionCommit.prototype.requireMaster = false\n\n      /**\n       * Creates a new TransactionCommit instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.TransactionCommit\n       * @static\n       * @param {eventstore.proto.ITransactionCommit=} [properties] Properties to set\n       * @returns {eventstore.proto.TransactionCommit} TransactionCommit instance\n       */\n      TransactionCommit.create = function create(properties) {\n        return new TransactionCommit(properties)\n      }\n\n      /**\n       * Encodes the specified TransactionCommit message. Does not implicitly {@link eventstore.proto.TransactionCommit.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.TransactionCommit\n       * @static\n       * @param {eventstore.proto.ITransactionCommit} message TransactionCommit message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      TransactionCommit.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.transactionId)\n        writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.requireMaster)\n        return writer\n      }\n\n      /**\n       * Encodes the specified TransactionCommit message, length delimited. Does not implicitly {@link eventstore.proto.TransactionCommit.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.TransactionCommit\n       * @static\n       * @param {eventstore.proto.ITransactionCommit} message TransactionCommit message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      TransactionCommit.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes a TransactionCommit message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.TransactionCommit\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.TransactionCommit} TransactionCommit\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      TransactionCommit.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.TransactionCommit()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              message.transactionId = reader.int64()\n              break\n            case 2:\n              message.requireMaster = reader.bool()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        if (!message.hasOwnProperty('transactionId'))\n          throw $util.ProtocolError(\"missing required 'transactionId'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('requireMaster'))\n          throw $util.ProtocolError(\"missing required 'requireMaster'\", {\n            instance: message\n          })\n        return message\n      }\n\n      /**\n       * Decodes a TransactionCommit message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.TransactionCommit\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.TransactionCommit} TransactionCommit\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      TransactionCommit.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies a TransactionCommit message.\n       * @function verify\n       * @memberof eventstore.proto.TransactionCommit\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      TransactionCommit.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        if (\n          !$util.isInteger(message.transactionId) &&\n          !(\n            message.transactionId &&\n            $util.isInteger(message.transactionId.low) &&\n            $util.isInteger(message.transactionId.high)\n          )\n        )\n          return 'transactionId: integer|Long expected'\n        if (typeof message.requireMaster !== 'boolean') return 'requireMaster: boolean expected'\n        return null\n      }\n\n      /**\n       * Creates a TransactionCommit message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.TransactionCommit\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.TransactionCommit} TransactionCommit\n       */\n      TransactionCommit.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.TransactionCommit) return object\n        var message = new $root.eventstore.proto.TransactionCommit()\n        if (object.transactionId != null)\n          if ($util.Long)\n            (message.transactionId = $util.Long.fromValue(object.transactionId)).unsigned = false\n          else if (typeof object.transactionId === 'string')\n            message.transactionId = parseInt(object.transactionId, 10)\n          else if (typeof object.transactionId === 'number')\n            message.transactionId = object.transactionId\n          else if (typeof object.transactionId === 'object')\n            message.transactionId = new $util.LongBits(\n              object.transactionId.low >>> 0,\n              object.transactionId.high >>> 0\n            ).toNumber()\n        if (object.requireMaster != null) message.requireMaster = Boolean(object.requireMaster)\n        return message\n      }\n\n      /**\n       * Creates a plain object from a TransactionCommit message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.TransactionCommit\n       * @static\n       * @param {eventstore.proto.TransactionCommit} message TransactionCommit\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      TransactionCommit.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.defaults) {\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.transactionId =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.transactionId = options.longs === String ? '0' : 0\n          object.requireMaster = false\n        }\n        if (message.transactionId != null && message.hasOwnProperty('transactionId'))\n          if (typeof message.transactionId === 'number')\n            object.transactionId =\n              options.longs === String ? String(message.transactionId) : message.transactionId\n          else\n            object.transactionId =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.transactionId)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.transactionId.low >>> 0,\n                    message.transactionId.high >>> 0\n                  ).toNumber()\n                : message.transactionId\n        if (message.requireMaster != null && message.hasOwnProperty('requireMaster'))\n          object.requireMaster = message.requireMaster\n        return object\n      }\n\n      /**\n       * Converts this TransactionCommit to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.TransactionCommit\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      TransactionCommit.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      return TransactionCommit\n    })()\n\n    proto.TransactionCommitCompleted = (function() {\n      /**\n       * Properties of a TransactionCommitCompleted.\n       * @memberof eventstore.proto\n       * @interface ITransactionCommitCompleted\n       * @property {number|Long} transactionId TransactionCommitCompleted transactionId\n       * @property {eventstore.proto.OperationResult} result TransactionCommitCompleted result\n       * @property {string|null} [message] TransactionCommitCompleted message\n       * @property {number|Long} firstEventNumber TransactionCommitCompleted firstEventNumber\n       * @property {number|Long} lastEventNumber TransactionCommitCompleted lastEventNumber\n       * @property {number|Long|null} [preparePosition] TransactionCommitCompleted preparePosition\n       * @property {number|Long|null} [commitPosition] TransactionCommitCompleted commitPosition\n       */\n\n      /**\n       * Constructs a new TransactionCommitCompleted.\n       * @memberof eventstore.proto\n       * @classdesc Represents a TransactionCommitCompleted.\n       * @implements ITransactionCommitCompleted\n       * @constructor\n       * @param {eventstore.proto.ITransactionCommitCompleted=} [properties] Properties to set\n       */\n      function TransactionCommitCompleted(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * TransactionCommitCompleted transactionId.\n       * @member {number|Long} transactionId\n       * @memberof eventstore.proto.TransactionCommitCompleted\n       * @instance\n       */\n      TransactionCommitCompleted.prototype.transactionId = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0\n\n      /**\n       * TransactionCommitCompleted result.\n       * @member {eventstore.proto.OperationResult} result\n       * @memberof eventstore.proto.TransactionCommitCompleted\n       * @instance\n       */\n      TransactionCommitCompleted.prototype.result = 0\n\n      /**\n       * TransactionCommitCompleted message.\n       * @member {string} message\n       * @memberof eventstore.proto.TransactionCommitCompleted\n       * @instance\n       */\n      TransactionCommitCompleted.prototype.message = ''\n\n      /**\n       * TransactionCommitCompleted firstEventNumber.\n       * @member {number|Long} firstEventNumber\n       * @memberof eventstore.proto.TransactionCommitCompleted\n       * @instance\n       */\n      TransactionCommitCompleted.prototype.firstEventNumber = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0\n\n      /**\n       * TransactionCommitCompleted lastEventNumber.\n       * @member {number|Long} lastEventNumber\n       * @memberof eventstore.proto.TransactionCommitCompleted\n       * @instance\n       */\n      TransactionCommitCompleted.prototype.lastEventNumber = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0\n\n      /**\n       * TransactionCommitCompleted preparePosition.\n       * @member {number|Long} preparePosition\n       * @memberof eventstore.proto.TransactionCommitCompleted\n       * @instance\n       */\n      TransactionCommitCompleted.prototype.preparePosition = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0\n\n      /**\n       * TransactionCommitCompleted commitPosition.\n       * @member {number|Long} commitPosition\n       * @memberof eventstore.proto.TransactionCommitCompleted\n       * @instance\n       */\n      TransactionCommitCompleted.prototype.commitPosition = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0\n\n      /**\n       * Creates a new TransactionCommitCompleted instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.TransactionCommitCompleted\n       * @static\n       * @param {eventstore.proto.ITransactionCommitCompleted=} [properties] Properties to set\n       * @returns {eventstore.proto.TransactionCommitCompleted} TransactionCommitCompleted instance\n       */\n      TransactionCommitCompleted.create = function create(properties) {\n        return new TransactionCommitCompleted(properties)\n      }\n\n      /**\n       * Encodes the specified TransactionCommitCompleted message. Does not implicitly {@link eventstore.proto.TransactionCommitCompleted.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.TransactionCommitCompleted\n       * @static\n       * @param {eventstore.proto.ITransactionCommitCompleted} message TransactionCommitCompleted message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      TransactionCommitCompleted.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.transactionId)\n        writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.result)\n        if (message.message != null && message.hasOwnProperty('message'))\n          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.message)\n        writer.uint32(/* id 4, wireType 0 =*/ 32).int64(message.firstEventNumber)\n        writer.uint32(/* id 5, wireType 0 =*/ 40).int64(message.lastEventNumber)\n        if (message.preparePosition != null && message.hasOwnProperty('preparePosition'))\n          writer.uint32(/* id 6, wireType 0 =*/ 48).int64(message.preparePosition)\n        if (message.commitPosition != null && message.hasOwnProperty('commitPosition'))\n          writer.uint32(/* id 7, wireType 0 =*/ 56).int64(message.commitPosition)\n        return writer\n      }\n\n      /**\n       * Encodes the specified TransactionCommitCompleted message, length delimited. Does not implicitly {@link eventstore.proto.TransactionCommitCompleted.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.TransactionCommitCompleted\n       * @static\n       * @param {eventstore.proto.ITransactionCommitCompleted} message TransactionCommitCompleted message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      TransactionCommitCompleted.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes a TransactionCommitCompleted message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.TransactionCommitCompleted\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.TransactionCommitCompleted} TransactionCommitCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      TransactionCommitCompleted.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.TransactionCommitCompleted()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              message.transactionId = reader.int64()\n              break\n            case 2:\n              message.result = reader.int32()\n              break\n            case 3:\n              message.message = reader.string()\n              break\n            case 4:\n              message.firstEventNumber = reader.int64()\n              break\n            case 5:\n              message.lastEventNumber = reader.int64()\n              break\n            case 6:\n              message.preparePosition = reader.int64()\n              break\n            case 7:\n              message.commitPosition = reader.int64()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        if (!message.hasOwnProperty('transactionId'))\n          throw $util.ProtocolError(\"missing required 'transactionId'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('result'))\n          throw $util.ProtocolError(\"missing required 'result'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('firstEventNumber'))\n          throw $util.ProtocolError(\"missing required 'firstEventNumber'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('lastEventNumber'))\n          throw $util.ProtocolError(\"missing required 'lastEventNumber'\", {\n            instance: message\n          })\n        return message\n      }\n\n      /**\n       * Decodes a TransactionCommitCompleted message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.TransactionCommitCompleted\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.TransactionCommitCompleted} TransactionCommitCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      TransactionCommitCompleted.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies a TransactionCommitCompleted message.\n       * @function verify\n       * @memberof eventstore.proto.TransactionCommitCompleted\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      TransactionCommitCompleted.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        if (\n          !$util.isInteger(message.transactionId) &&\n          !(\n            message.transactionId &&\n            $util.isInteger(message.transactionId.low) &&\n            $util.isInteger(message.transactionId.high)\n          )\n        )\n          return 'transactionId: integer|Long expected'\n        switch (message.result) {\n          default:\n            return 'result: enum value expected'\n          case 0:\n          case 1:\n          case 2:\n          case 3:\n          case 4:\n          case 5:\n          case 6:\n          case 7:\n            break\n        }\n        if (message.message != null && message.hasOwnProperty('message'))\n          if (!$util.isString(message.message)) return 'message: string expected'\n        if (\n          !$util.isInteger(message.firstEventNumber) &&\n          !(\n            message.firstEventNumber &&\n            $util.isInteger(message.firstEventNumber.low) &&\n            $util.isInteger(message.firstEventNumber.high)\n          )\n        )\n          return 'firstEventNumber: integer|Long expected'\n        if (\n          !$util.isInteger(message.lastEventNumber) &&\n          !(\n            message.lastEventNumber &&\n            $util.isInteger(message.lastEventNumber.low) &&\n            $util.isInteger(message.lastEventNumber.high)\n          )\n        )\n          return 'lastEventNumber: integer|Long expected'\n        if (message.preparePosition != null && message.hasOwnProperty('preparePosition'))\n          if (\n            !$util.isInteger(message.preparePosition) &&\n            !(\n              message.preparePosition &&\n              $util.isInteger(message.preparePosition.low) &&\n              $util.isInteger(message.preparePosition.high)\n            )\n          )\n            return 'preparePosition: integer|Long expected'\n        if (message.commitPosition != null && message.hasOwnProperty('commitPosition'))\n          if (\n            !$util.isInteger(message.commitPosition) &&\n            !(\n              message.commitPosition &&\n              $util.isInteger(message.commitPosition.low) &&\n              $util.isInteger(message.commitPosition.high)\n            )\n          )\n            return 'commitPosition: integer|Long expected'\n        return null\n      }\n\n      /**\n       * Creates a TransactionCommitCompleted message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.TransactionCommitCompleted\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.TransactionCommitCompleted} TransactionCommitCompleted\n       */\n      TransactionCommitCompleted.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.TransactionCommitCompleted) return object\n        var message = new $root.eventstore.proto.TransactionCommitCompleted()\n        if (object.transactionId != null)\n          if ($util.Long)\n            (message.transactionId = $util.Long.fromValue(object.transactionId)).unsigned = false\n          else if (typeof object.transactionId === 'string')\n            message.transactionId = parseInt(object.transactionId, 10)\n          else if (typeof object.transactionId === 'number')\n            message.transactionId = object.transactionId\n          else if (typeof object.transactionId === 'object')\n            message.transactionId = new $util.LongBits(\n              object.transactionId.low >>> 0,\n              object.transactionId.high >>> 0\n            ).toNumber()\n        switch (object.result) {\n          case 'Success':\n          case 0:\n            message.result = 0\n            break\n          case 'PrepareTimeout':\n          case 1:\n            message.result = 1\n            break\n          case 'CommitTimeout':\n          case 2:\n            message.result = 2\n            break\n          case 'ForwardTimeout':\n          case 3:\n            message.result = 3\n            break\n          case 'WrongExpectedVersion':\n          case 4:\n            message.result = 4\n            break\n          case 'StreamDeleted':\n          case 5:\n            message.result = 5\n            break\n          case 'InvalidTransaction':\n          case 6:\n            message.result = 6\n            break\n          case 'AccessDenied':\n          case 7:\n            message.result = 7\n            break\n        }\n        if (object.message != null) message.message = String(object.message)\n        if (object.firstEventNumber != null)\n          if ($util.Long)\n            (message.firstEventNumber = $util.Long.fromValue(\n              object.firstEventNumber\n            )).unsigned = false\n          else if (typeof object.firstEventNumber === 'string')\n            message.firstEventNumber = parseInt(object.firstEventNumber, 10)\n          else if (typeof object.firstEventNumber === 'number')\n            message.firstEventNumber = object.firstEventNumber\n          else if (typeof object.firstEventNumber === 'object')\n            message.firstEventNumber = new $util.LongBits(\n              object.firstEventNumber.low >>> 0,\n              object.firstEventNumber.high >>> 0\n            ).toNumber()\n        if (object.lastEventNumber != null)\n          if ($util.Long)\n            (message.lastEventNumber = $util.Long.fromValue(\n              object.lastEventNumber\n            )).unsigned = false\n          else if (typeof object.lastEventNumber === 'string')\n            message.lastEventNumber = parseInt(object.lastEventNumber, 10)\n          else if (typeof object.lastEventNumber === 'number')\n            message.lastEventNumber = object.lastEventNumber\n          else if (typeof object.lastEventNumber === 'object')\n            message.lastEventNumber = new $util.LongBits(\n              object.lastEventNumber.low >>> 0,\n              object.lastEventNumber.high >>> 0\n            ).toNumber()\n        if (object.preparePosition != null)\n          if ($util.Long)\n            (message.preparePosition = $util.Long.fromValue(\n              object.preparePosition\n            )).unsigned = false\n          else if (typeof object.preparePosition === 'string')\n            message.preparePosition = parseInt(object.preparePosition, 10)\n          else if (typeof object.preparePosition === 'number')\n            message.preparePosition = object.preparePosition\n          else if (typeof object.preparePosition === 'object')\n            message.preparePosition = new $util.LongBits(\n              object.preparePosition.low >>> 0,\n              object.preparePosition.high >>> 0\n            ).toNumber()\n        if (object.commitPosition != null)\n          if ($util.Long)\n            (message.commitPosition = $util.Long.fromValue(object.commitPosition)).unsigned = false\n          else if (typeof object.commitPosition === 'string')\n            message.commitPosition = parseInt(object.commitPosition, 10)\n          else if (typeof object.commitPosition === 'number')\n            message.commitPosition = object.commitPosition\n          else if (typeof object.commitPosition === 'object')\n            message.commitPosition = new $util.LongBits(\n              object.commitPosition.low >>> 0,\n              object.commitPosition.high >>> 0\n            ).toNumber()\n        return message\n      }\n\n      /**\n       * Creates a plain object from a TransactionCommitCompleted message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.TransactionCommitCompleted\n       * @static\n       * @param {eventstore.proto.TransactionCommitCompleted} message TransactionCommitCompleted\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      TransactionCommitCompleted.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.defaults) {\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.transactionId =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.transactionId = options.longs === String ? '0' : 0\n          object.result = options.enums === String ? 'Success' : 0\n          object.message = ''\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.firstEventNumber =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.firstEventNumber = options.longs === String ? '0' : 0\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.lastEventNumber =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.lastEventNumber = options.longs === String ? '0' : 0\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.preparePosition =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.preparePosition = options.longs === String ? '0' : 0\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.commitPosition =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.commitPosition = options.longs === String ? '0' : 0\n        }\n        if (message.transactionId != null && message.hasOwnProperty('transactionId'))\n          if (typeof message.transactionId === 'number')\n            object.transactionId =\n              options.longs === String ? String(message.transactionId) : message.transactionId\n          else\n            object.transactionId =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.transactionId)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.transactionId.low >>> 0,\n                    message.transactionId.high >>> 0\n                  ).toNumber()\n                : message.transactionId\n        if (message.result != null && message.hasOwnProperty('result'))\n          object.result =\n            options.enums === String\n              ? $root.eventstore.proto.OperationResult[message.result]\n              : message.result\n        if (message.message != null && message.hasOwnProperty('message'))\n          object.message = message.message\n        if (message.firstEventNumber != null && message.hasOwnProperty('firstEventNumber'))\n          if (typeof message.firstEventNumber === 'number')\n            object.firstEventNumber =\n              options.longs === String ? String(message.firstEventNumber) : message.firstEventNumber\n          else\n            object.firstEventNumber =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.firstEventNumber)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.firstEventNumber.low >>> 0,\n                    message.firstEventNumber.high >>> 0\n                  ).toNumber()\n                : message.firstEventNumber\n        if (message.lastEventNumber != null && message.hasOwnProperty('lastEventNumber'))\n          if (typeof message.lastEventNumber === 'number')\n            object.lastEventNumber =\n              options.longs === String ? String(message.lastEventNumber) : message.lastEventNumber\n          else\n            object.lastEventNumber =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.lastEventNumber)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.lastEventNumber.low >>> 0,\n                    message.lastEventNumber.high >>> 0\n                  ).toNumber()\n                : message.lastEventNumber\n        if (message.preparePosition != null && message.hasOwnProperty('preparePosition'))\n          if (typeof message.preparePosition === 'number')\n            object.preparePosition =\n              options.longs === String ? String(message.preparePosition) : message.preparePosition\n          else\n            object.preparePosition =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.preparePosition)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.preparePosition.low >>> 0,\n                    message.preparePosition.high >>> 0\n                  ).toNumber()\n                : message.preparePosition\n        if (message.commitPosition != null && message.hasOwnProperty('commitPosition'))\n          if (typeof message.commitPosition === 'number')\n            object.commitPosition =\n              options.longs === String ? String(message.commitPosition) : message.commitPosition\n          else\n            object.commitPosition =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.commitPosition)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.commitPosition.low >>> 0,\n                    message.commitPosition.high >>> 0\n                  ).toNumber()\n                : message.commitPosition\n        return object\n      }\n\n      /**\n       * Converts this TransactionCommitCompleted to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.TransactionCommitCompleted\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      TransactionCommitCompleted.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      return TransactionCommitCompleted\n    })()\n\n    proto.ReadEvent = (function() {\n      /**\n       * Properties of a ReadEvent.\n       * @memberof eventstore.proto\n       * @interface IReadEvent\n       * @property {string} eventStreamId ReadEvent eventStreamId\n       * @property {number|Long} eventNumber ReadEvent eventNumber\n       * @property {boolean} resolveLinkTos ReadEvent resolveLinkTos\n       * @property {boolean} requireMaster ReadEvent requireMaster\n       */\n\n      /**\n       * Constructs a new ReadEvent.\n       * @memberof eventstore.proto\n       * @classdesc Represents a ReadEvent.\n       * @implements IReadEvent\n       * @constructor\n       * @param {eventstore.proto.IReadEvent=} [properties] Properties to set\n       */\n      function ReadEvent(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * ReadEvent eventStreamId.\n       * @member {string} eventStreamId\n       * @memberof eventstore.proto.ReadEvent\n       * @instance\n       */\n      ReadEvent.prototype.eventStreamId = ''\n\n      /**\n       * ReadEvent eventNumber.\n       * @member {number|Long} eventNumber\n       * @memberof eventstore.proto.ReadEvent\n       * @instance\n       */\n      ReadEvent.prototype.eventNumber = $util.Long ? $util.Long.fromBits(0, 0, false) : 0\n\n      /**\n       * ReadEvent resolveLinkTos.\n       * @member {boolean} resolveLinkTos\n       * @memberof eventstore.proto.ReadEvent\n       * @instance\n       */\n      ReadEvent.prototype.resolveLinkTos = false\n\n      /**\n       * ReadEvent requireMaster.\n       * @member {boolean} requireMaster\n       * @memberof eventstore.proto.ReadEvent\n       * @instance\n       */\n      ReadEvent.prototype.requireMaster = false\n\n      /**\n       * Creates a new ReadEvent instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.ReadEvent\n       * @static\n       * @param {eventstore.proto.IReadEvent=} [properties] Properties to set\n       * @returns {eventstore.proto.ReadEvent} ReadEvent instance\n       */\n      ReadEvent.create = function create(properties) {\n        return new ReadEvent(properties)\n      }\n\n      /**\n       * Encodes the specified ReadEvent message. Does not implicitly {@link eventstore.proto.ReadEvent.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.ReadEvent\n       * @static\n       * @param {eventstore.proto.IReadEvent} message ReadEvent message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      ReadEvent.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.eventStreamId)\n        writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.eventNumber)\n        writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.resolveLinkTos)\n        writer.uint32(/* id 4, wireType 0 =*/ 32).bool(message.requireMaster)\n        return writer\n      }\n\n      /**\n       * Encodes the specified ReadEvent message, length delimited. Does not implicitly {@link eventstore.proto.ReadEvent.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.ReadEvent\n       * @static\n       * @param {eventstore.proto.IReadEvent} message ReadEvent message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      ReadEvent.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes a ReadEvent message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.ReadEvent\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.ReadEvent} ReadEvent\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      ReadEvent.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.ReadEvent()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              message.eventStreamId = reader.string()\n              break\n            case 2:\n              message.eventNumber = reader.int64()\n              break\n            case 3:\n              message.resolveLinkTos = reader.bool()\n              break\n            case 4:\n              message.requireMaster = reader.bool()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        if (!message.hasOwnProperty('eventStreamId'))\n          throw $util.ProtocolError(\"missing required 'eventStreamId'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('eventNumber'))\n          throw $util.ProtocolError(\"missing required 'eventNumber'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('resolveLinkTos'))\n          throw $util.ProtocolError(\"missing required 'resolveLinkTos'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('requireMaster'))\n          throw $util.ProtocolError(\"missing required 'requireMaster'\", {\n            instance: message\n          })\n        return message\n      }\n\n      /**\n       * Decodes a ReadEvent message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.ReadEvent\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.ReadEvent} ReadEvent\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      ReadEvent.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies a ReadEvent message.\n       * @function verify\n       * @memberof eventstore.proto.ReadEvent\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      ReadEvent.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        if (!$util.isString(message.eventStreamId)) return 'eventStreamId: string expected'\n        if (\n          !$util.isInteger(message.eventNumber) &&\n          !(\n            message.eventNumber &&\n            $util.isInteger(message.eventNumber.low) &&\n            $util.isInteger(message.eventNumber.high)\n          )\n        )\n          return 'eventNumber: integer|Long expected'\n        if (typeof message.resolveLinkTos !== 'boolean') return 'resolveLinkTos: boolean expected'\n        if (typeof message.requireMaster !== 'boolean') return 'requireMaster: boolean expected'\n        return null\n      }\n\n      /**\n       * Creates a ReadEvent message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.ReadEvent\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.ReadEvent} ReadEvent\n       */\n      ReadEvent.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.ReadEvent) return object\n        var message = new $root.eventstore.proto.ReadEvent()\n        if (object.eventStreamId != null) message.eventStreamId = String(object.eventStreamId)\n        if (object.eventNumber != null)\n          if ($util.Long)\n            (message.eventNumber = $util.Long.fromValue(object.eventNumber)).unsigned = false\n          else if (typeof object.eventNumber === 'string')\n            message.eventNumber = parseInt(object.eventNumber, 10)\n          else if (typeof object.eventNumber === 'number') message.eventNumber = object.eventNumber\n          else if (typeof object.eventNumber === 'object')\n            message.eventNumber = new $util.LongBits(\n              object.eventNumber.low >>> 0,\n              object.eventNumber.high >>> 0\n            ).toNumber()\n        if (object.resolveLinkTos != null) message.resolveLinkTos = Boolean(object.resolveLinkTos)\n        if (object.requireMaster != null) message.requireMaster = Boolean(object.requireMaster)\n        return message\n      }\n\n      /**\n       * Creates a plain object from a ReadEvent message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.ReadEvent\n       * @static\n       * @param {eventstore.proto.ReadEvent} message ReadEvent\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      ReadEvent.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.defaults) {\n          object.eventStreamId = ''\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.eventNumber =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.eventNumber = options.longs === String ? '0' : 0\n          object.resolveLinkTos = false\n          object.requireMaster = false\n        }\n        if (message.eventStreamId != null && message.hasOwnProperty('eventStreamId'))\n          object.eventStreamId = message.eventStreamId\n        if (message.eventNumber != null && message.hasOwnProperty('eventNumber'))\n          if (typeof message.eventNumber === 'number')\n            object.eventNumber =\n              options.longs === String ? String(message.eventNumber) : message.eventNumber\n          else\n            object.eventNumber =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.eventNumber)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.eventNumber.low >>> 0,\n                    message.eventNumber.high >>> 0\n                  ).toNumber()\n                : message.eventNumber\n        if (message.resolveLinkTos != null && message.hasOwnProperty('resolveLinkTos'))\n          object.resolveLinkTos = message.resolveLinkTos\n        if (message.requireMaster != null && message.hasOwnProperty('requireMaster'))\n          object.requireMaster = message.requireMaster\n        return object\n      }\n\n      /**\n       * Converts this ReadEvent to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.ReadEvent\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      ReadEvent.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      return ReadEvent\n    })()\n\n    proto.ReadEventCompleted = (function() {\n      /**\n       * Properties of a ReadEventCompleted.\n       * @memberof eventstore.proto\n       * @interface IReadEventCompleted\n       * @property {eventstore.proto.ReadEventCompleted.ReadEventResult} result ReadEventCompleted result\n       * @property {eventstore.proto.IResolvedIndexedEvent} event ReadEventCompleted event\n       * @property {string|null} [error] ReadEventCompleted error\n       */\n\n      /**\n       * Constructs a new ReadEventCompleted.\n       * @memberof eventstore.proto\n       * @classdesc Represents a ReadEventCompleted.\n       * @implements IReadEventCompleted\n       * @constructor\n       * @param {eventstore.proto.IReadEventCompleted=} [properties] Properties to set\n       */\n      function ReadEventCompleted(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * ReadEventCompleted result.\n       * @member {eventstore.proto.ReadEventCompleted.ReadEventResult} result\n       * @memberof eventstore.proto.ReadEventCompleted\n       * @instance\n       */\n      ReadEventCompleted.prototype.result = 0\n\n      /**\n       * ReadEventCompleted event.\n       * @member {eventstore.proto.IResolvedIndexedEvent} event\n       * @memberof eventstore.proto.ReadEventCompleted\n       * @instance\n       */\n      ReadEventCompleted.prototype.event = null\n\n      /**\n       * ReadEventCompleted error.\n       * @member {string} error\n       * @memberof eventstore.proto.ReadEventCompleted\n       * @instance\n       */\n      ReadEventCompleted.prototype.error = ''\n\n      /**\n       * Creates a new ReadEventCompleted instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.ReadEventCompleted\n       * @static\n       * @param {eventstore.proto.IReadEventCompleted=} [properties] Properties to set\n       * @returns {eventstore.proto.ReadEventCompleted} ReadEventCompleted instance\n       */\n      ReadEventCompleted.create = function create(properties) {\n        return new ReadEventCompleted(properties)\n      }\n\n      /**\n       * Encodes the specified ReadEventCompleted message. Does not implicitly {@link eventstore.proto.ReadEventCompleted.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.ReadEventCompleted\n       * @static\n       * @param {eventstore.proto.IReadEventCompleted} message ReadEventCompleted message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      ReadEventCompleted.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.result)\n        $root.eventstore.proto.ResolvedIndexedEvent.encode(\n          message.event,\n          writer.uint32(/* id 2, wireType 2 =*/ 18).fork()\n        ).ldelim()\n        if (message.error != null && message.hasOwnProperty('error'))\n          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.error)\n        return writer\n      }\n\n      /**\n       * Encodes the specified ReadEventCompleted message, length delimited. Does not implicitly {@link eventstore.proto.ReadEventCompleted.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.ReadEventCompleted\n       * @static\n       * @param {eventstore.proto.IReadEventCompleted} message ReadEventCompleted message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      ReadEventCompleted.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes a ReadEventCompleted message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.ReadEventCompleted\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.ReadEventCompleted} ReadEventCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      ReadEventCompleted.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.ReadEventCompleted()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              message.result = reader.int32()\n              break\n            case 2:\n              message.event = $root.eventstore.proto.ResolvedIndexedEvent.decode(\n                reader,\n                reader.uint32()\n              )\n              break\n            case 3:\n              message.error = reader.string()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        if (!message.hasOwnProperty('result'))\n          throw $util.ProtocolError(\"missing required 'result'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('event'))\n          throw $util.ProtocolError(\"missing required 'event'\", {\n            instance: message\n          })\n        return message\n      }\n\n      /**\n       * Decodes a ReadEventCompleted message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.ReadEventCompleted\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.ReadEventCompleted} ReadEventCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      ReadEventCompleted.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies a ReadEventCompleted message.\n       * @function verify\n       * @memberof eventstore.proto.ReadEventCompleted\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      ReadEventCompleted.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        switch (message.result) {\n          default:\n            return 'result: enum value expected'\n          case 0:\n          case 1:\n          case 2:\n          case 3:\n          case 4:\n          case 5:\n            break\n        }\n        {\n          var error = $root.eventstore.proto.ResolvedIndexedEvent.verify(message.event)\n          if (error) return 'event.' + error\n        }\n        if (message.error != null && message.hasOwnProperty('error'))\n          if (!$util.isString(message.error)) return 'error: string expected'\n        return null\n      }\n\n      /**\n       * Creates a ReadEventCompleted message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.ReadEventCompleted\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.ReadEventCompleted} ReadEventCompleted\n       */\n      ReadEventCompleted.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.ReadEventCompleted) return object\n        var message = new $root.eventstore.proto.ReadEventCompleted()\n        switch (object.result) {\n          case 'Success':\n          case 0:\n            message.result = 0\n            break\n          case 'NotFound':\n          case 1:\n            message.result = 1\n            break\n          case 'NoStream':\n          case 2:\n            message.result = 2\n            break\n          case 'StreamDeleted':\n          case 3:\n            message.result = 3\n            break\n          case 'Error':\n          case 4:\n            message.result = 4\n            break\n          case 'AccessDenied':\n          case 5:\n            message.result = 5\n            break\n        }\n        if (object.event != null) {\n          if (typeof object.event !== 'object')\n            throw TypeError('.eventstore.proto.ReadEventCompleted.event: object expected')\n          message.event = $root.eventstore.proto.ResolvedIndexedEvent.fromObject(object.event)\n        }\n        if (object.error != null) message.error = String(object.error)\n        return message\n      }\n\n      /**\n       * Creates a plain object from a ReadEventCompleted message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.ReadEventCompleted\n       * @static\n       * @param {eventstore.proto.ReadEventCompleted} message ReadEventCompleted\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      ReadEventCompleted.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.defaults) {\n          object.result = options.enums === String ? 'Success' : 0\n          object.event = null\n          object.error = ''\n        }\n        if (message.result != null && message.hasOwnProperty('result'))\n          object.result =\n            options.enums === String\n              ? $root.eventstore.proto.ReadEventCompleted.ReadEventResult[message.result]\n              : message.result\n        if (message.event != null && message.hasOwnProperty('event'))\n          object.event = $root.eventstore.proto.ResolvedIndexedEvent.toObject(\n            message.event,\n            options\n          )\n        if (message.error != null && message.hasOwnProperty('error')) object.error = message.error\n        return object\n      }\n\n      /**\n       * Converts this ReadEventCompleted to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.ReadEventCompleted\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      ReadEventCompleted.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      /**\n       * ReadEventResult enum.\n       * @name eventstore.proto.ReadEventCompleted.ReadEventResult\n       * @enum {string}\n       * @property {number} Success=0 Success value\n       * @property {number} NotFound=1 NotFound value\n       * @property {number} NoStream=2 NoStream value\n       * @property {number} StreamDeleted=3 StreamDeleted value\n       * @property {number} Error=4 Error value\n       * @property {number} AccessDenied=5 AccessDenied value\n       */\n      ReadEventCompleted.ReadEventResult = (function() {\n        var valuesById = {},\n          values = Object.create(valuesById)\n        values[(valuesById[0] = 'Success')] = 0\n        values[(valuesById[1] = 'NotFound')] = 1\n        values[(valuesById[2] = 'NoStream')] = 2\n        values[(valuesById[3] = 'StreamDeleted')] = 3\n        values[(valuesById[4] = 'Error')] = 4\n        values[(valuesById[5] = 'AccessDenied')] = 5\n        return values\n      })()\n\n      return ReadEventCompleted\n    })()\n\n    proto.ReadStreamEvents = (function() {\n      /**\n       * Properties of a ReadStreamEvents.\n       * @memberof eventstore.proto\n       * @interface IReadStreamEvents\n       * @property {string} eventStreamId ReadStreamEvents eventStreamId\n       * @property {number|Long} fromEventNumber ReadStreamEvents fromEventNumber\n       * @property {number} maxCount ReadStreamEvents maxCount\n       * @property {boolean} resolveLinkTos ReadStreamEvents resolveLinkTos\n       * @property {boolean} requireMaster ReadStreamEvents requireMaster\n       */\n\n      /**\n       * Constructs a new ReadStreamEvents.\n       * @memberof eventstore.proto\n       * @classdesc Represents a ReadStreamEvents.\n       * @implements IReadStreamEvents\n       * @constructor\n       * @param {eventstore.proto.IReadStreamEvents=} [properties] Properties to set\n       */\n      function ReadStreamEvents(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * ReadStreamEvents eventStreamId.\n       * @member {string} eventStreamId\n       * @memberof eventstore.proto.ReadStreamEvents\n       * @instance\n       */\n      ReadStreamEvents.prototype.eventStreamId = ''\n\n      /**\n       * ReadStreamEvents fromEventNumber.\n       * @member {number|Long} fromEventNumber\n       * @memberof eventstore.proto.ReadStreamEvents\n       * @instance\n       */\n      ReadStreamEvents.prototype.fromEventNumber = $util.Long ? $util.Long.fromBits(0, 0, false) : 0\n\n      /**\n       * ReadStreamEvents maxCount.\n       * @member {number} maxCount\n       * @memberof eventstore.proto.ReadStreamEvents\n       * @instance\n       */\n      ReadStreamEvents.prototype.maxCount = 0\n\n      /**\n       * ReadStreamEvents resolveLinkTos.\n       * @member {boolean} resolveLinkTos\n       * @memberof eventstore.proto.ReadStreamEvents\n       * @instance\n       */\n      ReadStreamEvents.prototype.resolveLinkTos = false\n\n      /**\n       * ReadStreamEvents requireMaster.\n       * @member {boolean} requireMaster\n       * @memberof eventstore.proto.ReadStreamEvents\n       * @instance\n       */\n      ReadStreamEvents.prototype.requireMaster = false\n\n      /**\n       * Creates a new ReadStreamEvents instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.ReadStreamEvents\n       * @static\n       * @param {eventstore.proto.IReadStreamEvents=} [properties] Properties to set\n       * @returns {eventstore.proto.ReadStreamEvents} ReadStreamEvents instance\n       */\n      ReadStreamEvents.create = function create(properties) {\n        return new ReadStreamEvents(properties)\n      }\n\n      /**\n       * Encodes the specified ReadStreamEvents message. Does not implicitly {@link eventstore.proto.ReadStreamEvents.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.ReadStreamEvents\n       * @static\n       * @param {eventstore.proto.IReadStreamEvents} message ReadStreamEvents message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      ReadStreamEvents.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.eventStreamId)\n        writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.fromEventNumber)\n        writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.maxCount)\n        writer.uint32(/* id 4, wireType 0 =*/ 32).bool(message.resolveLinkTos)\n        writer.uint32(/* id 5, wireType 0 =*/ 40).bool(message.requireMaster)\n        return writer\n      }\n\n      /**\n       * Encodes the specified ReadStreamEvents message, length delimited. Does not implicitly {@link eventstore.proto.ReadStreamEvents.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.ReadStreamEvents\n       * @static\n       * @param {eventstore.proto.IReadStreamEvents} message ReadStreamEvents message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      ReadStreamEvents.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes a ReadStreamEvents message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.ReadStreamEvents\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.ReadStreamEvents} ReadStreamEvents\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      ReadStreamEvents.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.ReadStreamEvents()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              message.eventStreamId = reader.string()\n              break\n            case 2:\n              message.fromEventNumber = reader.int64()\n              break\n            case 3:\n              message.maxCount = reader.int32()\n              break\n            case 4:\n              message.resolveLinkTos = reader.bool()\n              break\n            case 5:\n              message.requireMaster = reader.bool()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        if (!message.hasOwnProperty('eventStreamId'))\n          throw $util.ProtocolError(\"missing required 'eventStreamId'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('fromEventNumber'))\n          throw $util.ProtocolError(\"missing required 'fromEventNumber'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('maxCount'))\n          throw $util.ProtocolError(\"missing required 'maxCount'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('resolveLinkTos'))\n          throw $util.ProtocolError(\"missing required 'resolveLinkTos'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('requireMaster'))\n          throw $util.ProtocolError(\"missing required 'requireMaster'\", {\n            instance: message\n          })\n        return message\n      }\n\n      /**\n       * Decodes a ReadStreamEvents message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.ReadStreamEvents\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.ReadStreamEvents} ReadStreamEvents\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      ReadStreamEvents.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies a ReadStreamEvents message.\n       * @function verify\n       * @memberof eventstore.proto.ReadStreamEvents\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      ReadStreamEvents.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        if (!$util.isString(message.eventStreamId)) return 'eventStreamId: string expected'\n        if (\n          !$util.isInteger(message.fromEventNumber) &&\n          !(\n            message.fromEventNumber &&\n            $util.isInteger(message.fromEventNumber.low) &&\n            $util.isInteger(message.fromEventNumber.high)\n          )\n        )\n          return 'fromEventNumber: integer|Long expected'\n        if (!$util.isInteger(message.maxCount)) return 'maxCount: integer expected'\n        if (typeof message.resolveLinkTos !== 'boolean') return 'resolveLinkTos: boolean expected'\n        if (typeof message.requireMaster !== 'boolean') return 'requireMaster: boolean expected'\n        return null\n      }\n\n      /**\n       * Creates a ReadStreamEvents message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.ReadStreamEvents\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.ReadStreamEvents} ReadStreamEvents\n       */\n      ReadStreamEvents.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.ReadStreamEvents) return object\n        var message = new $root.eventstore.proto.ReadStreamEvents()\n        if (object.eventStreamId != null) message.eventStreamId = String(object.eventStreamId)\n        if (object.fromEventNumber != null)\n          if ($util.Long)\n            (message.fromEventNumber = $util.Long.fromValue(\n              object.fromEventNumber\n            )).unsigned = false\n          else if (typeof object.fromEventNumber === 'string')\n            message.fromEventNumber = parseInt(object.fromEventNumber, 10)\n          else if (typeof object.fromEventNumber === 'number')\n            message.fromEventNumber = object.fromEventNumber\n          else if (typeof object.fromEventNumber === 'object')\n            message.fromEventNumber = new $util.LongBits(\n              object.fromEventNumber.low >>> 0,\n              object.fromEventNumber.high >>> 0\n            ).toNumber()\n        if (object.maxCount != null) message.maxCount = object.maxCount | 0\n        if (object.resolveLinkTos != null) message.resolveLinkTos = Boolean(object.resolveLinkTos)\n        if (object.requireMaster != null) message.requireMaster = Boolean(object.requireMaster)\n        return message\n      }\n\n      /**\n       * Creates a plain object from a ReadStreamEvents message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.ReadStreamEvents\n       * @static\n       * @param {eventstore.proto.ReadStreamEvents} message ReadStreamEvents\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      ReadStreamEvents.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.defaults) {\n          object.eventStreamId = ''\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.fromEventNumber =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.fromEventNumber = options.longs === String ? '0' : 0\n          object.maxCount = 0\n          object.resolveLinkTos = false\n          object.requireMaster = false\n        }\n        if (message.eventStreamId != null && message.hasOwnProperty('eventStreamId'))\n          object.eventStreamId = message.eventStreamId\n        if (message.fromEventNumber != null && message.hasOwnProperty('fromEventNumber'))\n          if (typeof message.fromEventNumber === 'number')\n            object.fromEventNumber =\n              options.longs === String ? String(message.fromEventNumber) : message.fromEventNumber\n          else\n            object.fromEventNumber =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.fromEventNumber)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.fromEventNumber.low >>> 0,\n                    message.fromEventNumber.high >>> 0\n                  ).toNumber()\n                : message.fromEventNumber\n        if (message.maxCount != null && message.hasOwnProperty('maxCount'))\n          object.maxCount = message.maxCount\n        if (message.resolveLinkTos != null && message.hasOwnProperty('resolveLinkTos'))\n          object.resolveLinkTos = message.resolveLinkTos\n        if (message.requireMaster != null && message.hasOwnProperty('requireMaster'))\n          object.requireMaster = message.requireMaster\n        return object\n      }\n\n      /**\n       * Converts this ReadStreamEvents to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.ReadStreamEvents\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      ReadStreamEvents.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      return ReadStreamEvents\n    })()\n\n    proto.ReadStreamEventsCompleted = (function() {\n      /**\n       * Properties of a ReadStreamEventsCompleted.\n       * @memberof eventstore.proto\n       * @interface IReadStreamEventsCompleted\n       * @property {Array.<eventstore.proto.IResolvedIndexedEvent>|null} [events] ReadStreamEventsCompleted events\n       * @property {eventstore.proto.ReadStreamEventsCompleted.ReadStreamResult} result ReadStreamEventsCompleted result\n       * @property {number|Long} nextEventNumber ReadStreamEventsCompleted nextEventNumber\n       * @property {number|Long} lastEventNumber ReadStreamEventsCompleted lastEventNumber\n       * @property {boolean} isEndOfStream ReadStreamEventsCompleted isEndOfStream\n       * @property {number|Long} lastCommitPosition ReadStreamEventsCompleted lastCommitPosition\n       * @property {string|null} [error] ReadStreamEventsCompleted error\n       */\n\n      /**\n       * Constructs a new ReadStreamEventsCompleted.\n       * @memberof eventstore.proto\n       * @classdesc Represents a ReadStreamEventsCompleted.\n       * @implements IReadStreamEventsCompleted\n       * @constructor\n       * @param {eventstore.proto.IReadStreamEventsCompleted=} [properties] Properties to set\n       */\n      function ReadStreamEventsCompleted(properties) {\n        this.events = []\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * ReadStreamEventsCompleted events.\n       * @member {Array.<eventstore.proto.IResolvedIndexedEvent>} events\n       * @memberof eventstore.proto.ReadStreamEventsCompleted\n       * @instance\n       */\n      ReadStreamEventsCompleted.prototype.events = $util.emptyArray\n\n      /**\n       * ReadStreamEventsCompleted result.\n       * @member {eventstore.proto.ReadStreamEventsCompleted.ReadStreamResult} result\n       * @memberof eventstore.proto.ReadStreamEventsCompleted\n       * @instance\n       */\n      ReadStreamEventsCompleted.prototype.result = 0\n\n      /**\n       * ReadStreamEventsCompleted nextEventNumber.\n       * @member {number|Long} nextEventNumber\n       * @memberof eventstore.proto.ReadStreamEventsCompleted\n       * @instance\n       */\n      ReadStreamEventsCompleted.prototype.nextEventNumber = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0\n\n      /**\n       * ReadStreamEventsCompleted lastEventNumber.\n       * @member {number|Long} lastEventNumber\n       * @memberof eventstore.proto.ReadStreamEventsCompleted\n       * @instance\n       */\n      ReadStreamEventsCompleted.prototype.lastEventNumber = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0\n\n      /**\n       * ReadStreamEventsCompleted isEndOfStream.\n       * @member {boolean} isEndOfStream\n       * @memberof eventstore.proto.ReadStreamEventsCompleted\n       * @instance\n       */\n      ReadStreamEventsCompleted.prototype.isEndOfStream = false\n\n      /**\n       * ReadStreamEventsCompleted lastCommitPosition.\n       * @member {number|Long} lastCommitPosition\n       * @memberof eventstore.proto.ReadStreamEventsCompleted\n       * @instance\n       */\n      ReadStreamEventsCompleted.prototype.lastCommitPosition = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0\n\n      /**\n       * ReadStreamEventsCompleted error.\n       * @member {string} error\n       * @memberof eventstore.proto.ReadStreamEventsCompleted\n       * @instance\n       */\n      ReadStreamEventsCompleted.prototype.error = ''\n\n      /**\n       * Creates a new ReadStreamEventsCompleted instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.ReadStreamEventsCompleted\n       * @static\n       * @param {eventstore.proto.IReadStreamEventsCompleted=} [properties] Properties to set\n       * @returns {eventstore.proto.ReadStreamEventsCompleted} ReadStreamEventsCompleted instance\n       */\n      ReadStreamEventsCompleted.create = function create(properties) {\n        return new ReadStreamEventsCompleted(properties)\n      }\n\n      /**\n       * Encodes the specified ReadStreamEventsCompleted message. Does not implicitly {@link eventstore.proto.ReadStreamEventsCompleted.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.ReadStreamEventsCompleted\n       * @static\n       * @param {eventstore.proto.IReadStreamEventsCompleted} message ReadStreamEventsCompleted message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      ReadStreamEventsCompleted.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        if (message.events != null && message.events.length)\n          for (var i = 0; i < message.events.length; ++i)\n            $root.eventstore.proto.ResolvedIndexedEvent.encode(\n              message.events[i],\n              writer.uint32(/* id 1, wireType 2 =*/ 10).fork()\n            ).ldelim()\n        writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.result)\n        writer.uint32(/* id 3, wireType 0 =*/ 24).int64(message.nextEventNumber)\n        writer.uint32(/* id 4, wireType 0 =*/ 32).int64(message.lastEventNumber)\n        writer.uint32(/* id 5, wireType 0 =*/ 40).bool(message.isEndOfStream)\n        writer.uint32(/* id 6, wireType 0 =*/ 48).int64(message.lastCommitPosition)\n        if (message.error != null && message.hasOwnProperty('error'))\n          writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.error)\n        return writer\n      }\n\n      /**\n       * Encodes the specified ReadStreamEventsCompleted message, length delimited. Does not implicitly {@link eventstore.proto.ReadStreamEventsCompleted.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.ReadStreamEventsCompleted\n       * @static\n       * @param {eventstore.proto.IReadStreamEventsCompleted} message ReadStreamEventsCompleted message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      ReadStreamEventsCompleted.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes a ReadStreamEventsCompleted message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.ReadStreamEventsCompleted\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.ReadStreamEventsCompleted} ReadStreamEventsCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      ReadStreamEventsCompleted.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.ReadStreamEventsCompleted()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              if (!(message.events && message.events.length)) message.events = []\n              message.events.push(\n                $root.eventstore.proto.ResolvedIndexedEvent.decode(reader, reader.uint32())\n              )\n              break\n            case 2:\n              message.result = reader.int32()\n              break\n            case 3:\n              message.nextEventNumber = reader.int64()\n              break\n            case 4:\n              message.lastEventNumber = reader.int64()\n              break\n            case 5:\n              message.isEndOfStream = reader.bool()\n              break\n            case 6:\n              message.lastCommitPosition = reader.int64()\n              break\n            case 7:\n              message.error = reader.string()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        if (!message.hasOwnProperty('result'))\n          throw $util.ProtocolError(\"missing required 'result'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('nextEventNumber'))\n          throw $util.ProtocolError(\"missing required 'nextEventNumber'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('lastEventNumber'))\n          throw $util.ProtocolError(\"missing required 'lastEventNumber'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('isEndOfStream'))\n          throw $util.ProtocolError(\"missing required 'isEndOfStream'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('lastCommitPosition'))\n          throw $util.ProtocolError(\"missing required 'lastCommitPosition'\", {\n            instance: message\n          })\n        return message\n      }\n\n      /**\n       * Decodes a ReadStreamEventsCompleted message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.ReadStreamEventsCompleted\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.ReadStreamEventsCompleted} ReadStreamEventsCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      ReadStreamEventsCompleted.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies a ReadStreamEventsCompleted message.\n       * @function verify\n       * @memberof eventstore.proto.ReadStreamEventsCompleted\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      ReadStreamEventsCompleted.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        if (message.events != null && message.hasOwnProperty('events')) {\n          if (!Array.isArray(message.events)) return 'events: array expected'\n          for (var i = 0; i < message.events.length; ++i) {\n            var error = $root.eventstore.proto.ResolvedIndexedEvent.verify(message.events[i])\n            if (error) return 'events.' + error\n          }\n        }\n        switch (message.result) {\n          default:\n            return 'result: enum value expected'\n          case 0:\n          case 1:\n          case 2:\n          case 3:\n          case 4:\n          case 5:\n            break\n        }\n        if (\n          !$util.isInteger(message.nextEventNumber) &&\n          !(\n            message.nextEventNumber &&\n            $util.isInteger(message.nextEventNumber.low) &&\n            $util.isInteger(message.nextEventNumber.high)\n          )\n        )\n          return 'nextEventNumber: integer|Long expected'\n        if (\n          !$util.isInteger(message.lastEventNumber) &&\n          !(\n            message.lastEventNumber &&\n            $util.isInteger(message.lastEventNumber.low) &&\n            $util.isInteger(message.lastEventNumber.high)\n          )\n        )\n          return 'lastEventNumber: integer|Long expected'\n        if (typeof message.isEndOfStream !== 'boolean') return 'isEndOfStream: boolean expected'\n        if (\n          !$util.isInteger(message.lastCommitPosition) &&\n          !(\n            message.lastCommitPosition &&\n            $util.isInteger(message.lastCommitPosition.low) &&\n            $util.isInteger(message.lastCommitPosition.high)\n          )\n        )\n          return 'lastCommitPosition: integer|Long expected'\n        if (message.error != null && message.hasOwnProperty('error'))\n          if (!$util.isString(message.error)) return 'error: string expected'\n        return null\n      }\n\n      /**\n       * Creates a ReadStreamEventsCompleted message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.ReadStreamEventsCompleted\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.ReadStreamEventsCompleted} ReadStreamEventsCompleted\n       */\n      ReadStreamEventsCompleted.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.ReadStreamEventsCompleted) return object\n        var message = new $root.eventstore.proto.ReadStreamEventsCompleted()\n        if (object.events) {\n          if (!Array.isArray(object.events))\n            throw TypeError('.eventstore.proto.ReadStreamEventsCompleted.events: array expected')\n          message.events = []\n          for (var i = 0; i < object.events.length; ++i) {\n            if (typeof object.events[i] !== 'object')\n              throw TypeError('.eventstore.proto.ReadStreamEventsCompleted.events: object expected')\n            message.events[i] = $root.eventstore.proto.ResolvedIndexedEvent.fromObject(\n              object.events[i]\n            )\n          }\n        }\n        switch (object.result) {\n          case 'Success':\n          case 0:\n            message.result = 0\n            break\n          case 'NoStream':\n          case 1:\n            message.result = 1\n            break\n          case 'StreamDeleted':\n          case 2:\n            message.result = 2\n            break\n          case 'NotModified':\n          case 3:\n            message.result = 3\n            break\n          case 'Error':\n          case 4:\n            message.result = 4\n            break\n          case 'AccessDenied':\n          case 5:\n            message.result = 5\n            break\n        }\n        if (object.nextEventNumber != null)\n          if ($util.Long)\n            (message.nextEventNumber = $util.Long.fromValue(\n              object.nextEventNumber\n            )).unsigned = false\n          else if (typeof object.nextEventNumber === 'string')\n            message.nextEventNumber = parseInt(object.nextEventNumber, 10)\n          else if (typeof object.nextEventNumber === 'number')\n            message.nextEventNumber = object.nextEventNumber\n          else if (typeof object.nextEventNumber === 'object')\n            message.nextEventNumber = new $util.LongBits(\n              object.nextEventNumber.low >>> 0,\n              object.nextEventNumber.high >>> 0\n            ).toNumber()\n        if (object.lastEventNumber != null)\n          if ($util.Long)\n            (message.lastEventNumber = $util.Long.fromValue(\n              object.lastEventNumber\n            )).unsigned = false\n          else if (typeof object.lastEventNumber === 'string')\n            message.lastEventNumber = parseInt(object.lastEventNumber, 10)\n          else if (typeof object.lastEventNumber === 'number')\n            message.lastEventNumber = object.lastEventNumber\n          else if (typeof object.lastEventNumber === 'object')\n            message.lastEventNumber = new $util.LongBits(\n              object.lastEventNumber.low >>> 0,\n              object.lastEventNumber.high >>> 0\n            ).toNumber()\n        if (object.isEndOfStream != null) message.isEndOfStream = Boolean(object.isEndOfStream)\n        if (object.lastCommitPosition != null)\n          if ($util.Long)\n            (message.lastCommitPosition = $util.Long.fromValue(\n              object.lastCommitPosition\n            )).unsigned = false\n          else if (typeof object.lastCommitPosition === 'string')\n            message.lastCommitPosition = parseInt(object.lastCommitPosition, 10)\n          else if (typeof object.lastCommitPosition === 'number')\n            message.lastCommitPosition = object.lastCommitPosition\n          else if (typeof object.lastCommitPosition === 'object')\n            message.lastCommitPosition = new $util.LongBits(\n              object.lastCommitPosition.low >>> 0,\n              object.lastCommitPosition.high >>> 0\n            ).toNumber()\n        if (object.error != null) message.error = String(object.error)\n        return message\n      }\n\n      /**\n       * Creates a plain object from a ReadStreamEventsCompleted message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.ReadStreamEventsCompleted\n       * @static\n       * @param {eventstore.proto.ReadStreamEventsCompleted} message ReadStreamEventsCompleted\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      ReadStreamEventsCompleted.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.arrays || options.defaults) object.events = []\n        if (options.defaults) {\n          object.result = options.enums === String ? 'Success' : 0\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.nextEventNumber =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.nextEventNumber = options.longs === String ? '0' : 0\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.lastEventNumber =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.lastEventNumber = options.longs === String ? '0' : 0\n          object.isEndOfStream = false\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.lastCommitPosition =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.lastCommitPosition = options.longs === String ? '0' : 0\n          object.error = ''\n        }\n        if (message.events && message.events.length) {\n          object.events = []\n          for (var j = 0; j < message.events.length; ++j)\n            object.events[j] = $root.eventstore.proto.ResolvedIndexedEvent.toObject(\n              message.events[j],\n              options\n            )\n        }\n        if (message.result != null && message.hasOwnProperty('result'))\n          object.result =\n            options.enums === String\n              ? $root.eventstore.proto.ReadStreamEventsCompleted.ReadStreamResult[message.result]\n              : message.result\n        if (message.nextEventNumber != null && message.hasOwnProperty('nextEventNumber'))\n          if (typeof message.nextEventNumber === 'number')\n            object.nextEventNumber =\n              options.longs === String ? String(message.nextEventNumber) : message.nextEventNumber\n          else\n            object.nextEventNumber =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.nextEventNumber)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.nextEventNumber.low >>> 0,\n                    message.nextEventNumber.high >>> 0\n                  ).toNumber()\n                : message.nextEventNumber\n        if (message.lastEventNumber != null && message.hasOwnProperty('lastEventNumber'))\n          if (typeof message.lastEventNumber === 'number')\n            object.lastEventNumber =\n              options.longs === String ? String(message.lastEventNumber) : message.lastEventNumber\n          else\n            object.lastEventNumber =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.lastEventNumber)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.lastEventNumber.low >>> 0,\n                    message.lastEventNumber.high >>> 0\n                  ).toNumber()\n                : message.lastEventNumber\n        if (message.isEndOfStream != null && message.hasOwnProperty('isEndOfStream'))\n          object.isEndOfStream = message.isEndOfStream\n        if (message.lastCommitPosition != null && message.hasOwnProperty('lastCommitPosition'))\n          if (typeof message.lastCommitPosition === 'number')\n            object.lastCommitPosition =\n              options.longs === String\n                ? String(message.lastCommitPosition)\n                : message.lastCommitPosition\n          else\n            object.lastCommitPosition =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.lastCommitPosition)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.lastCommitPosition.low >>> 0,\n                    message.lastCommitPosition.high >>> 0\n                  ).toNumber()\n                : message.lastCommitPosition\n        if (message.error != null && message.hasOwnProperty('error')) object.error = message.error\n        return object\n      }\n\n      /**\n       * Converts this ReadStreamEventsCompleted to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.ReadStreamEventsCompleted\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      ReadStreamEventsCompleted.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      /**\n       * ReadStreamResult enum.\n       * @name eventstore.proto.ReadStreamEventsCompleted.ReadStreamResult\n       * @enum {string}\n       * @property {number} Success=0 Success value\n       * @property {number} NoStream=1 NoStream value\n       * @property {number} StreamDeleted=2 StreamDeleted value\n       * @property {number} NotModified=3 NotModified value\n       * @property {number} Error=4 Error value\n       * @property {number} AccessDenied=5 AccessDenied value\n       */\n      ReadStreamEventsCompleted.ReadStreamResult = (function() {\n        var valuesById = {},\n          values = Object.create(valuesById)\n        values[(valuesById[0] = 'Success')] = 0\n        values[(valuesById[1] = 'NoStream')] = 1\n        values[(valuesById[2] = 'StreamDeleted')] = 2\n        values[(valuesById[3] = 'NotModified')] = 3\n        values[(valuesById[4] = 'Error')] = 4\n        values[(valuesById[5] = 'AccessDenied')] = 5\n        return values\n      })()\n\n      return ReadStreamEventsCompleted\n    })()\n\n    proto.ReadAllEvents = (function() {\n      /**\n       * Properties of a ReadAllEvents.\n       * @memberof eventstore.proto\n       * @interface IReadAllEvents\n       * @property {number|Long} commitPosition ReadAllEvents commitPosition\n       * @property {number|Long} preparePosition ReadAllEvents preparePosition\n       * @property {number} maxCount ReadAllEvents maxCount\n       * @property {boolean} resolveLinkTos ReadAllEvents resolveLinkTos\n       * @property {boolean} requireMaster ReadAllEvents requireMaster\n       */\n\n      /**\n       * Constructs a new ReadAllEvents.\n       * @memberof eventstore.proto\n       * @classdesc Represents a ReadAllEvents.\n       * @implements IReadAllEvents\n       * @constructor\n       * @param {eventstore.proto.IReadAllEvents=} [properties] Properties to set\n       */\n      function ReadAllEvents(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * ReadAllEvents commitPosition.\n       * @member {number|Long} commitPosition\n       * @memberof eventstore.proto.ReadAllEvents\n       * @instance\n       */\n      ReadAllEvents.prototype.commitPosition = $util.Long ? $util.Long.fromBits(0, 0, false) : 0\n\n      /**\n       * ReadAllEvents preparePosition.\n       * @member {number|Long} preparePosition\n       * @memberof eventstore.proto.ReadAllEvents\n       * @instance\n       */\n      ReadAllEvents.prototype.preparePosition = $util.Long ? $util.Long.fromBits(0, 0, false) : 0\n\n      /**\n       * ReadAllEvents maxCount.\n       * @member {number} maxCount\n       * @memberof eventstore.proto.ReadAllEvents\n       * @instance\n       */\n      ReadAllEvents.prototype.maxCount = 0\n\n      /**\n       * ReadAllEvents resolveLinkTos.\n       * @member {boolean} resolveLinkTos\n       * @memberof eventstore.proto.ReadAllEvents\n       * @instance\n       */\n      ReadAllEvents.prototype.resolveLinkTos = false\n\n      /**\n       * ReadAllEvents requireMaster.\n       * @member {boolean} requireMaster\n       * @memberof eventstore.proto.ReadAllEvents\n       * @instance\n       */\n      ReadAllEvents.prototype.requireMaster = false\n\n      /**\n       * Creates a new ReadAllEvents instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.ReadAllEvents\n       * @static\n       * @param {eventstore.proto.IReadAllEvents=} [properties] Properties to set\n       * @returns {eventstore.proto.ReadAllEvents} ReadAllEvents instance\n       */\n      ReadAllEvents.create = function create(properties) {\n        return new ReadAllEvents(properties)\n      }\n\n      /**\n       * Encodes the specified ReadAllEvents message. Does not implicitly {@link eventstore.proto.ReadAllEvents.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.ReadAllEvents\n       * @static\n       * @param {eventstore.proto.IReadAllEvents} message ReadAllEvents message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      ReadAllEvents.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.commitPosition)\n        writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.preparePosition)\n        writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.maxCount)\n        writer.uint32(/* id 4, wireType 0 =*/ 32).bool(message.resolveLinkTos)\n        writer.uint32(/* id 5, wireType 0 =*/ 40).bool(message.requireMaster)\n        return writer\n      }\n\n      /**\n       * Encodes the specified ReadAllEvents message, length delimited. Does not implicitly {@link eventstore.proto.ReadAllEvents.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.ReadAllEvents\n       * @static\n       * @param {eventstore.proto.IReadAllEvents} message ReadAllEvents message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      ReadAllEvents.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes a ReadAllEvents message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.ReadAllEvents\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.ReadAllEvents} ReadAllEvents\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      ReadAllEvents.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.ReadAllEvents()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              message.commitPosition = reader.int64()\n              break\n            case 2:\n              message.preparePosition = reader.int64()\n              break\n            case 3:\n              message.maxCount = reader.int32()\n              break\n            case 4:\n              message.resolveLinkTos = reader.bool()\n              break\n            case 5:\n              message.requireMaster = reader.bool()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        if (!message.hasOwnProperty('commitPosition'))\n          throw $util.ProtocolError(\"missing required 'commitPosition'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('preparePosition'))\n          throw $util.ProtocolError(\"missing required 'preparePosition'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('maxCount'))\n          throw $util.ProtocolError(\"missing required 'maxCount'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('resolveLinkTos'))\n          throw $util.ProtocolError(\"missing required 'resolveLinkTos'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('requireMaster'))\n          throw $util.ProtocolError(\"missing required 'requireMaster'\", {\n            instance: message\n          })\n        return message\n      }\n\n      /**\n       * Decodes a ReadAllEvents message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.ReadAllEvents\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.ReadAllEvents} ReadAllEvents\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      ReadAllEvents.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies a ReadAllEvents message.\n       * @function verify\n       * @memberof eventstore.proto.ReadAllEvents\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      ReadAllEvents.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        if (\n          !$util.isInteger(message.commitPosition) &&\n          !(\n            message.commitPosition &&\n            $util.isInteger(message.commitPosition.low) &&\n            $util.isInteger(message.commitPosition.high)\n          )\n        )\n          return 'commitPosition: integer|Long expected'\n        if (\n          !$util.isInteger(message.preparePosition) &&\n          !(\n            message.preparePosition &&\n            $util.isInteger(message.preparePosition.low) &&\n            $util.isInteger(message.preparePosition.high)\n          )\n        )\n          return 'preparePosition: integer|Long expected'\n        if (!$util.isInteger(message.maxCount)) return 'maxCount: integer expected'\n        if (typeof message.resolveLinkTos !== 'boolean') return 'resolveLinkTos: boolean expected'\n        if (typeof message.requireMaster !== 'boolean') return 'requireMaster: boolean expected'\n        return null\n      }\n\n      /**\n       * Creates a ReadAllEvents message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.ReadAllEvents\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.ReadAllEvents} ReadAllEvents\n       */\n      ReadAllEvents.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.ReadAllEvents) return object\n        var message = new $root.eventstore.proto.ReadAllEvents()\n        if (object.commitPosition != null)\n          if ($util.Long)\n            (message.commitPosition = $util.Long.fromValue(object.commitPosition)).unsigned = false\n          else if (typeof object.commitPosition === 'string')\n            message.commitPosition = parseInt(object.commitPosition, 10)\n          else if (typeof object.commitPosition === 'number')\n            message.commitPosition = object.commitPosition\n          else if (typeof object.commitPosition === 'object')\n            message.commitPosition = new $util.LongBits(\n              object.commitPosition.low >>> 0,\n              object.commitPosition.high >>> 0\n            ).toNumber()\n        if (object.preparePosition != null)\n          if ($util.Long)\n            (message.preparePosition = $util.Long.fromValue(\n              object.preparePosition\n            )).unsigned = false\n          else if (typeof object.preparePosition === 'string')\n            message.preparePosition = parseInt(object.preparePosition, 10)\n          else if (typeof object.preparePosition === 'number')\n            message.preparePosition = object.preparePosition\n          else if (typeof object.preparePosition === 'object')\n            message.preparePosition = new $util.LongBits(\n              object.preparePosition.low >>> 0,\n              object.preparePosition.high >>> 0\n            ).toNumber()\n        if (object.maxCount != null) message.maxCount = object.maxCount | 0\n        if (object.resolveLinkTos != null) message.resolveLinkTos = Boolean(object.resolveLinkTos)\n        if (object.requireMaster != null) message.requireMaster = Boolean(object.requireMaster)\n        return message\n      }\n\n      /**\n       * Creates a plain object from a ReadAllEvents message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.ReadAllEvents\n       * @static\n       * @param {eventstore.proto.ReadAllEvents} message ReadAllEvents\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      ReadAllEvents.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.defaults) {\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.commitPosition =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.commitPosition = options.longs === String ? '0' : 0\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.preparePosition =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.preparePosition = options.longs === String ? '0' : 0\n          object.maxCount = 0\n          object.resolveLinkTos = false\n          object.requireMaster = false\n        }\n        if (message.commitPosition != null && message.hasOwnProperty('commitPosition'))\n          if (typeof message.commitPosition === 'number')\n            object.commitPosition =\n              options.longs === String ? String(message.commitPosition) : message.commitPosition\n          else\n            object.commitPosition =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.commitPosition)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.commitPosition.low >>> 0,\n                    message.commitPosition.high >>> 0\n                  ).toNumber()\n                : message.commitPosition\n        if (message.preparePosition != null && message.hasOwnProperty('preparePosition'))\n          if (typeof message.preparePosition === 'number')\n            object.preparePosition =\n              options.longs === String ? String(message.preparePosition) : message.preparePosition\n          else\n            object.preparePosition =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.preparePosition)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.preparePosition.low >>> 0,\n                    message.preparePosition.high >>> 0\n                  ).toNumber()\n                : message.preparePosition\n        if (message.maxCount != null && message.hasOwnProperty('maxCount'))\n          object.maxCount = message.maxCount\n        if (message.resolveLinkTos != null && message.hasOwnProperty('resolveLinkTos'))\n          object.resolveLinkTos = message.resolveLinkTos\n        if (message.requireMaster != null && message.hasOwnProperty('requireMaster'))\n          object.requireMaster = message.requireMaster\n        return object\n      }\n\n      /**\n       * Converts this ReadAllEvents to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.ReadAllEvents\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      ReadAllEvents.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      return ReadAllEvents\n    })()\n\n    proto.ReadAllEventsCompleted = (function() {\n      /**\n       * Properties of a ReadAllEventsCompleted.\n       * @memberof eventstore.proto\n       * @interface IReadAllEventsCompleted\n       * @property {number|Long} commitPosition ReadAllEventsCompleted commitPosition\n       * @property {number|Long} preparePosition ReadAllEventsCompleted preparePosition\n       * @property {Array.<eventstore.proto.IResolvedEvent>|null} [events] ReadAllEventsCompleted events\n       * @property {number|Long} nextCommitPosition ReadAllEventsCompleted nextCommitPosition\n       * @property {number|Long} nextPreparePosition ReadAllEventsCompleted nextPreparePosition\n       * @property {eventstore.proto.ReadAllEventsCompleted.ReadAllResult|null} [result] ReadAllEventsCompleted result\n       * @property {string|null} [error] ReadAllEventsCompleted error\n       */\n\n      /**\n       * Constructs a new ReadAllEventsCompleted.\n       * @memberof eventstore.proto\n       * @classdesc Represents a ReadAllEventsCompleted.\n       * @implements IReadAllEventsCompleted\n       * @constructor\n       * @param {eventstore.proto.IReadAllEventsCompleted=} [properties] Properties to set\n       */\n      function ReadAllEventsCompleted(properties) {\n        this.events = []\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * ReadAllEventsCompleted commitPosition.\n       * @member {number|Long} commitPosition\n       * @memberof eventstore.proto.ReadAllEventsCompleted\n       * @instance\n       */\n      ReadAllEventsCompleted.prototype.commitPosition = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0\n\n      /**\n       * ReadAllEventsCompleted preparePosition.\n       * @member {number|Long} preparePosition\n       * @memberof eventstore.proto.ReadAllEventsCompleted\n       * @instance\n       */\n      ReadAllEventsCompleted.prototype.preparePosition = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0\n\n      /**\n       * ReadAllEventsCompleted events.\n       * @member {Array.<eventstore.proto.IResolvedEvent>} events\n       * @memberof eventstore.proto.ReadAllEventsCompleted\n       * @instance\n       */\n      ReadAllEventsCompleted.prototype.events = $util.emptyArray\n\n      /**\n       * ReadAllEventsCompleted nextCommitPosition.\n       * @member {number|Long} nextCommitPosition\n       * @memberof eventstore.proto.ReadAllEventsCompleted\n       * @instance\n       */\n      ReadAllEventsCompleted.prototype.nextCommitPosition = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0\n\n      /**\n       * ReadAllEventsCompleted nextPreparePosition.\n       * @member {number|Long} nextPreparePosition\n       * @memberof eventstore.proto.ReadAllEventsCompleted\n       * @instance\n       */\n      ReadAllEventsCompleted.prototype.nextPreparePosition = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0\n\n      /**\n       * ReadAllEventsCompleted result.\n       * @member {eventstore.proto.ReadAllEventsCompleted.ReadAllResult} result\n       * @memberof eventstore.proto.ReadAllEventsCompleted\n       * @instance\n       */\n      ReadAllEventsCompleted.prototype.result = 0\n\n      /**\n       * ReadAllEventsCompleted error.\n       * @member {string} error\n       * @memberof eventstore.proto.ReadAllEventsCompleted\n       * @instance\n       */\n      ReadAllEventsCompleted.prototype.error = ''\n\n      /**\n       * Creates a new ReadAllEventsCompleted instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.ReadAllEventsCompleted\n       * @static\n       * @param {eventstore.proto.IReadAllEventsCompleted=} [properties] Properties to set\n       * @returns {eventstore.proto.ReadAllEventsCompleted} ReadAllEventsCompleted instance\n       */\n      ReadAllEventsCompleted.create = function create(properties) {\n        return new ReadAllEventsCompleted(properties)\n      }\n\n      /**\n       * Encodes the specified ReadAllEventsCompleted message. Does not implicitly {@link eventstore.proto.ReadAllEventsCompleted.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.ReadAllEventsCompleted\n       * @static\n       * @param {eventstore.proto.IReadAllEventsCompleted} message ReadAllEventsCompleted message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      ReadAllEventsCompleted.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.commitPosition)\n        writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.preparePosition)\n        if (message.events != null && message.events.length)\n          for (var i = 0; i < message.events.length; ++i)\n            $root.eventstore.proto.ResolvedEvent.encode(\n              message.events[i],\n              writer.uint32(/* id 3, wireType 2 =*/ 26).fork()\n            ).ldelim()\n        writer.uint32(/* id 4, wireType 0 =*/ 32).int64(message.nextCommitPosition)\n        writer.uint32(/* id 5, wireType 0 =*/ 40).int64(message.nextPreparePosition)\n        if (message.result != null && message.hasOwnProperty('result'))\n          writer.uint32(/* id 6, wireType 0 =*/ 48).int32(message.result)\n        if (message.error != null && message.hasOwnProperty('error'))\n          writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.error)\n        return writer\n      }\n\n      /**\n       * Encodes the specified ReadAllEventsCompleted message, length delimited. Does not implicitly {@link eventstore.proto.ReadAllEventsCompleted.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.ReadAllEventsCompleted\n       * @static\n       * @param {eventstore.proto.IReadAllEventsCompleted} message ReadAllEventsCompleted message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      ReadAllEventsCompleted.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes a ReadAllEventsCompleted message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.ReadAllEventsCompleted\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.ReadAllEventsCompleted} ReadAllEventsCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      ReadAllEventsCompleted.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.ReadAllEventsCompleted()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              message.commitPosition = reader.int64()\n              break\n            case 2:\n              message.preparePosition = reader.int64()\n              break\n            case 3:\n              if (!(message.events && message.events.length)) message.events = []\n              message.events.push(\n                $root.eventstore.proto.ResolvedEvent.decode(reader, reader.uint32())\n              )\n              break\n            case 4:\n              message.nextCommitPosition = reader.int64()\n              break\n            case 5:\n              message.nextPreparePosition = reader.int64()\n              break\n            case 6:\n              message.result = reader.int32()\n              break\n            case 7:\n              message.error = reader.string()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        if (!message.hasOwnProperty('commitPosition'))\n          throw $util.ProtocolError(\"missing required 'commitPosition'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('preparePosition'))\n          throw $util.ProtocolError(\"missing required 'preparePosition'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('nextCommitPosition'))\n          throw $util.ProtocolError(\"missing required 'nextCommitPosition'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('nextPreparePosition'))\n          throw $util.ProtocolError(\"missing required 'nextPreparePosition'\", {\n            instance: message\n          })\n        return message\n      }\n\n      /**\n       * Decodes a ReadAllEventsCompleted message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.ReadAllEventsCompleted\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.ReadAllEventsCompleted} ReadAllEventsCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      ReadAllEventsCompleted.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies a ReadAllEventsCompleted message.\n       * @function verify\n       * @memberof eventstore.proto.ReadAllEventsCompleted\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      ReadAllEventsCompleted.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        if (\n          !$util.isInteger(message.commitPosition) &&\n          !(\n            message.commitPosition &&\n            $util.isInteger(message.commitPosition.low) &&\n            $util.isInteger(message.commitPosition.high)\n          )\n        )\n          return 'commitPosition: integer|Long expected'\n        if (\n          !$util.isInteger(message.preparePosition) &&\n          !(\n            message.preparePosition &&\n            $util.isInteger(message.preparePosition.low) &&\n            $util.isInteger(message.preparePosition.high)\n          )\n        )\n          return 'preparePosition: integer|Long expected'\n        if (message.events != null && message.hasOwnProperty('events')) {\n          if (!Array.isArray(message.events)) return 'events: array expected'\n          for (var i = 0; i < message.events.length; ++i) {\n            var error = $root.eventstore.proto.ResolvedEvent.verify(message.events[i])\n            if (error) return 'events.' + error\n          }\n        }\n        if (\n          !$util.isInteger(message.nextCommitPosition) &&\n          !(\n            message.nextCommitPosition &&\n            $util.isInteger(message.nextCommitPosition.low) &&\n            $util.isInteger(message.nextCommitPosition.high)\n          )\n        )\n          return 'nextCommitPosition: integer|Long expected'\n        if (\n          !$util.isInteger(message.nextPreparePosition) &&\n          !(\n            message.nextPreparePosition &&\n            $util.isInteger(message.nextPreparePosition.low) &&\n            $util.isInteger(message.nextPreparePosition.high)\n          )\n        )\n          return 'nextPreparePosition: integer|Long expected'\n        if (message.result != null && message.hasOwnProperty('result'))\n          switch (message.result) {\n            default:\n              return 'result: enum value expected'\n            case 0:\n            case 1:\n            case 2:\n            case 3:\n              break\n          }\n        if (message.error != null && message.hasOwnProperty('error'))\n          if (!$util.isString(message.error)) return 'error: string expected'\n        return null\n      }\n\n      /**\n       * Creates a ReadAllEventsCompleted message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.ReadAllEventsCompleted\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.ReadAllEventsCompleted} ReadAllEventsCompleted\n       */\n      ReadAllEventsCompleted.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.ReadAllEventsCompleted) return object\n        var message = new $root.eventstore.proto.ReadAllEventsCompleted()\n        if (object.commitPosition != null)\n          if ($util.Long)\n            (message.commitPosition = $util.Long.fromValue(object.commitPosition)).unsigned = false\n          else if (typeof object.commitPosition === 'string')\n            message.commitPosition = parseInt(object.commitPosition, 10)\n          else if (typeof object.commitPosition === 'number')\n            message.commitPosition = object.commitPosition\n          else if (typeof object.commitPosition === 'object')\n            message.commitPosition = new $util.LongBits(\n              object.commitPosition.low >>> 0,\n              object.commitPosition.high >>> 0\n            ).toNumber()\n        if (object.preparePosition != null)\n          if ($util.Long)\n            (message.preparePosition = $util.Long.fromValue(\n              object.preparePosition\n            )).unsigned = false\n          else if (typeof object.preparePosition === 'string')\n            message.preparePosition = parseInt(object.preparePosition, 10)\n          else if (typeof object.preparePosition === 'number')\n            message.preparePosition = object.preparePosition\n          else if (typeof object.preparePosition === 'object')\n            message.preparePosition = new $util.LongBits(\n              object.preparePosition.low >>> 0,\n              object.preparePosition.high >>> 0\n            ).toNumber()\n        if (object.events) {\n          if (!Array.isArray(object.events))\n            throw TypeError('.eventstore.proto.ReadAllEventsCompleted.events: array expected')\n          message.events = []\n          for (var i = 0; i < object.events.length; ++i) {\n            if (typeof object.events[i] !== 'object')\n              throw TypeError('.eventstore.proto.ReadAllEventsCompleted.events: object expected')\n            message.events[i] = $root.eventstore.proto.ResolvedEvent.fromObject(object.events[i])\n          }\n        }\n        if (object.nextCommitPosition != null)\n          if ($util.Long)\n            (message.nextCommitPosition = $util.Long.fromValue(\n              object.nextCommitPosition\n            )).unsigned = false\n          else if (typeof object.nextCommitPosition === 'string')\n            message.nextCommitPosition = parseInt(object.nextCommitPosition, 10)\n          else if (typeof object.nextCommitPosition === 'number')\n            message.nextCommitPosition = object.nextCommitPosition\n          else if (typeof object.nextCommitPosition === 'object')\n            message.nextCommitPosition = new $util.LongBits(\n              object.nextCommitPosition.low >>> 0,\n              object.nextCommitPosition.high >>> 0\n            ).toNumber()\n        if (object.nextPreparePosition != null)\n          if ($util.Long)\n            (message.nextPreparePosition = $util.Long.fromValue(\n              object.nextPreparePosition\n            )).unsigned = false\n          else if (typeof object.nextPreparePosition === 'string')\n            message.nextPreparePosition = parseInt(object.nextPreparePosition, 10)\n          else if (typeof object.nextPreparePosition === 'number')\n            message.nextPreparePosition = object.nextPreparePosition\n          else if (typeof object.nextPreparePosition === 'object')\n            message.nextPreparePosition = new $util.LongBits(\n              object.nextPreparePosition.low >>> 0,\n              object.nextPreparePosition.high >>> 0\n            ).toNumber()\n        switch (object.result) {\n          case 'Success':\n          case 0:\n            message.result = 0\n            break\n          case 'NotModified':\n          case 1:\n            message.result = 1\n            break\n          case 'Error':\n          case 2:\n            message.result = 2\n            break\n          case 'AccessDenied':\n          case 3:\n            message.result = 3\n            break\n        }\n        if (object.error != null) message.error = String(object.error)\n        return message\n      }\n\n      /**\n       * Creates a plain object from a ReadAllEventsCompleted message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.ReadAllEventsCompleted\n       * @static\n       * @param {eventstore.proto.ReadAllEventsCompleted} message ReadAllEventsCompleted\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      ReadAllEventsCompleted.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.arrays || options.defaults) object.events = []\n        if (options.defaults) {\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.commitPosition =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.commitPosition = options.longs === String ? '0' : 0\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.preparePosition =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.preparePosition = options.longs === String ? '0' : 0\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.nextCommitPosition =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.nextCommitPosition = options.longs === String ? '0' : 0\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.nextPreparePosition =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.nextPreparePosition = options.longs === String ? '0' : 0\n          object.result = options.enums === String ? 'Success' : 0\n          object.error = ''\n        }\n        if (message.commitPosition != null && message.hasOwnProperty('commitPosition'))\n          if (typeof message.commitPosition === 'number')\n            object.commitPosition =\n              options.longs === String ? String(message.commitPosition) : message.commitPosition\n          else\n            object.commitPosition =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.commitPosition)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.commitPosition.low >>> 0,\n                    message.commitPosition.high >>> 0\n                  ).toNumber()\n                : message.commitPosition\n        if (message.preparePosition != null && message.hasOwnProperty('preparePosition'))\n          if (typeof message.preparePosition === 'number')\n            object.preparePosition =\n              options.longs === String ? String(message.preparePosition) : message.preparePosition\n          else\n            object.preparePosition =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.preparePosition)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.preparePosition.low >>> 0,\n                    message.preparePosition.high >>> 0\n                  ).toNumber()\n                : message.preparePosition\n        if (message.events && message.events.length) {\n          object.events = []\n          for (var j = 0; j < message.events.length; ++j)\n            object.events[j] = $root.eventstore.proto.ResolvedEvent.toObject(\n              message.events[j],\n              options\n            )\n        }\n        if (message.nextCommitPosition != null && message.hasOwnProperty('nextCommitPosition'))\n          if (typeof message.nextCommitPosition === 'number')\n            object.nextCommitPosition =\n              options.longs === String\n                ? String(message.nextCommitPosition)\n                : message.nextCommitPosition\n          else\n            object.nextCommitPosition =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.nextCommitPosition)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.nextCommitPosition.low >>> 0,\n                    message.nextCommitPosition.high >>> 0\n                  ).toNumber()\n                : message.nextCommitPosition\n        if (message.nextPreparePosition != null && message.hasOwnProperty('nextPreparePosition'))\n          if (typeof message.nextPreparePosition === 'number')\n            object.nextPreparePosition =\n              options.longs === String\n                ? String(message.nextPreparePosition)\n                : message.nextPreparePosition\n          else\n            object.nextPreparePosition =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.nextPreparePosition)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.nextPreparePosition.low >>> 0,\n                    message.nextPreparePosition.high >>> 0\n                  ).toNumber()\n                : message.nextPreparePosition\n        if (message.result != null && message.hasOwnProperty('result'))\n          object.result =\n            options.enums === String\n              ? $root.eventstore.proto.ReadAllEventsCompleted.ReadAllResult[message.result]\n              : message.result\n        if (message.error != null && message.hasOwnProperty('error')) object.error = message.error\n        return object\n      }\n\n      /**\n       * Converts this ReadAllEventsCompleted to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.ReadAllEventsCompleted\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      ReadAllEventsCompleted.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      /**\n       * ReadAllResult enum.\n       * @name eventstore.proto.ReadAllEventsCompleted.ReadAllResult\n       * @enum {string}\n       * @property {number} Success=0 Success value\n       * @property {number} NotModified=1 NotModified value\n       * @property {number} Error=2 Error value\n       * @property {number} AccessDenied=3 AccessDenied value\n       */\n      ReadAllEventsCompleted.ReadAllResult = (function() {\n        var valuesById = {},\n          values = Object.create(valuesById)\n        values[(valuesById[0] = 'Success')] = 0\n        values[(valuesById[1] = 'NotModified')] = 1\n        values[(valuesById[2] = 'Error')] = 2\n        values[(valuesById[3] = 'AccessDenied')] = 3\n        return values\n      })()\n\n      return ReadAllEventsCompleted\n    })()\n\n    proto.CreatePersistentSubscription = (function() {\n      /**\n       * Properties of a CreatePersistentSubscription.\n       * @memberof eventstore.proto\n       * @interface ICreatePersistentSubscription\n       * @property {string} subscriptionGroupName CreatePersistentSubscription subscriptionGroupName\n       * @property {string} eventStreamId CreatePersistentSubscription eventStreamId\n       * @property {boolean} resolveLinkTos CreatePersistentSubscription resolveLinkTos\n       * @property {number|Long} startFrom CreatePersistentSubscription startFrom\n       * @property {number} messageTimeoutMilliseconds CreatePersistentSubscription messageTimeoutMilliseconds\n       * @property {boolean} recordStatistics CreatePersistentSubscription recordStatistics\n       * @property {number} liveBufferSize CreatePersistentSubscription liveBufferSize\n       * @property {number} readBatchSize CreatePersistentSubscription readBatchSize\n       * @property {number} bufferSize CreatePersistentSubscription bufferSize\n       * @property {number} maxRetryCount CreatePersistentSubscription maxRetryCount\n       * @property {boolean} preferRoundRobin CreatePersistentSubscription preferRoundRobin\n       * @property {number} checkpointAfterTime CreatePersistentSubscription checkpointAfterTime\n       * @property {number} checkpointMaxCount CreatePersistentSubscription checkpointMaxCount\n       * @property {number} checkpointMinCount CreatePersistentSubscription checkpointMinCount\n       * @property {number} subscriberMaxCount CreatePersistentSubscription subscriberMaxCount\n       * @property {string|null} [namedConsumerStrategy] CreatePersistentSubscription namedConsumerStrategy\n       */\n\n      /**\n       * Constructs a new CreatePersistentSubscription.\n       * @memberof eventstore.proto\n       * @classdesc Represents a CreatePersistentSubscription.\n       * @implements ICreatePersistentSubscription\n       * @constructor\n       * @param {eventstore.proto.ICreatePersistentSubscription=} [properties] Properties to set\n       */\n      function CreatePersistentSubscription(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * CreatePersistentSubscription subscriptionGroupName.\n       * @member {string} subscriptionGroupName\n       * @memberof eventstore.proto.CreatePersistentSubscription\n       * @instance\n       */\n      CreatePersistentSubscription.prototype.subscriptionGroupName = ''\n\n      /**\n       * CreatePersistentSubscription eventStreamId.\n       * @member {string} eventStreamId\n       * @memberof eventstore.proto.CreatePersistentSubscription\n       * @instance\n       */\n      CreatePersistentSubscription.prototype.eventStreamId = ''\n\n      /**\n       * CreatePersistentSubscription resolveLinkTos.\n       * @member {boolean} resolveLinkTos\n       * @memberof eventstore.proto.CreatePersistentSubscription\n       * @instance\n       */\n      CreatePersistentSubscription.prototype.resolveLinkTos = false\n\n      /**\n       * CreatePersistentSubscription startFrom.\n       * @member {number|Long} startFrom\n       * @memberof eventstore.proto.CreatePersistentSubscription\n       * @instance\n       */\n      CreatePersistentSubscription.prototype.startFrom = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0\n\n      /**\n       * CreatePersistentSubscription messageTimeoutMilliseconds.\n       * @member {number} messageTimeoutMilliseconds\n       * @memberof eventstore.proto.CreatePersistentSubscription\n       * @instance\n       */\n      CreatePersistentSubscription.prototype.messageTimeoutMilliseconds = 0\n\n      /**\n       * CreatePersistentSubscription recordStatistics.\n       * @member {boolean} recordStatistics\n       * @memberof eventstore.proto.CreatePersistentSubscription\n       * @instance\n       */\n      CreatePersistentSubscription.prototype.recordStatistics = false\n\n      /**\n       * CreatePersistentSubscription liveBufferSize.\n       * @member {number} liveBufferSize\n       * @memberof eventstore.proto.CreatePersistentSubscription\n       * @instance\n       */\n      CreatePersistentSubscription.prototype.liveBufferSize = 0\n\n      /**\n       * CreatePersistentSubscription readBatchSize.\n       * @member {number} readBatchSize\n       * @memberof eventstore.proto.CreatePersistentSubscription\n       * @instance\n       */\n      CreatePersistentSubscription.prototype.readBatchSize = 0\n\n      /**\n       * CreatePersistentSubscription bufferSize.\n       * @member {number} bufferSize\n       * @memberof eventstore.proto.CreatePersistentSubscription\n       * @instance\n       */\n      CreatePersistentSubscription.prototype.bufferSize = 0\n\n      /**\n       * CreatePersistentSubscription maxRetryCount.\n       * @member {number} maxRetryCount\n       * @memberof eventstore.proto.CreatePersistentSubscription\n       * @instance\n       */\n      CreatePersistentSubscription.prototype.maxRetryCount = 0\n\n      /**\n       * CreatePersistentSubscription preferRoundRobin.\n       * @member {boolean} preferRoundRobin\n       * @memberof eventstore.proto.CreatePersistentSubscription\n       * @instance\n       */\n      CreatePersistentSubscription.prototype.preferRoundRobin = false\n\n      /**\n       * CreatePersistentSubscription checkpointAfterTime.\n       * @member {number} checkpointAfterTime\n       * @memberof eventstore.proto.CreatePersistentSubscription\n       * @instance\n       */\n      CreatePersistentSubscription.prototype.checkpointAfterTime = 0\n\n      /**\n       * CreatePersistentSubscription checkpointMaxCount.\n       * @member {number} checkpointMaxCount\n       * @memberof eventstore.proto.CreatePersistentSubscription\n       * @instance\n       */\n      CreatePersistentSubscription.prototype.checkpointMaxCount = 0\n\n      /**\n       * CreatePersistentSubscription checkpointMinCount.\n       * @member {number} checkpointMinCount\n       * @memberof eventstore.proto.CreatePersistentSubscription\n       * @instance\n       */\n      CreatePersistentSubscription.prototype.checkpointMinCount = 0\n\n      /**\n       * CreatePersistentSubscription subscriberMaxCount.\n       * @member {number} subscriberMaxCount\n       * @memberof eventstore.proto.CreatePersistentSubscription\n       * @instance\n       */\n      CreatePersistentSubscription.prototype.subscriberMaxCount = 0\n\n      /**\n       * CreatePersistentSubscription namedConsumerStrategy.\n       * @member {string} namedConsumerStrategy\n       * @memberof eventstore.proto.CreatePersistentSubscription\n       * @instance\n       */\n      CreatePersistentSubscription.prototype.namedConsumerStrategy = ''\n\n      /**\n       * Creates a new CreatePersistentSubscription instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.CreatePersistentSubscription\n       * @static\n       * @param {eventstore.proto.ICreatePersistentSubscription=} [properties] Properties to set\n       * @returns {eventstore.proto.CreatePersistentSubscription} CreatePersistentSubscription instance\n       */\n      CreatePersistentSubscription.create = function create(properties) {\n        return new CreatePersistentSubscription(properties)\n      }\n\n      /**\n       * Encodes the specified CreatePersistentSubscription message. Does not implicitly {@link eventstore.proto.CreatePersistentSubscription.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.CreatePersistentSubscription\n       * @static\n       * @param {eventstore.proto.ICreatePersistentSubscription} message CreatePersistentSubscription message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      CreatePersistentSubscription.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.subscriptionGroupName)\n        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.eventStreamId)\n        writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.resolveLinkTos)\n        writer.uint32(/* id 4, wireType 0 =*/ 32).int64(message.startFrom)\n        writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.messageTimeoutMilliseconds)\n        writer.uint32(/* id 6, wireType 0 =*/ 48).bool(message.recordStatistics)\n        writer.uint32(/* id 7, wireType 0 =*/ 56).int32(message.liveBufferSize)\n        writer.uint32(/* id 8, wireType 0 =*/ 64).int32(message.readBatchSize)\n        writer.uint32(/* id 9, wireType 0 =*/ 72).int32(message.bufferSize)\n        writer.uint32(/* id 10, wireType 0 =*/ 80).int32(message.maxRetryCount)\n        writer.uint32(/* id 11, wireType 0 =*/ 88).bool(message.preferRoundRobin)\n        writer.uint32(/* id 12, wireType 0 =*/ 96).int32(message.checkpointAfterTime)\n        writer.uint32(/* id 13, wireType 0 =*/ 104).int32(message.checkpointMaxCount)\n        writer.uint32(/* id 14, wireType 0 =*/ 112).int32(message.checkpointMinCount)\n        writer.uint32(/* id 15, wireType 0 =*/ 120).int32(message.subscriberMaxCount)\n        if (\n          message.namedConsumerStrategy != null &&\n          message.hasOwnProperty('namedConsumerStrategy')\n        )\n          writer.uint32(/* id 16, wireType 2 =*/ 130).string(message.namedConsumerStrategy)\n        return writer\n      }\n\n      /**\n       * Encodes the specified CreatePersistentSubscription message, length delimited. Does not implicitly {@link eventstore.proto.CreatePersistentSubscription.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.CreatePersistentSubscription\n       * @static\n       * @param {eventstore.proto.ICreatePersistentSubscription} message CreatePersistentSubscription message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      CreatePersistentSubscription.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes a CreatePersistentSubscription message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.CreatePersistentSubscription\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.CreatePersistentSubscription} CreatePersistentSubscription\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      CreatePersistentSubscription.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.CreatePersistentSubscription()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              message.subscriptionGroupName = reader.string()\n              break\n            case 2:\n              message.eventStreamId = reader.string()\n              break\n            case 3:\n              message.resolveLinkTos = reader.bool()\n              break\n            case 4:\n              message.startFrom = reader.int64()\n              break\n            case 5:\n              message.messageTimeoutMilliseconds = reader.int32()\n              break\n            case 6:\n              message.recordStatistics = reader.bool()\n              break\n            case 7:\n              message.liveBufferSize = reader.int32()\n              break\n            case 8:\n              message.readBatchSize = reader.int32()\n              break\n            case 9:\n              message.bufferSize = reader.int32()\n              break\n            case 10:\n              message.maxRetryCount = reader.int32()\n              break\n            case 11:\n              message.preferRoundRobin = reader.bool()\n              break\n            case 12:\n              message.checkpointAfterTime = reader.int32()\n              break\n            case 13:\n              message.checkpointMaxCount = reader.int32()\n              break\n            case 14:\n              message.checkpointMinCount = reader.int32()\n              break\n            case 15:\n              message.subscriberMaxCount = reader.int32()\n              break\n            case 16:\n              message.namedConsumerStrategy = reader.string()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        if (!message.hasOwnProperty('subscriptionGroupName'))\n          throw $util.ProtocolError(\"missing required 'subscriptionGroupName'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('eventStreamId'))\n          throw $util.ProtocolError(\"missing required 'eventStreamId'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('resolveLinkTos'))\n          throw $util.ProtocolError(\"missing required 'resolveLinkTos'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('startFrom'))\n          throw $util.ProtocolError(\"missing required 'startFrom'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('messageTimeoutMilliseconds'))\n          throw $util.ProtocolError(\"missing required 'messageTimeoutMilliseconds'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('recordStatistics'))\n          throw $util.ProtocolError(\"missing required 'recordStatistics'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('liveBufferSize'))\n          throw $util.ProtocolError(\"missing required 'liveBufferSize'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('readBatchSize'))\n          throw $util.ProtocolError(\"missing required 'readBatchSize'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('bufferSize'))\n          throw $util.ProtocolError(\"missing required 'bufferSize'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('maxRetryCount'))\n          throw $util.ProtocolError(\"missing required 'maxRetryCount'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('preferRoundRobin'))\n          throw $util.ProtocolError(\"missing required 'preferRoundRobin'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('checkpointAfterTime'))\n          throw $util.ProtocolError(\"missing required 'checkpointAfterTime'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('checkpointMaxCount'))\n          throw $util.ProtocolError(\"missing required 'checkpointMaxCount'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('checkpointMinCount'))\n          throw $util.ProtocolError(\"missing required 'checkpointMinCount'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('subscriberMaxCount'))\n          throw $util.ProtocolError(\"missing required 'subscriberMaxCount'\", {\n            instance: message\n          })\n        return message\n      }\n\n      /**\n       * Decodes a CreatePersistentSubscription message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.CreatePersistentSubscription\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.CreatePersistentSubscription} CreatePersistentSubscription\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      CreatePersistentSubscription.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies a CreatePersistentSubscription message.\n       * @function verify\n       * @memberof eventstore.proto.CreatePersistentSubscription\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      CreatePersistentSubscription.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        if (!$util.isString(message.subscriptionGroupName))\n          return 'subscriptionGroupName: string expected'\n        if (!$util.isString(message.eventStreamId)) return 'eventStreamId: string expected'\n        if (typeof message.resolveLinkTos !== 'boolean') return 'resolveLinkTos: boolean expected'\n        if (\n          !$util.isInteger(message.startFrom) &&\n          !(\n            message.startFrom &&\n            $util.isInteger(message.startFrom.low) &&\n            $util.isInteger(message.startFrom.high)\n          )\n        )\n          return 'startFrom: integer|Long expected'\n        if (!$util.isInteger(message.messageTimeoutMilliseconds))\n          return 'messageTimeoutMilliseconds: integer expected'\n        if (typeof message.recordStatistics !== 'boolean')\n          return 'recordStatistics: boolean expected'\n        if (!$util.isInteger(message.liveBufferSize)) return 'liveBufferSize: integer expected'\n        if (!$util.isInteger(message.readBatchSize)) return 'readBatchSize: integer expected'\n        if (!$util.isInteger(message.bufferSize)) return 'bufferSize: integer expected'\n        if (!$util.isInteger(message.maxRetryCount)) return 'maxRetryCount: integer expected'\n        if (typeof message.preferRoundRobin !== 'boolean')\n          return 'preferRoundRobin: boolean expected'\n        if (!$util.isInteger(message.checkpointAfterTime))\n          return 'checkpointAfterTime: integer expected'\n        if (!$util.isInteger(message.checkpointMaxCount))\n          return 'checkpointMaxCount: integer expected'\n        if (!$util.isInteger(message.checkpointMinCount))\n          return 'checkpointMinCount: integer expected'\n        if (!$util.isInteger(message.subscriberMaxCount))\n          return 'subscriberMaxCount: integer expected'\n        if (\n          message.namedConsumerStrategy != null &&\n          message.hasOwnProperty('namedConsumerStrategy')\n        )\n          if (!$util.isString(message.namedConsumerStrategy))\n            return 'namedConsumerStrategy: string expected'\n        return null\n      }\n\n      /**\n       * Creates a CreatePersistentSubscription message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.CreatePersistentSubscription\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.CreatePersistentSubscription} CreatePersistentSubscription\n       */\n      CreatePersistentSubscription.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.CreatePersistentSubscription) return object\n        var message = new $root.eventstore.proto.CreatePersistentSubscription()\n        if (object.subscriptionGroupName != null)\n          message.subscriptionGroupName = String(object.subscriptionGroupName)\n        if (object.eventStreamId != null) message.eventStreamId = String(object.eventStreamId)\n        if (object.resolveLinkTos != null) message.resolveLinkTos = Boolean(object.resolveLinkTos)\n        if (object.startFrom != null)\n          if ($util.Long)\n            (message.startFrom = $util.Long.fromValue(object.startFrom)).unsigned = false\n          else if (typeof object.startFrom === 'string')\n            message.startFrom = parseInt(object.startFrom, 10)\n          else if (typeof object.startFrom === 'number') message.startFrom = object.startFrom\n          else if (typeof object.startFrom === 'object')\n            message.startFrom = new $util.LongBits(\n              object.startFrom.low >>> 0,\n              object.startFrom.high >>> 0\n            ).toNumber()\n        if (object.messageTimeoutMilliseconds != null)\n          message.messageTimeoutMilliseconds = object.messageTimeoutMilliseconds | 0\n        if (object.recordStatistics != null)\n          message.recordStatistics = Boolean(object.recordStatistics)\n        if (object.liveBufferSize != null) message.liveBufferSize = object.liveBufferSize | 0\n        if (object.readBatchSize != null) message.readBatchSize = object.readBatchSize | 0\n        if (object.bufferSize != null) message.bufferSize = object.bufferSize | 0\n        if (object.maxRetryCount != null) message.maxRetryCount = object.maxRetryCount | 0\n        if (object.preferRoundRobin != null)\n          message.preferRoundRobin = Boolean(object.preferRoundRobin)\n        if (object.checkpointAfterTime != null)\n          message.checkpointAfterTime = object.checkpointAfterTime | 0\n        if (object.checkpointMaxCount != null)\n          message.checkpointMaxCount = object.checkpointMaxCount | 0\n        if (object.checkpointMinCount != null)\n          message.checkpointMinCount = object.checkpointMinCount | 0\n        if (object.subscriberMaxCount != null)\n          message.subscriberMaxCount = object.subscriberMaxCount | 0\n        if (object.namedConsumerStrategy != null)\n          message.namedConsumerStrategy = String(object.namedConsumerStrategy)\n        return message\n      }\n\n      /**\n       * Creates a plain object from a CreatePersistentSubscription message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.CreatePersistentSubscription\n       * @static\n       * @param {eventstore.proto.CreatePersistentSubscription} message CreatePersistentSubscription\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      CreatePersistentSubscription.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.defaults) {\n          object.subscriptionGroupName = ''\n          object.eventStreamId = ''\n          object.resolveLinkTos = false\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.startFrom =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.startFrom = options.longs === String ? '0' : 0\n          object.messageTimeoutMilliseconds = 0\n          object.recordStatistics = false\n          object.liveBufferSize = 0\n          object.readBatchSize = 0\n          object.bufferSize = 0\n          object.maxRetryCount = 0\n          object.preferRoundRobin = false\n          object.checkpointAfterTime = 0\n          object.checkpointMaxCount = 0\n          object.checkpointMinCount = 0\n          object.subscriberMaxCount = 0\n          object.namedConsumerStrategy = ''\n        }\n        if (\n          message.subscriptionGroupName != null &&\n          message.hasOwnProperty('subscriptionGroupName')\n        )\n          object.subscriptionGroupName = message.subscriptionGroupName\n        if (message.eventStreamId != null && message.hasOwnProperty('eventStreamId'))\n          object.eventStreamId = message.eventStreamId\n        if (message.resolveLinkTos != null && message.hasOwnProperty('resolveLinkTos'))\n          object.resolveLinkTos = message.resolveLinkTos\n        if (message.startFrom != null && message.hasOwnProperty('startFrom'))\n          if (typeof message.startFrom === 'number')\n            object.startFrom =\n              options.longs === String ? String(message.startFrom) : message.startFrom\n          else\n            object.startFrom =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.startFrom)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.startFrom.low >>> 0,\n                    message.startFrom.high >>> 0\n                  ).toNumber()\n                : message.startFrom\n        if (\n          message.messageTimeoutMilliseconds != null &&\n          message.hasOwnProperty('messageTimeoutMilliseconds')\n        )\n          object.messageTimeoutMilliseconds = message.messageTimeoutMilliseconds\n        if (message.recordStatistics != null && message.hasOwnProperty('recordStatistics'))\n          object.recordStatistics = message.recordStatistics\n        if (message.liveBufferSize != null && message.hasOwnProperty('liveBufferSize'))\n          object.liveBufferSize = message.liveBufferSize\n        if (message.readBatchSize != null && message.hasOwnProperty('readBatchSize'))\n          object.readBatchSize = message.readBatchSize\n        if (message.bufferSize != null && message.hasOwnProperty('bufferSize'))\n          object.bufferSize = message.bufferSize\n        if (message.maxRetryCount != null && message.hasOwnProperty('maxRetryCount'))\n          object.maxRetryCount = message.maxRetryCount\n        if (message.preferRoundRobin != null && message.hasOwnProperty('preferRoundRobin'))\n          object.preferRoundRobin = message.preferRoundRobin\n        if (message.checkpointAfterTime != null && message.hasOwnProperty('checkpointAfterTime'))\n          object.checkpointAfterTime = message.checkpointAfterTime\n        if (message.checkpointMaxCount != null && message.hasOwnProperty('checkpointMaxCount'))\n          object.checkpointMaxCount = message.checkpointMaxCount\n        if (message.checkpointMinCount != null && message.hasOwnProperty('checkpointMinCount'))\n          object.checkpointMinCount = message.checkpointMinCount\n        if (message.subscriberMaxCount != null && message.hasOwnProperty('subscriberMaxCount'))\n          object.subscriberMaxCount = message.subscriberMaxCount\n        if (\n          message.namedConsumerStrategy != null &&\n          message.hasOwnProperty('namedConsumerStrategy')\n        )\n          object.namedConsumerStrategy = message.namedConsumerStrategy\n        return object\n      }\n\n      /**\n       * Converts this CreatePersistentSubscription to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.CreatePersistentSubscription\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      CreatePersistentSubscription.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      return CreatePersistentSubscription\n    })()\n\n    proto.DeletePersistentSubscription = (function() {\n      /**\n       * Properties of a DeletePersistentSubscription.\n       * @memberof eventstore.proto\n       * @interface IDeletePersistentSubscription\n       * @property {string} subscriptionGroupName DeletePersistentSubscription subscriptionGroupName\n       * @property {string} eventStreamId DeletePersistentSubscription eventStreamId\n       */\n\n      /**\n       * Constructs a new DeletePersistentSubscription.\n       * @memberof eventstore.proto\n       * @classdesc Represents a DeletePersistentSubscription.\n       * @implements IDeletePersistentSubscription\n       * @constructor\n       * @param {eventstore.proto.IDeletePersistentSubscription=} [properties] Properties to set\n       */\n      function DeletePersistentSubscription(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * DeletePersistentSubscription subscriptionGroupName.\n       * @member {string} subscriptionGroupName\n       * @memberof eventstore.proto.DeletePersistentSubscription\n       * @instance\n       */\n      DeletePersistentSubscription.prototype.subscriptionGroupName = ''\n\n      /**\n       * DeletePersistentSubscription eventStreamId.\n       * @member {string} eventStreamId\n       * @memberof eventstore.proto.DeletePersistentSubscription\n       * @instance\n       */\n      DeletePersistentSubscription.prototype.eventStreamId = ''\n\n      /**\n       * Creates a new DeletePersistentSubscription instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.DeletePersistentSubscription\n       * @static\n       * @param {eventstore.proto.IDeletePersistentSubscription=} [properties] Properties to set\n       * @returns {eventstore.proto.DeletePersistentSubscription} DeletePersistentSubscription instance\n       */\n      DeletePersistentSubscription.create = function create(properties) {\n        return new DeletePersistentSubscription(properties)\n      }\n\n      /**\n       * Encodes the specified DeletePersistentSubscription message. Does not implicitly {@link eventstore.proto.DeletePersistentSubscription.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.DeletePersistentSubscription\n       * @static\n       * @param {eventstore.proto.IDeletePersistentSubscription} message DeletePersistentSubscription message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      DeletePersistentSubscription.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.subscriptionGroupName)\n        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.eventStreamId)\n        return writer\n      }\n\n      /**\n       * Encodes the specified DeletePersistentSubscription message, length delimited. Does not implicitly {@link eventstore.proto.DeletePersistentSubscription.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.DeletePersistentSubscription\n       * @static\n       * @param {eventstore.proto.IDeletePersistentSubscription} message DeletePersistentSubscription message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      DeletePersistentSubscription.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes a DeletePersistentSubscription message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.DeletePersistentSubscription\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.DeletePersistentSubscription} DeletePersistentSubscription\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      DeletePersistentSubscription.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.DeletePersistentSubscription()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              message.subscriptionGroupName = reader.string()\n              break\n            case 2:\n              message.eventStreamId = reader.string()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        if (!message.hasOwnProperty('subscriptionGroupName'))\n          throw $util.ProtocolError(\"missing required 'subscriptionGroupName'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('eventStreamId'))\n          throw $util.ProtocolError(\"missing required 'eventStreamId'\", {\n            instance: message\n          })\n        return message\n      }\n\n      /**\n       * Decodes a DeletePersistentSubscription message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.DeletePersistentSubscription\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.DeletePersistentSubscription} DeletePersistentSubscription\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      DeletePersistentSubscription.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies a DeletePersistentSubscription message.\n       * @function verify\n       * @memberof eventstore.proto.DeletePersistentSubscription\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      DeletePersistentSubscription.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        if (!$util.isString(message.subscriptionGroupName))\n          return 'subscriptionGroupName: string expected'\n        if (!$util.isString(message.eventStreamId)) return 'eventStreamId: string expected'\n        return null\n      }\n\n      /**\n       * Creates a DeletePersistentSubscription message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.DeletePersistentSubscription\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.DeletePersistentSubscription} DeletePersistentSubscription\n       */\n      DeletePersistentSubscription.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.DeletePersistentSubscription) return object\n        var message = new $root.eventstore.proto.DeletePersistentSubscription()\n        if (object.subscriptionGroupName != null)\n          message.subscriptionGroupName = String(object.subscriptionGroupName)\n        if (object.eventStreamId != null) message.eventStreamId = String(object.eventStreamId)\n        return message\n      }\n\n      /**\n       * Creates a plain object from a DeletePersistentSubscription message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.DeletePersistentSubscription\n       * @static\n       * @param {eventstore.proto.DeletePersistentSubscription} message DeletePersistentSubscription\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      DeletePersistentSubscription.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.defaults) {\n          object.subscriptionGroupName = ''\n          object.eventStreamId = ''\n        }\n        if (\n          message.subscriptionGroupName != null &&\n          message.hasOwnProperty('subscriptionGroupName')\n        )\n          object.subscriptionGroupName = message.subscriptionGroupName\n        if (message.eventStreamId != null && message.hasOwnProperty('eventStreamId'))\n          object.eventStreamId = message.eventStreamId\n        return object\n      }\n\n      /**\n       * Converts this DeletePersistentSubscription to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.DeletePersistentSubscription\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      DeletePersistentSubscription.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      return DeletePersistentSubscription\n    })()\n\n    proto.UpdatePersistentSubscription = (function() {\n      /**\n       * Properties of an UpdatePersistentSubscription.\n       * @memberof eventstore.proto\n       * @interface IUpdatePersistentSubscription\n       * @property {string} subscriptionGroupName UpdatePersistentSubscription subscriptionGroupName\n       * @property {string} eventStreamId UpdatePersistentSubscription eventStreamId\n       * @property {boolean} resolveLinkTos UpdatePersistentSubscription resolveLinkTos\n       * @property {number|Long} startFrom UpdatePersistentSubscription startFrom\n       * @property {number} messageTimeoutMilliseconds UpdatePersistentSubscription messageTimeoutMilliseconds\n       * @property {boolean} recordStatistics UpdatePersistentSubscription recordStatistics\n       * @property {number} liveBufferSize UpdatePersistentSubscription liveBufferSize\n       * @property {number} readBatchSize UpdatePersistentSubscription readBatchSize\n       * @property {number} bufferSize UpdatePersistentSubscription bufferSize\n       * @property {number} maxRetryCount UpdatePersistentSubscription maxRetryCount\n       * @property {boolean} preferRoundRobin UpdatePersistentSubscription preferRoundRobin\n       * @property {number} checkpointAfterTime UpdatePersistentSubscription checkpointAfterTime\n       * @property {number} checkpointMaxCount UpdatePersistentSubscription checkpointMaxCount\n       * @property {number} checkpointMinCount UpdatePersistentSubscription checkpointMinCount\n       * @property {number} subscriberMaxCount UpdatePersistentSubscription subscriberMaxCount\n       * @property {string|null} [namedConsumerStrategy] UpdatePersistentSubscription namedConsumerStrategy\n       */\n\n      /**\n       * Constructs a new UpdatePersistentSubscription.\n       * @memberof eventstore.proto\n       * @classdesc Represents an UpdatePersistentSubscription.\n       * @implements IUpdatePersistentSubscription\n       * @constructor\n       * @param {eventstore.proto.IUpdatePersistentSubscription=} [properties] Properties to set\n       */\n      function UpdatePersistentSubscription(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * UpdatePersistentSubscription subscriptionGroupName.\n       * @member {string} subscriptionGroupName\n       * @memberof eventstore.proto.UpdatePersistentSubscription\n       * @instance\n       */\n      UpdatePersistentSubscription.prototype.subscriptionGroupName = ''\n\n      /**\n       * UpdatePersistentSubscription eventStreamId.\n       * @member {string} eventStreamId\n       * @memberof eventstore.proto.UpdatePersistentSubscription\n       * @instance\n       */\n      UpdatePersistentSubscription.prototype.eventStreamId = ''\n\n      /**\n       * UpdatePersistentSubscription resolveLinkTos.\n       * @member {boolean} resolveLinkTos\n       * @memberof eventstore.proto.UpdatePersistentSubscription\n       * @instance\n       */\n      UpdatePersistentSubscription.prototype.resolveLinkTos = false\n\n      /**\n       * UpdatePersistentSubscription startFrom.\n       * @member {number|Long} startFrom\n       * @memberof eventstore.proto.UpdatePersistentSubscription\n       * @instance\n       */\n      UpdatePersistentSubscription.prototype.startFrom = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0\n\n      /**\n       * UpdatePersistentSubscription messageTimeoutMilliseconds.\n       * @member {number} messageTimeoutMilliseconds\n       * @memberof eventstore.proto.UpdatePersistentSubscription\n       * @instance\n       */\n      UpdatePersistentSubscription.prototype.messageTimeoutMilliseconds = 0\n\n      /**\n       * UpdatePersistentSubscription recordStatistics.\n       * @member {boolean} recordStatistics\n       * @memberof eventstore.proto.UpdatePersistentSubscription\n       * @instance\n       */\n      UpdatePersistentSubscription.prototype.recordStatistics = false\n\n      /**\n       * UpdatePersistentSubscription liveBufferSize.\n       * @member {number} liveBufferSize\n       * @memberof eventstore.proto.UpdatePersistentSubscription\n       * @instance\n       */\n      UpdatePersistentSubscription.prototype.liveBufferSize = 0\n\n      /**\n       * UpdatePersistentSubscription readBatchSize.\n       * @member {number} readBatchSize\n       * @memberof eventstore.proto.UpdatePersistentSubscription\n       * @instance\n       */\n      UpdatePersistentSubscription.prototype.readBatchSize = 0\n\n      /**\n       * UpdatePersistentSubscription bufferSize.\n       * @member {number} bufferSize\n       * @memberof eventstore.proto.UpdatePersistentSubscription\n       * @instance\n       */\n      UpdatePersistentSubscription.prototype.bufferSize = 0\n\n      /**\n       * UpdatePersistentSubscription maxRetryCount.\n       * @member {number} maxRetryCount\n       * @memberof eventstore.proto.UpdatePersistentSubscription\n       * @instance\n       */\n      UpdatePersistentSubscription.prototype.maxRetryCount = 0\n\n      /**\n       * UpdatePersistentSubscription preferRoundRobin.\n       * @member {boolean} preferRoundRobin\n       * @memberof eventstore.proto.UpdatePersistentSubscription\n       * @instance\n       */\n      UpdatePersistentSubscription.prototype.preferRoundRobin = false\n\n      /**\n       * UpdatePersistentSubscription checkpointAfterTime.\n       * @member {number} checkpointAfterTime\n       * @memberof eventstore.proto.UpdatePersistentSubscription\n       * @instance\n       */\n      UpdatePersistentSubscription.prototype.checkpointAfterTime = 0\n\n      /**\n       * UpdatePersistentSubscription checkpointMaxCount.\n       * @member {number} checkpointMaxCount\n       * @memberof eventstore.proto.UpdatePersistentSubscription\n       * @instance\n       */\n      UpdatePersistentSubscription.prototype.checkpointMaxCount = 0\n\n      /**\n       * UpdatePersistentSubscription checkpointMinCount.\n       * @member {number} checkpointMinCount\n       * @memberof eventstore.proto.UpdatePersistentSubscription\n       * @instance\n       */\n      UpdatePersistentSubscription.prototype.checkpointMinCount = 0\n\n      /**\n       * UpdatePersistentSubscription subscriberMaxCount.\n       * @member {number} subscriberMaxCount\n       * @memberof eventstore.proto.UpdatePersistentSubscription\n       * @instance\n       */\n      UpdatePersistentSubscription.prototype.subscriberMaxCount = 0\n\n      /**\n       * UpdatePersistentSubscription namedConsumerStrategy.\n       * @member {string} namedConsumerStrategy\n       * @memberof eventstore.proto.UpdatePersistentSubscription\n       * @instance\n       */\n      UpdatePersistentSubscription.prototype.namedConsumerStrategy = ''\n\n      /**\n       * Creates a new UpdatePersistentSubscription instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.UpdatePersistentSubscription\n       * @static\n       * @param {eventstore.proto.IUpdatePersistentSubscription=} [properties] Properties to set\n       * @returns {eventstore.proto.UpdatePersistentSubscription} UpdatePersistentSubscription instance\n       */\n      UpdatePersistentSubscription.create = function create(properties) {\n        return new UpdatePersistentSubscription(properties)\n      }\n\n      /**\n       * Encodes the specified UpdatePersistentSubscription message. Does not implicitly {@link eventstore.proto.UpdatePersistentSubscription.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.UpdatePersistentSubscription\n       * @static\n       * @param {eventstore.proto.IUpdatePersistentSubscription} message UpdatePersistentSubscription message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      UpdatePersistentSubscription.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.subscriptionGroupName)\n        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.eventStreamId)\n        writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.resolveLinkTos)\n        writer.uint32(/* id 4, wireType 0 =*/ 32).int64(message.startFrom)\n        writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.messageTimeoutMilliseconds)\n        writer.uint32(/* id 6, wireType 0 =*/ 48).bool(message.recordStatistics)\n        writer.uint32(/* id 7, wireType 0 =*/ 56).int32(message.liveBufferSize)\n        writer.uint32(/* id 8, wireType 0 =*/ 64).int32(message.readBatchSize)\n        writer.uint32(/* id 9, wireType 0 =*/ 72).int32(message.bufferSize)\n        writer.uint32(/* id 10, wireType 0 =*/ 80).int32(message.maxRetryCount)\n        writer.uint32(/* id 11, wireType 0 =*/ 88).bool(message.preferRoundRobin)\n        writer.uint32(/* id 12, wireType 0 =*/ 96).int32(message.checkpointAfterTime)\n        writer.uint32(/* id 13, wireType 0 =*/ 104).int32(message.checkpointMaxCount)\n        writer.uint32(/* id 14, wireType 0 =*/ 112).int32(message.checkpointMinCount)\n        writer.uint32(/* id 15, wireType 0 =*/ 120).int32(message.subscriberMaxCount)\n        if (\n          message.namedConsumerStrategy != null &&\n          message.hasOwnProperty('namedConsumerStrategy')\n        )\n          writer.uint32(/* id 16, wireType 2 =*/ 130).string(message.namedConsumerStrategy)\n        return writer\n      }\n\n      /**\n       * Encodes the specified UpdatePersistentSubscription message, length delimited. Does not implicitly {@link eventstore.proto.UpdatePersistentSubscription.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.UpdatePersistentSubscription\n       * @static\n       * @param {eventstore.proto.IUpdatePersistentSubscription} message UpdatePersistentSubscription message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      UpdatePersistentSubscription.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes an UpdatePersistentSubscription message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.UpdatePersistentSubscription\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.UpdatePersistentSubscription} UpdatePersistentSubscription\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      UpdatePersistentSubscription.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.UpdatePersistentSubscription()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              message.subscriptionGroupName = reader.string()\n              break\n            case 2:\n              message.eventStreamId = reader.string()\n              break\n            case 3:\n              message.resolveLinkTos = reader.bool()\n              break\n            case 4:\n              message.startFrom = reader.int64()\n              break\n            case 5:\n              message.messageTimeoutMilliseconds = reader.int32()\n              break\n            case 6:\n              message.recordStatistics = reader.bool()\n              break\n            case 7:\n              message.liveBufferSize = reader.int32()\n              break\n            case 8:\n              message.readBatchSize = reader.int32()\n              break\n            case 9:\n              message.bufferSize = reader.int32()\n              break\n            case 10:\n              message.maxRetryCount = reader.int32()\n              break\n            case 11:\n              message.preferRoundRobin = reader.bool()\n              break\n            case 12:\n              message.checkpointAfterTime = reader.int32()\n              break\n            case 13:\n              message.checkpointMaxCount = reader.int32()\n              break\n            case 14:\n              message.checkpointMinCount = reader.int32()\n              break\n            case 15:\n              message.subscriberMaxCount = reader.int32()\n              break\n            case 16:\n              message.namedConsumerStrategy = reader.string()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        if (!message.hasOwnProperty('subscriptionGroupName'))\n          throw $util.ProtocolError(\"missing required 'subscriptionGroupName'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('eventStreamId'))\n          throw $util.ProtocolError(\"missing required 'eventStreamId'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('resolveLinkTos'))\n          throw $util.ProtocolError(\"missing required 'resolveLinkTos'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('startFrom'))\n          throw $util.ProtocolError(\"missing required 'startFrom'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('messageTimeoutMilliseconds'))\n          throw $util.ProtocolError(\"missing required 'messageTimeoutMilliseconds'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('recordStatistics'))\n          throw $util.ProtocolError(\"missing required 'recordStatistics'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('liveBufferSize'))\n          throw $util.ProtocolError(\"missing required 'liveBufferSize'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('readBatchSize'))\n          throw $util.ProtocolError(\"missing required 'readBatchSize'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('bufferSize'))\n          throw $util.ProtocolError(\"missing required 'bufferSize'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('maxRetryCount'))\n          throw $util.ProtocolError(\"missing required 'maxRetryCount'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('preferRoundRobin'))\n          throw $util.ProtocolError(\"missing required 'preferRoundRobin'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('checkpointAfterTime'))\n          throw $util.ProtocolError(\"missing required 'checkpointAfterTime'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('checkpointMaxCount'))\n          throw $util.ProtocolError(\"missing required 'checkpointMaxCount'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('checkpointMinCount'))\n          throw $util.ProtocolError(\"missing required 'checkpointMinCount'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('subscriberMaxCount'))\n          throw $util.ProtocolError(\"missing required 'subscriberMaxCount'\", {\n            instance: message\n          })\n        return message\n      }\n\n      /**\n       * Decodes an UpdatePersistentSubscription message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.UpdatePersistentSubscription\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.UpdatePersistentSubscription} UpdatePersistentSubscription\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      UpdatePersistentSubscription.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies an UpdatePersistentSubscription message.\n       * @function verify\n       * @memberof eventstore.proto.UpdatePersistentSubscription\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      UpdatePersistentSubscription.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        if (!$util.isString(message.subscriptionGroupName))\n          return 'subscriptionGroupName: string expected'\n        if (!$util.isString(message.eventStreamId)) return 'eventStreamId: string expected'\n        if (typeof message.resolveLinkTos !== 'boolean') return 'resolveLinkTos: boolean expected'\n        if (\n          !$util.isInteger(message.startFrom) &&\n          !(\n            message.startFrom &&\n            $util.isInteger(message.startFrom.low) &&\n            $util.isInteger(message.startFrom.high)\n          )\n        )\n          return 'startFrom: integer|Long expected'\n        if (!$util.isInteger(message.messageTimeoutMilliseconds))\n          return 'messageTimeoutMilliseconds: integer expected'\n        if (typeof message.recordStatistics !== 'boolean')\n          return 'recordStatistics: boolean expected'\n        if (!$util.isInteger(message.liveBufferSize)) return 'liveBufferSize: integer expected'\n        if (!$util.isInteger(message.readBatchSize)) return 'readBatchSize: integer expected'\n        if (!$util.isInteger(message.bufferSize)) return 'bufferSize: integer expected'\n        if (!$util.isInteger(message.maxRetryCount)) return 'maxRetryCount: integer expected'\n        if (typeof message.preferRoundRobin !== 'boolean')\n          return 'preferRoundRobin: boolean expected'\n        if (!$util.isInteger(message.checkpointAfterTime))\n          return 'checkpointAfterTime: integer expected'\n        if (!$util.isInteger(message.checkpointMaxCount))\n          return 'checkpointMaxCount: integer expected'\n        if (!$util.isInteger(message.checkpointMinCount))\n          return 'checkpointMinCount: integer expected'\n        if (!$util.isInteger(message.subscriberMaxCount))\n          return 'subscriberMaxCount: integer expected'\n        if (\n          message.namedConsumerStrategy != null &&\n          message.hasOwnProperty('namedConsumerStrategy')\n        )\n          if (!$util.isString(message.namedConsumerStrategy))\n            return 'namedConsumerStrategy: string expected'\n        return null\n      }\n\n      /**\n       * Creates an UpdatePersistentSubscription message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.UpdatePersistentSubscription\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.UpdatePersistentSubscription} UpdatePersistentSubscription\n       */\n      UpdatePersistentSubscription.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.UpdatePersistentSubscription) return object\n        var message = new $root.eventstore.proto.UpdatePersistentSubscription()\n        if (object.subscriptionGroupName != null)\n          message.subscriptionGroupName = String(object.subscriptionGroupName)\n        if (object.eventStreamId != null) message.eventStreamId = String(object.eventStreamId)\n        if (object.resolveLinkTos != null) message.resolveLinkTos = Boolean(object.resolveLinkTos)\n        if (object.startFrom != null)\n          if ($util.Long)\n            (message.startFrom = $util.Long.fromValue(object.startFrom)).unsigned = false\n          else if (typeof object.startFrom === 'string')\n            message.startFrom = parseInt(object.startFrom, 10)\n          else if (typeof object.startFrom === 'number') message.startFrom = object.startFrom\n          else if (typeof object.startFrom === 'object')\n            message.startFrom = new $util.LongBits(\n              object.startFrom.low >>> 0,\n              object.startFrom.high >>> 0\n            ).toNumber()\n        if (object.messageTimeoutMilliseconds != null)\n          message.messageTimeoutMilliseconds = object.messageTimeoutMilliseconds | 0\n        if (object.recordStatistics != null)\n          message.recordStatistics = Boolean(object.recordStatistics)\n        if (object.liveBufferSize != null) message.liveBufferSize = object.liveBufferSize | 0\n        if (object.readBatchSize != null) message.readBatchSize = object.readBatchSize | 0\n        if (object.bufferSize != null) message.bufferSize = object.bufferSize | 0\n        if (object.maxRetryCount != null) message.maxRetryCount = object.maxRetryCount | 0\n        if (object.preferRoundRobin != null)\n          message.preferRoundRobin = Boolean(object.preferRoundRobin)\n        if (object.checkpointAfterTime != null)\n          message.checkpointAfterTime = object.checkpointAfterTime | 0\n        if (object.checkpointMaxCount != null)\n          message.checkpointMaxCount = object.checkpointMaxCount | 0\n        if (object.checkpointMinCount != null)\n          message.checkpointMinCount = object.checkpointMinCount | 0\n        if (object.subscriberMaxCount != null)\n          message.subscriberMaxCount = object.subscriberMaxCount | 0\n        if (object.namedConsumerStrategy != null)\n          message.namedConsumerStrategy = String(object.namedConsumerStrategy)\n        return message\n      }\n\n      /**\n       * Creates a plain object from an UpdatePersistentSubscription message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.UpdatePersistentSubscription\n       * @static\n       * @param {eventstore.proto.UpdatePersistentSubscription} message UpdatePersistentSubscription\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      UpdatePersistentSubscription.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.defaults) {\n          object.subscriptionGroupName = ''\n          object.eventStreamId = ''\n          object.resolveLinkTos = false\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.startFrom =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.startFrom = options.longs === String ? '0' : 0\n          object.messageTimeoutMilliseconds = 0\n          object.recordStatistics = false\n          object.liveBufferSize = 0\n          object.readBatchSize = 0\n          object.bufferSize = 0\n          object.maxRetryCount = 0\n          object.preferRoundRobin = false\n          object.checkpointAfterTime = 0\n          object.checkpointMaxCount = 0\n          object.checkpointMinCount = 0\n          object.subscriberMaxCount = 0\n          object.namedConsumerStrategy = ''\n        }\n        if (\n          message.subscriptionGroupName != null &&\n          message.hasOwnProperty('subscriptionGroupName')\n        )\n          object.subscriptionGroupName = message.subscriptionGroupName\n        if (message.eventStreamId != null && message.hasOwnProperty('eventStreamId'))\n          object.eventStreamId = message.eventStreamId\n        if (message.resolveLinkTos != null && message.hasOwnProperty('resolveLinkTos'))\n          object.resolveLinkTos = message.resolveLinkTos\n        if (message.startFrom != null && message.hasOwnProperty('startFrom'))\n          if (typeof message.startFrom === 'number')\n            object.startFrom =\n              options.longs === String ? String(message.startFrom) : message.startFrom\n          else\n            object.startFrom =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.startFrom)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.startFrom.low >>> 0,\n                    message.startFrom.high >>> 0\n                  ).toNumber()\n                : message.startFrom\n        if (\n          message.messageTimeoutMilliseconds != null &&\n          message.hasOwnProperty('messageTimeoutMilliseconds')\n        )\n          object.messageTimeoutMilliseconds = message.messageTimeoutMilliseconds\n        if (message.recordStatistics != null && message.hasOwnProperty('recordStatistics'))\n          object.recordStatistics = message.recordStatistics\n        if (message.liveBufferSize != null && message.hasOwnProperty('liveBufferSize'))\n          object.liveBufferSize = message.liveBufferSize\n        if (message.readBatchSize != null && message.hasOwnProperty('readBatchSize'))\n          object.readBatchSize = message.readBatchSize\n        if (message.bufferSize != null && message.hasOwnProperty('bufferSize'))\n          object.bufferSize = message.bufferSize\n        if (message.maxRetryCount != null && message.hasOwnProperty('maxRetryCount'))\n          object.maxRetryCount = message.maxRetryCount\n        if (message.preferRoundRobin != null && message.hasOwnProperty('preferRoundRobin'))\n          object.preferRoundRobin = message.preferRoundRobin\n        if (message.checkpointAfterTime != null && message.hasOwnProperty('checkpointAfterTime'))\n          object.checkpointAfterTime = message.checkpointAfterTime\n        if (message.checkpointMaxCount != null && message.hasOwnProperty('checkpointMaxCount'))\n          object.checkpointMaxCount = message.checkpointMaxCount\n        if (message.checkpointMinCount != null && message.hasOwnProperty('checkpointMinCount'))\n          object.checkpointMinCount = message.checkpointMinCount\n        if (message.subscriberMaxCount != null && message.hasOwnProperty('subscriberMaxCount'))\n          object.subscriberMaxCount = message.subscriberMaxCount\n        if (\n          message.namedConsumerStrategy != null &&\n          message.hasOwnProperty('namedConsumerStrategy')\n        )\n          object.namedConsumerStrategy = message.namedConsumerStrategy\n        return object\n      }\n\n      /**\n       * Converts this UpdatePersistentSubscription to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.UpdatePersistentSubscription\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      UpdatePersistentSubscription.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      return UpdatePersistentSubscription\n    })()\n\n    proto.UpdatePersistentSubscriptionCompleted = (function() {\n      /**\n       * Properties of an UpdatePersistentSubscriptionCompleted.\n       * @memberof eventstore.proto\n       * @interface IUpdatePersistentSubscriptionCompleted\n       * @property {eventstore.proto.UpdatePersistentSubscriptionCompleted.UpdatePersistentSubscriptionResult} result UpdatePersistentSubscriptionCompleted result\n       * @property {string|null} [reason] UpdatePersistentSubscriptionCompleted reason\n       */\n\n      /**\n       * Constructs a new UpdatePersistentSubscriptionCompleted.\n       * @memberof eventstore.proto\n       * @classdesc Represents an UpdatePersistentSubscriptionCompleted.\n       * @implements IUpdatePersistentSubscriptionCompleted\n       * @constructor\n       * @param {eventstore.proto.IUpdatePersistentSubscriptionCompleted=} [properties] Properties to set\n       */\n      function UpdatePersistentSubscriptionCompleted(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * UpdatePersistentSubscriptionCompleted result.\n       * @member {eventstore.proto.UpdatePersistentSubscriptionCompleted.UpdatePersistentSubscriptionResult} result\n       * @memberof eventstore.proto.UpdatePersistentSubscriptionCompleted\n       * @instance\n       */\n      UpdatePersistentSubscriptionCompleted.prototype.result = 0\n\n      /**\n       * UpdatePersistentSubscriptionCompleted reason.\n       * @member {string} reason\n       * @memberof eventstore.proto.UpdatePersistentSubscriptionCompleted\n       * @instance\n       */\n      UpdatePersistentSubscriptionCompleted.prototype.reason = ''\n\n      /**\n       * Creates a new UpdatePersistentSubscriptionCompleted instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.UpdatePersistentSubscriptionCompleted\n       * @static\n       * @param {eventstore.proto.IUpdatePersistentSubscriptionCompleted=} [properties] Properties to set\n       * @returns {eventstore.proto.UpdatePersistentSubscriptionCompleted} UpdatePersistentSubscriptionCompleted instance\n       */\n      UpdatePersistentSubscriptionCompleted.create = function create(properties) {\n        return new UpdatePersistentSubscriptionCompleted(properties)\n      }\n\n      /**\n       * Encodes the specified UpdatePersistentSubscriptionCompleted message. Does not implicitly {@link eventstore.proto.UpdatePersistentSubscriptionCompleted.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.UpdatePersistentSubscriptionCompleted\n       * @static\n       * @param {eventstore.proto.IUpdatePersistentSubscriptionCompleted} message UpdatePersistentSubscriptionCompleted message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      UpdatePersistentSubscriptionCompleted.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.result)\n        if (message.reason != null && message.hasOwnProperty('reason'))\n          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.reason)\n        return writer\n      }\n\n      /**\n       * Encodes the specified UpdatePersistentSubscriptionCompleted message, length delimited. Does not implicitly {@link eventstore.proto.UpdatePersistentSubscriptionCompleted.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.UpdatePersistentSubscriptionCompleted\n       * @static\n       * @param {eventstore.proto.IUpdatePersistentSubscriptionCompleted} message UpdatePersistentSubscriptionCompleted message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      UpdatePersistentSubscriptionCompleted.encodeDelimited = function encodeDelimited(\n        message,\n        writer\n      ) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes an UpdatePersistentSubscriptionCompleted message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.UpdatePersistentSubscriptionCompleted\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.UpdatePersistentSubscriptionCompleted} UpdatePersistentSubscriptionCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      UpdatePersistentSubscriptionCompleted.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.UpdatePersistentSubscriptionCompleted()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              message.result = reader.int32()\n              break\n            case 2:\n              message.reason = reader.string()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        if (!message.hasOwnProperty('result'))\n          throw $util.ProtocolError(\"missing required 'result'\", {\n            instance: message\n          })\n        return message\n      }\n\n      /**\n       * Decodes an UpdatePersistentSubscriptionCompleted message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.UpdatePersistentSubscriptionCompleted\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.UpdatePersistentSubscriptionCompleted} UpdatePersistentSubscriptionCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      UpdatePersistentSubscriptionCompleted.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies an UpdatePersistentSubscriptionCompleted message.\n       * @function verify\n       * @memberof eventstore.proto.UpdatePersistentSubscriptionCompleted\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      UpdatePersistentSubscriptionCompleted.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        switch (message.result) {\n          default:\n            return 'result: enum value expected'\n          case 0:\n          case 1:\n          case 2:\n          case 3:\n            break\n        }\n        if (message.reason != null && message.hasOwnProperty('reason'))\n          if (!$util.isString(message.reason)) return 'reason: string expected'\n        return null\n      }\n\n      /**\n       * Creates an UpdatePersistentSubscriptionCompleted message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.UpdatePersistentSubscriptionCompleted\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.UpdatePersistentSubscriptionCompleted} UpdatePersistentSubscriptionCompleted\n       */\n      UpdatePersistentSubscriptionCompleted.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.UpdatePersistentSubscriptionCompleted)\n          return object\n        var message = new $root.eventstore.proto.UpdatePersistentSubscriptionCompleted()\n        switch (object.result) {\n          case 'Success':\n          case 0:\n            message.result = 0\n            break\n          case 'DoesNotExist':\n          case 1:\n            message.result = 1\n            break\n          case 'Fail':\n          case 2:\n            message.result = 2\n            break\n          case 'AccessDenied':\n          case 3:\n            message.result = 3\n            break\n        }\n        if (object.reason != null) message.reason = String(object.reason)\n        return message\n      }\n\n      /**\n       * Creates a plain object from an UpdatePersistentSubscriptionCompleted message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.UpdatePersistentSubscriptionCompleted\n       * @static\n       * @param {eventstore.proto.UpdatePersistentSubscriptionCompleted} message UpdatePersistentSubscriptionCompleted\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      UpdatePersistentSubscriptionCompleted.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.defaults) {\n          object.result = options.enums === String ? 'Success' : 0\n          object.reason = ''\n        }\n        if (message.result != null && message.hasOwnProperty('result'))\n          object.result =\n            options.enums === String\n              ? $root.eventstore.proto.UpdatePersistentSubscriptionCompleted\n                  .UpdatePersistentSubscriptionResult[message.result]\n              : message.result\n        if (message.reason != null && message.hasOwnProperty('reason'))\n          object.reason = message.reason\n        return object\n      }\n\n      /**\n       * Converts this UpdatePersistentSubscriptionCompleted to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.UpdatePersistentSubscriptionCompleted\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      UpdatePersistentSubscriptionCompleted.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      /**\n       * UpdatePersistentSubscriptionResult enum.\n       * @name eventstore.proto.UpdatePersistentSubscriptionCompleted.UpdatePersistentSubscriptionResult\n       * @enum {string}\n       * @property {number} Success=0 Success value\n       * @property {number} DoesNotExist=1 DoesNotExist value\n       * @property {number} Fail=2 Fail value\n       * @property {number} AccessDenied=3 AccessDenied value\n       */\n      UpdatePersistentSubscriptionCompleted.UpdatePersistentSubscriptionResult = (function() {\n        var valuesById = {},\n          values = Object.create(valuesById)\n        values[(valuesById[0] = 'Success')] = 0\n        values[(valuesById[1] = 'DoesNotExist')] = 1\n        values[(valuesById[2] = 'Fail')] = 2\n        values[(valuesById[3] = 'AccessDenied')] = 3\n        return values\n      })()\n\n      return UpdatePersistentSubscriptionCompleted\n    })()\n\n    proto.CreatePersistentSubscriptionCompleted = (function() {\n      /**\n       * Properties of a CreatePersistentSubscriptionCompleted.\n       * @memberof eventstore.proto\n       * @interface ICreatePersistentSubscriptionCompleted\n       * @property {eventstore.proto.CreatePersistentSubscriptionCompleted.CreatePersistentSubscriptionResult} result CreatePersistentSubscriptionCompleted result\n       * @property {string|null} [reason] CreatePersistentSubscriptionCompleted reason\n       */\n\n      /**\n       * Constructs a new CreatePersistentSubscriptionCompleted.\n       * @memberof eventstore.proto\n       * @classdesc Represents a CreatePersistentSubscriptionCompleted.\n       * @implements ICreatePersistentSubscriptionCompleted\n       * @constructor\n       * @param {eventstore.proto.ICreatePersistentSubscriptionCompleted=} [properties] Properties to set\n       */\n      function CreatePersistentSubscriptionCompleted(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * CreatePersistentSubscriptionCompleted result.\n       * @member {eventstore.proto.CreatePersistentSubscriptionCompleted.CreatePersistentSubscriptionResult} result\n       * @memberof eventstore.proto.CreatePersistentSubscriptionCompleted\n       * @instance\n       */\n      CreatePersistentSubscriptionCompleted.prototype.result = 0\n\n      /**\n       * CreatePersistentSubscriptionCompleted reason.\n       * @member {string} reason\n       * @memberof eventstore.proto.CreatePersistentSubscriptionCompleted\n       * @instance\n       */\n      CreatePersistentSubscriptionCompleted.prototype.reason = ''\n\n      /**\n       * Creates a new CreatePersistentSubscriptionCompleted instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.CreatePersistentSubscriptionCompleted\n       * @static\n       * @param {eventstore.proto.ICreatePersistentSubscriptionCompleted=} [properties] Properties to set\n       * @returns {eventstore.proto.CreatePersistentSubscriptionCompleted} CreatePersistentSubscriptionCompleted instance\n       */\n      CreatePersistentSubscriptionCompleted.create = function create(properties) {\n        return new CreatePersistentSubscriptionCompleted(properties)\n      }\n\n      /**\n       * Encodes the specified CreatePersistentSubscriptionCompleted message. Does not implicitly {@link eventstore.proto.CreatePersistentSubscriptionCompleted.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.CreatePersistentSubscriptionCompleted\n       * @static\n       * @param {eventstore.proto.ICreatePersistentSubscriptionCompleted} message CreatePersistentSubscriptionCompleted message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      CreatePersistentSubscriptionCompleted.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.result)\n        if (message.reason != null && message.hasOwnProperty('reason'))\n          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.reason)\n        return writer\n      }\n\n      /**\n       * Encodes the specified CreatePersistentSubscriptionCompleted message, length delimited. Does not implicitly {@link eventstore.proto.CreatePersistentSubscriptionCompleted.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.CreatePersistentSubscriptionCompleted\n       * @static\n       * @param {eventstore.proto.ICreatePersistentSubscriptionCompleted} message CreatePersistentSubscriptionCompleted message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      CreatePersistentSubscriptionCompleted.encodeDelimited = function encodeDelimited(\n        message,\n        writer\n      ) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes a CreatePersistentSubscriptionCompleted message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.CreatePersistentSubscriptionCompleted\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.CreatePersistentSubscriptionCompleted} CreatePersistentSubscriptionCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      CreatePersistentSubscriptionCompleted.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.CreatePersistentSubscriptionCompleted()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              message.result = reader.int32()\n              break\n            case 2:\n              message.reason = reader.string()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        if (!message.hasOwnProperty('result'))\n          throw $util.ProtocolError(\"missing required 'result'\", {\n            instance: message\n          })\n        return message\n      }\n\n      /**\n       * Decodes a CreatePersistentSubscriptionCompleted message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.CreatePersistentSubscriptionCompleted\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.CreatePersistentSubscriptionCompleted} CreatePersistentSubscriptionCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      CreatePersistentSubscriptionCompleted.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies a CreatePersistentSubscriptionCompleted message.\n       * @function verify\n       * @memberof eventstore.proto.CreatePersistentSubscriptionCompleted\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      CreatePersistentSubscriptionCompleted.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        switch (message.result) {\n          default:\n            return 'result: enum value expected'\n          case 0:\n          case 1:\n          case 2:\n          case 3:\n            break\n        }\n        if (message.reason != null && message.hasOwnProperty('reason'))\n          if (!$util.isString(message.reason)) return 'reason: string expected'\n        return null\n      }\n\n      /**\n       * Creates a CreatePersistentSubscriptionCompleted message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.CreatePersistentSubscriptionCompleted\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.CreatePersistentSubscriptionCompleted} CreatePersistentSubscriptionCompleted\n       */\n      CreatePersistentSubscriptionCompleted.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.CreatePersistentSubscriptionCompleted)\n          return object\n        var message = new $root.eventstore.proto.CreatePersistentSubscriptionCompleted()\n        switch (object.result) {\n          case 'Success':\n          case 0:\n            message.result = 0\n            break\n          case 'AlreadyExists':\n          case 1:\n            message.result = 1\n            break\n          case 'Fail':\n          case 2:\n            message.result = 2\n            break\n          case 'AccessDenied':\n          case 3:\n            message.result = 3\n            break\n        }\n        if (object.reason != null) message.reason = String(object.reason)\n        return message\n      }\n\n      /**\n       * Creates a plain object from a CreatePersistentSubscriptionCompleted message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.CreatePersistentSubscriptionCompleted\n       * @static\n       * @param {eventstore.proto.CreatePersistentSubscriptionCompleted} message CreatePersistentSubscriptionCompleted\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      CreatePersistentSubscriptionCompleted.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.defaults) {\n          object.result = options.enums === String ? 'Success' : 0\n          object.reason = ''\n        }\n        if (message.result != null && message.hasOwnProperty('result'))\n          object.result =\n            options.enums === String\n              ? $root.eventstore.proto.CreatePersistentSubscriptionCompleted\n                  .CreatePersistentSubscriptionResult[message.result]\n              : message.result\n        if (message.reason != null && message.hasOwnProperty('reason'))\n          object.reason = message.reason\n        return object\n      }\n\n      /**\n       * Converts this CreatePersistentSubscriptionCompleted to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.CreatePersistentSubscriptionCompleted\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      CreatePersistentSubscriptionCompleted.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      /**\n       * CreatePersistentSubscriptionResult enum.\n       * @name eventstore.proto.CreatePersistentSubscriptionCompleted.CreatePersistentSubscriptionResult\n       * @enum {string}\n       * @property {number} Success=0 Success value\n       * @property {number} AlreadyExists=1 AlreadyExists value\n       * @property {number} Fail=2 Fail value\n       * @property {number} AccessDenied=3 AccessDenied value\n       */\n      CreatePersistentSubscriptionCompleted.CreatePersistentSubscriptionResult = (function() {\n        var valuesById = {},\n          values = Object.create(valuesById)\n        values[(valuesById[0] = 'Success')] = 0\n        values[(valuesById[1] = 'AlreadyExists')] = 1\n        values[(valuesById[2] = 'Fail')] = 2\n        values[(valuesById[3] = 'AccessDenied')] = 3\n        return values\n      })()\n\n      return CreatePersistentSubscriptionCompleted\n    })()\n\n    proto.DeletePersistentSubscriptionCompleted = (function() {\n      /**\n       * Properties of a DeletePersistentSubscriptionCompleted.\n       * @memberof eventstore.proto\n       * @interface IDeletePersistentSubscriptionCompleted\n       * @property {eventstore.proto.DeletePersistentSubscriptionCompleted.DeletePersistentSubscriptionResult} result DeletePersistentSubscriptionCompleted result\n       * @property {string|null} [reason] DeletePersistentSubscriptionCompleted reason\n       */\n\n      /**\n       * Constructs a new DeletePersistentSubscriptionCompleted.\n       * @memberof eventstore.proto\n       * @classdesc Represents a DeletePersistentSubscriptionCompleted.\n       * @implements IDeletePersistentSubscriptionCompleted\n       * @constructor\n       * @param {eventstore.proto.IDeletePersistentSubscriptionCompleted=} [properties] Properties to set\n       */\n      function DeletePersistentSubscriptionCompleted(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * DeletePersistentSubscriptionCompleted result.\n       * @member {eventstore.proto.DeletePersistentSubscriptionCompleted.DeletePersistentSubscriptionResult} result\n       * @memberof eventstore.proto.DeletePersistentSubscriptionCompleted\n       * @instance\n       */\n      DeletePersistentSubscriptionCompleted.prototype.result = 0\n\n      /**\n       * DeletePersistentSubscriptionCompleted reason.\n       * @member {string} reason\n       * @memberof eventstore.proto.DeletePersistentSubscriptionCompleted\n       * @instance\n       */\n      DeletePersistentSubscriptionCompleted.prototype.reason = ''\n\n      /**\n       * Creates a new DeletePersistentSubscriptionCompleted instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.DeletePersistentSubscriptionCompleted\n       * @static\n       * @param {eventstore.proto.IDeletePersistentSubscriptionCompleted=} [properties] Properties to set\n       * @returns {eventstore.proto.DeletePersistentSubscriptionCompleted} DeletePersistentSubscriptionCompleted instance\n       */\n      DeletePersistentSubscriptionCompleted.create = function create(properties) {\n        return new DeletePersistentSubscriptionCompleted(properties)\n      }\n\n      /**\n       * Encodes the specified DeletePersistentSubscriptionCompleted message. Does not implicitly {@link eventstore.proto.DeletePersistentSubscriptionCompleted.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.DeletePersistentSubscriptionCompleted\n       * @static\n       * @param {eventstore.proto.IDeletePersistentSubscriptionCompleted} message DeletePersistentSubscriptionCompleted message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      DeletePersistentSubscriptionCompleted.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.result)\n        if (message.reason != null && message.hasOwnProperty('reason'))\n          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.reason)\n        return writer\n      }\n\n      /**\n       * Encodes the specified DeletePersistentSubscriptionCompleted message, length delimited. Does not implicitly {@link eventstore.proto.DeletePersistentSubscriptionCompleted.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.DeletePersistentSubscriptionCompleted\n       * @static\n       * @param {eventstore.proto.IDeletePersistentSubscriptionCompleted} message DeletePersistentSubscriptionCompleted message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      DeletePersistentSubscriptionCompleted.encodeDelimited = function encodeDelimited(\n        message,\n        writer\n      ) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes a DeletePersistentSubscriptionCompleted message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.DeletePersistentSubscriptionCompleted\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.DeletePersistentSubscriptionCompleted} DeletePersistentSubscriptionCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      DeletePersistentSubscriptionCompleted.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.DeletePersistentSubscriptionCompleted()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              message.result = reader.int32()\n              break\n            case 2:\n              message.reason = reader.string()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        if (!message.hasOwnProperty('result'))\n          throw $util.ProtocolError(\"missing required 'result'\", {\n            instance: message\n          })\n        return message\n      }\n\n      /**\n       * Decodes a DeletePersistentSubscriptionCompleted message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.DeletePersistentSubscriptionCompleted\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.DeletePersistentSubscriptionCompleted} DeletePersistentSubscriptionCompleted\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      DeletePersistentSubscriptionCompleted.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies a DeletePersistentSubscriptionCompleted message.\n       * @function verify\n       * @memberof eventstore.proto.DeletePersistentSubscriptionCompleted\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      DeletePersistentSubscriptionCompleted.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        switch (message.result) {\n          default:\n            return 'result: enum value expected'\n          case 0:\n          case 1:\n          case 2:\n          case 3:\n            break\n        }\n        if (message.reason != null && message.hasOwnProperty('reason'))\n          if (!$util.isString(message.reason)) return 'reason: string expected'\n        return null\n      }\n\n      /**\n       * Creates a DeletePersistentSubscriptionCompleted message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.DeletePersistentSubscriptionCompleted\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.DeletePersistentSubscriptionCompleted} DeletePersistentSubscriptionCompleted\n       */\n      DeletePersistentSubscriptionCompleted.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.DeletePersistentSubscriptionCompleted)\n          return object\n        var message = new $root.eventstore.proto.DeletePersistentSubscriptionCompleted()\n        switch (object.result) {\n          case 'Success':\n          case 0:\n            message.result = 0\n            break\n          case 'DoesNotExist':\n          case 1:\n            message.result = 1\n            break\n          case 'Fail':\n          case 2:\n            message.result = 2\n            break\n          case 'AccessDenied':\n          case 3:\n            message.result = 3\n            break\n        }\n        if (object.reason != null) message.reason = String(object.reason)\n        return message\n      }\n\n      /**\n       * Creates a plain object from a DeletePersistentSubscriptionCompleted message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.DeletePersistentSubscriptionCompleted\n       * @static\n       * @param {eventstore.proto.DeletePersistentSubscriptionCompleted} message DeletePersistentSubscriptionCompleted\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      DeletePersistentSubscriptionCompleted.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.defaults) {\n          object.result = options.enums === String ? 'Success' : 0\n          object.reason = ''\n        }\n        if (message.result != null && message.hasOwnProperty('result'))\n          object.result =\n            options.enums === String\n              ? $root.eventstore.proto.DeletePersistentSubscriptionCompleted\n                  .DeletePersistentSubscriptionResult[message.result]\n              : message.result\n        if (message.reason != null && message.hasOwnProperty('reason'))\n          object.reason = message.reason\n        return object\n      }\n\n      /**\n       * Converts this DeletePersistentSubscriptionCompleted to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.DeletePersistentSubscriptionCompleted\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      DeletePersistentSubscriptionCompleted.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      /**\n       * DeletePersistentSubscriptionResult enum.\n       * @name eventstore.proto.DeletePersistentSubscriptionCompleted.DeletePersistentSubscriptionResult\n       * @enum {string}\n       * @property {number} Success=0 Success value\n       * @property {number} DoesNotExist=1 DoesNotExist value\n       * @property {number} Fail=2 Fail value\n       * @property {number} AccessDenied=3 AccessDenied value\n       */\n      DeletePersistentSubscriptionCompleted.DeletePersistentSubscriptionResult = (function() {\n        var valuesById = {},\n          values = Object.create(valuesById)\n        values[(valuesById[0] = 'Success')] = 0\n        values[(valuesById[1] = 'DoesNotExist')] = 1\n        values[(valuesById[2] = 'Fail')] = 2\n        values[(valuesById[3] = 'AccessDenied')] = 3\n        return values\n      })()\n\n      return DeletePersistentSubscriptionCompleted\n    })()\n\n    proto.ConnectToPersistentSubscription = (function() {\n      /**\n       * Properties of a ConnectToPersistentSubscription.\n       * @memberof eventstore.proto\n       * @interface IConnectToPersistentSubscription\n       * @property {string} subscriptionId ConnectToPersistentSubscription subscriptionId\n       * @property {string} eventStreamId ConnectToPersistentSubscription eventStreamId\n       * @property {number} allowedInFlightMessages ConnectToPersistentSubscription allowedInFlightMessages\n       */\n\n      /**\n       * Constructs a new ConnectToPersistentSubscription.\n       * @memberof eventstore.proto\n       * @classdesc Represents a ConnectToPersistentSubscription.\n       * @implements IConnectToPersistentSubscription\n       * @constructor\n       * @param {eventstore.proto.IConnectToPersistentSubscription=} [properties] Properties to set\n       */\n      function ConnectToPersistentSubscription(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * ConnectToPersistentSubscription subscriptionId.\n       * @member {string} subscriptionId\n       * @memberof eventstore.proto.ConnectToPersistentSubscription\n       * @instance\n       */\n      ConnectToPersistentSubscription.prototype.subscriptionId = ''\n\n      /**\n       * ConnectToPersistentSubscription eventStreamId.\n       * @member {string} eventStreamId\n       * @memberof eventstore.proto.ConnectToPersistentSubscription\n       * @instance\n       */\n      ConnectToPersistentSubscription.prototype.eventStreamId = ''\n\n      /**\n       * ConnectToPersistentSubscription allowedInFlightMessages.\n       * @member {number} allowedInFlightMessages\n       * @memberof eventstore.proto.ConnectToPersistentSubscription\n       * @instance\n       */\n      ConnectToPersistentSubscription.prototype.allowedInFlightMessages = 0\n\n      /**\n       * Creates a new ConnectToPersistentSubscription instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.ConnectToPersistentSubscription\n       * @static\n       * @param {eventstore.proto.IConnectToPersistentSubscription=} [properties] Properties to set\n       * @returns {eventstore.proto.ConnectToPersistentSubscription} ConnectToPersistentSubscription instance\n       */\n      ConnectToPersistentSubscription.create = function create(properties) {\n        return new ConnectToPersistentSubscription(properties)\n      }\n\n      /**\n       * Encodes the specified ConnectToPersistentSubscription message. Does not implicitly {@link eventstore.proto.ConnectToPersistentSubscription.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.ConnectToPersistentSubscription\n       * @static\n       * @param {eventstore.proto.IConnectToPersistentSubscription} message ConnectToPersistentSubscription message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      ConnectToPersistentSubscription.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.subscriptionId)\n        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.eventStreamId)\n        writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.allowedInFlightMessages)\n        return writer\n      }\n\n      /**\n       * Encodes the specified ConnectToPersistentSubscription message, length delimited. Does not implicitly {@link eventstore.proto.ConnectToPersistentSubscription.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.ConnectToPersistentSubscription\n       * @static\n       * @param {eventstore.proto.IConnectToPersistentSubscription} message ConnectToPersistentSubscription message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      ConnectToPersistentSubscription.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes a ConnectToPersistentSubscription message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.ConnectToPersistentSubscription\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.ConnectToPersistentSubscription} ConnectToPersistentSubscription\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      ConnectToPersistentSubscription.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.ConnectToPersistentSubscription()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              message.subscriptionId = reader.string()\n              break\n            case 2:\n              message.eventStreamId = reader.string()\n              break\n            case 3:\n              message.allowedInFlightMessages = reader.int32()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        if (!message.hasOwnProperty('subscriptionId'))\n          throw $util.ProtocolError(\"missing required 'subscriptionId'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('eventStreamId'))\n          throw $util.ProtocolError(\"missing required 'eventStreamId'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('allowedInFlightMessages'))\n          throw $util.ProtocolError(\"missing required 'allowedInFlightMessages'\", {\n            instance: message\n          })\n        return message\n      }\n\n      /**\n       * Decodes a ConnectToPersistentSubscription message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.ConnectToPersistentSubscription\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.ConnectToPersistentSubscription} ConnectToPersistentSubscription\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      ConnectToPersistentSubscription.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies a ConnectToPersistentSubscription message.\n       * @function verify\n       * @memberof eventstore.proto.ConnectToPersistentSubscription\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      ConnectToPersistentSubscription.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        if (!$util.isString(message.subscriptionId)) return 'subscriptionId: string expected'\n        if (!$util.isString(message.eventStreamId)) return 'eventStreamId: string expected'\n        if (!$util.isInteger(message.allowedInFlightMessages))\n          return 'allowedInFlightMessages: integer expected'\n        return null\n      }\n\n      /**\n       * Creates a ConnectToPersistentSubscription message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.ConnectToPersistentSubscription\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.ConnectToPersistentSubscription} ConnectToPersistentSubscription\n       */\n      ConnectToPersistentSubscription.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.ConnectToPersistentSubscription) return object\n        var message = new $root.eventstore.proto.ConnectToPersistentSubscription()\n        if (object.subscriptionId != null) message.subscriptionId = String(object.subscriptionId)\n        if (object.eventStreamId != null) message.eventStreamId = String(object.eventStreamId)\n        if (object.allowedInFlightMessages != null)\n          message.allowedInFlightMessages = object.allowedInFlightMessages | 0\n        return message\n      }\n\n      /**\n       * Creates a plain object from a ConnectToPersistentSubscription message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.ConnectToPersistentSubscription\n       * @static\n       * @param {eventstore.proto.ConnectToPersistentSubscription} message ConnectToPersistentSubscription\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      ConnectToPersistentSubscription.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.defaults) {\n          object.subscriptionId = ''\n          object.eventStreamId = ''\n          object.allowedInFlightMessages = 0\n        }\n        if (message.subscriptionId != null && message.hasOwnProperty('subscriptionId'))\n          object.subscriptionId = message.subscriptionId\n        if (message.eventStreamId != null && message.hasOwnProperty('eventStreamId'))\n          object.eventStreamId = message.eventStreamId\n        if (\n          message.allowedInFlightMessages != null &&\n          message.hasOwnProperty('allowedInFlightMessages')\n        )\n          object.allowedInFlightMessages = message.allowedInFlightMessages\n        return object\n      }\n\n      /**\n       * Converts this ConnectToPersistentSubscription to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.ConnectToPersistentSubscription\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      ConnectToPersistentSubscription.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      return ConnectToPersistentSubscription\n    })()\n\n    proto.PersistentSubscriptionAckEvents = (function() {\n      /**\n       * Properties of a PersistentSubscriptionAckEvents.\n       * @memberof eventstore.proto\n       * @interface IPersistentSubscriptionAckEvents\n       * @property {string} subscriptionId PersistentSubscriptionAckEvents subscriptionId\n       * @property {Array.<Uint8Array>|null} [processedEventIds] PersistentSubscriptionAckEvents processedEventIds\n       */\n\n      /**\n       * Constructs a new PersistentSubscriptionAckEvents.\n       * @memberof eventstore.proto\n       * @classdesc Represents a PersistentSubscriptionAckEvents.\n       * @implements IPersistentSubscriptionAckEvents\n       * @constructor\n       * @param {eventstore.proto.IPersistentSubscriptionAckEvents=} [properties] Properties to set\n       */\n      function PersistentSubscriptionAckEvents(properties) {\n        this.processedEventIds = []\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * PersistentSubscriptionAckEvents subscriptionId.\n       * @member {string} subscriptionId\n       * @memberof eventstore.proto.PersistentSubscriptionAckEvents\n       * @instance\n       */\n      PersistentSubscriptionAckEvents.prototype.subscriptionId = ''\n\n      /**\n       * PersistentSubscriptionAckEvents processedEventIds.\n       * @member {Array.<Uint8Array>} processedEventIds\n       * @memberof eventstore.proto.PersistentSubscriptionAckEvents\n       * @instance\n       */\n      PersistentSubscriptionAckEvents.prototype.processedEventIds = $util.emptyArray\n\n      /**\n       * Creates a new PersistentSubscriptionAckEvents instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.PersistentSubscriptionAckEvents\n       * @static\n       * @param {eventstore.proto.IPersistentSubscriptionAckEvents=} [properties] Properties to set\n       * @returns {eventstore.proto.PersistentSubscriptionAckEvents} PersistentSubscriptionAckEvents instance\n       */\n      PersistentSubscriptionAckEvents.create = function create(properties) {\n        return new PersistentSubscriptionAckEvents(properties)\n      }\n\n      /**\n       * Encodes the specified PersistentSubscriptionAckEvents message. Does not implicitly {@link eventstore.proto.PersistentSubscriptionAckEvents.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.PersistentSubscriptionAckEvents\n       * @static\n       * @param {eventstore.proto.IPersistentSubscriptionAckEvents} message PersistentSubscriptionAckEvents message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      PersistentSubscriptionAckEvents.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.subscriptionId)\n        if (message.processedEventIds != null && message.processedEventIds.length)\n          for (var i = 0; i < message.processedEventIds.length; ++i)\n            writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.processedEventIds[i])\n        return writer\n      }\n\n      /**\n       * Encodes the specified PersistentSubscriptionAckEvents message, length delimited. Does not implicitly {@link eventstore.proto.PersistentSubscriptionAckEvents.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.PersistentSubscriptionAckEvents\n       * @static\n       * @param {eventstore.proto.IPersistentSubscriptionAckEvents} message PersistentSubscriptionAckEvents message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      PersistentSubscriptionAckEvents.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes a PersistentSubscriptionAckEvents message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.PersistentSubscriptionAckEvents\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.PersistentSubscriptionAckEvents} PersistentSubscriptionAckEvents\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      PersistentSubscriptionAckEvents.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.PersistentSubscriptionAckEvents()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              message.subscriptionId = reader.string()\n              break\n            case 2:\n              if (!(message.processedEventIds && message.processedEventIds.length))\n                message.processedEventIds = []\n              message.processedEventIds.push(reader.bytes())\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        if (!message.hasOwnProperty('subscriptionId'))\n          throw $util.ProtocolError(\"missing required 'subscriptionId'\", {\n            instance: message\n          })\n        return message\n      }\n\n      /**\n       * Decodes a PersistentSubscriptionAckEvents message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.PersistentSubscriptionAckEvents\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.PersistentSubscriptionAckEvents} PersistentSubscriptionAckEvents\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      PersistentSubscriptionAckEvents.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies a PersistentSubscriptionAckEvents message.\n       * @function verify\n       * @memberof eventstore.proto.PersistentSubscriptionAckEvents\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      PersistentSubscriptionAckEvents.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        if (!$util.isString(message.subscriptionId)) return 'subscriptionId: string expected'\n        if (message.processedEventIds != null && message.hasOwnProperty('processedEventIds')) {\n          if (!Array.isArray(message.processedEventIds)) return 'processedEventIds: array expected'\n          for (var i = 0; i < message.processedEventIds.length; ++i)\n            if (\n              !(\n                (message.processedEventIds[i] &&\n                  typeof message.processedEventIds[i].length === 'number') ||\n                $util.isString(message.processedEventIds[i])\n              )\n            )\n              return 'processedEventIds: buffer[] expected'\n        }\n        return null\n      }\n\n      /**\n       * Creates a PersistentSubscriptionAckEvents message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.PersistentSubscriptionAckEvents\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.PersistentSubscriptionAckEvents} PersistentSubscriptionAckEvents\n       */\n      PersistentSubscriptionAckEvents.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.PersistentSubscriptionAckEvents) return object\n        var message = new $root.eventstore.proto.PersistentSubscriptionAckEvents()\n        if (object.subscriptionId != null) message.subscriptionId = String(object.subscriptionId)\n        if (object.processedEventIds) {\n          if (!Array.isArray(object.processedEventIds))\n            throw TypeError(\n              '.eventstore.proto.PersistentSubscriptionAckEvents.processedEventIds: array expected'\n            )\n          message.processedEventIds = []\n          for (var i = 0; i < object.processedEventIds.length; ++i)\n            if (typeof object.processedEventIds[i] === 'string')\n              $util.base64.decode(\n                object.processedEventIds[i],\n                (message.processedEventIds[i] = $util.newBuffer(\n                  $util.base64.length(object.processedEventIds[i])\n                )),\n                0\n              )\n            else if (object.processedEventIds[i].length)\n              message.processedEventIds[i] = object.processedEventIds[i]\n        }\n        return message\n      }\n\n      /**\n       * Creates a plain object from a PersistentSubscriptionAckEvents message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.PersistentSubscriptionAckEvents\n       * @static\n       * @param {eventstore.proto.PersistentSubscriptionAckEvents} message PersistentSubscriptionAckEvents\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      PersistentSubscriptionAckEvents.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.arrays || options.defaults) object.processedEventIds = []\n        if (options.defaults) object.subscriptionId = ''\n        if (message.subscriptionId != null && message.hasOwnProperty('subscriptionId'))\n          object.subscriptionId = message.subscriptionId\n        if (message.processedEventIds && message.processedEventIds.length) {\n          object.processedEventIds = []\n          for (var j = 0; j < message.processedEventIds.length; ++j)\n            object.processedEventIds[j] =\n              options.bytes === String\n                ? $util.base64.encode(\n                    message.processedEventIds[j],\n                    0,\n                    message.processedEventIds[j].length\n                  )\n                : options.bytes === Array\n                ? Array.prototype.slice.call(message.processedEventIds[j])\n                : message.processedEventIds[j]\n        }\n        return object\n      }\n\n      /**\n       * Converts this PersistentSubscriptionAckEvents to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.PersistentSubscriptionAckEvents\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      PersistentSubscriptionAckEvents.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      return PersistentSubscriptionAckEvents\n    })()\n\n    proto.PersistentSubscriptionNakEvents = (function() {\n      /**\n       * Properties of a PersistentSubscriptionNakEvents.\n       * @memberof eventstore.proto\n       * @interface IPersistentSubscriptionNakEvents\n       * @property {string} subscriptionId PersistentSubscriptionNakEvents subscriptionId\n       * @property {Array.<Uint8Array>|null} [processedEventIds] PersistentSubscriptionNakEvents processedEventIds\n       * @property {string|null} [message] PersistentSubscriptionNakEvents message\n       * @property {eventstore.proto.PersistentSubscriptionNakEvents.NakAction} action PersistentSubscriptionNakEvents action\n       */\n\n      /**\n       * Constructs a new PersistentSubscriptionNakEvents.\n       * @memberof eventstore.proto\n       * @classdesc Represents a PersistentSubscriptionNakEvents.\n       * @implements IPersistentSubscriptionNakEvents\n       * @constructor\n       * @param {eventstore.proto.IPersistentSubscriptionNakEvents=} [properties] Properties to set\n       */\n      function PersistentSubscriptionNakEvents(properties) {\n        this.processedEventIds = []\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * PersistentSubscriptionNakEvents subscriptionId.\n       * @member {string} subscriptionId\n       * @memberof eventstore.proto.PersistentSubscriptionNakEvents\n       * @instance\n       */\n      PersistentSubscriptionNakEvents.prototype.subscriptionId = ''\n\n      /**\n       * PersistentSubscriptionNakEvents processedEventIds.\n       * @member {Array.<Uint8Array>} processedEventIds\n       * @memberof eventstore.proto.PersistentSubscriptionNakEvents\n       * @instance\n       */\n      PersistentSubscriptionNakEvents.prototype.processedEventIds = $util.emptyArray\n\n      /**\n       * PersistentSubscriptionNakEvents message.\n       * @member {string} message\n       * @memberof eventstore.proto.PersistentSubscriptionNakEvents\n       * @instance\n       */\n      PersistentSubscriptionNakEvents.prototype.message = ''\n\n      /**\n       * PersistentSubscriptionNakEvents action.\n       * @member {eventstore.proto.PersistentSubscriptionNakEvents.NakAction} action\n       * @memberof eventstore.proto.PersistentSubscriptionNakEvents\n       * @instance\n       */\n      PersistentSubscriptionNakEvents.prototype.action = 0\n\n      /**\n       * Creates a new PersistentSubscriptionNakEvents instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.PersistentSubscriptionNakEvents\n       * @static\n       * @param {eventstore.proto.IPersistentSubscriptionNakEvents=} [properties] Properties to set\n       * @returns {eventstore.proto.PersistentSubscriptionNakEvents} PersistentSubscriptionNakEvents instance\n       */\n      PersistentSubscriptionNakEvents.create = function create(properties) {\n        return new PersistentSubscriptionNakEvents(properties)\n      }\n\n      /**\n       * Encodes the specified PersistentSubscriptionNakEvents message. Does not implicitly {@link eventstore.proto.PersistentSubscriptionNakEvents.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.PersistentSubscriptionNakEvents\n       * @static\n       * @param {eventstore.proto.IPersistentSubscriptionNakEvents} message PersistentSubscriptionNakEvents message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      PersistentSubscriptionNakEvents.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.subscriptionId)\n        if (message.processedEventIds != null && message.processedEventIds.length)\n          for (var i = 0; i < message.processedEventIds.length; ++i)\n            writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.processedEventIds[i])\n        if (message.message != null && message.hasOwnProperty('message'))\n          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.message)\n        writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.action)\n        return writer\n      }\n\n      /**\n       * Encodes the specified PersistentSubscriptionNakEvents message, length delimited. Does not implicitly {@link eventstore.proto.PersistentSubscriptionNakEvents.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.PersistentSubscriptionNakEvents\n       * @static\n       * @param {eventstore.proto.IPersistentSubscriptionNakEvents} message PersistentSubscriptionNakEvents message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      PersistentSubscriptionNakEvents.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes a PersistentSubscriptionNakEvents message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.PersistentSubscriptionNakEvents\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.PersistentSubscriptionNakEvents} PersistentSubscriptionNakEvents\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      PersistentSubscriptionNakEvents.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.PersistentSubscriptionNakEvents()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              message.subscriptionId = reader.string()\n              break\n            case 2:\n              if (!(message.processedEventIds && message.processedEventIds.length))\n                message.processedEventIds = []\n              message.processedEventIds.push(reader.bytes())\n              break\n            case 3:\n              message.message = reader.string()\n              break\n            case 4:\n              message.action = reader.int32()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        if (!message.hasOwnProperty('subscriptionId'))\n          throw $util.ProtocolError(\"missing required 'subscriptionId'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('action'))\n          throw $util.ProtocolError(\"missing required 'action'\", {\n            instance: message\n          })\n        return message\n      }\n\n      /**\n       * Decodes a PersistentSubscriptionNakEvents message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.PersistentSubscriptionNakEvents\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.PersistentSubscriptionNakEvents} PersistentSubscriptionNakEvents\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      PersistentSubscriptionNakEvents.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies a PersistentSubscriptionNakEvents message.\n       * @function verify\n       * @memberof eventstore.proto.PersistentSubscriptionNakEvents\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      PersistentSubscriptionNakEvents.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        if (!$util.isString(message.subscriptionId)) return 'subscriptionId: string expected'\n        if (message.processedEventIds != null && message.hasOwnProperty('processedEventIds')) {\n          if (!Array.isArray(message.processedEventIds)) return 'processedEventIds: array expected'\n          for (var i = 0; i < message.processedEventIds.length; ++i)\n            if (\n              !(\n                (message.processedEventIds[i] &&\n                  typeof message.processedEventIds[i].length === 'number') ||\n                $util.isString(message.processedEventIds[i])\n              )\n            )\n              return 'processedEventIds: buffer[] expected'\n        }\n        if (message.message != null && message.hasOwnProperty('message'))\n          if (!$util.isString(message.message)) return 'message: string expected'\n        switch (message.action) {\n          default:\n            return 'action: enum value expected'\n          case 0:\n          case 1:\n          case 2:\n          case 3:\n          case 4:\n            break\n        }\n        return null\n      }\n\n      /**\n       * Creates a PersistentSubscriptionNakEvents message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.PersistentSubscriptionNakEvents\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.PersistentSubscriptionNakEvents} PersistentSubscriptionNakEvents\n       */\n      PersistentSubscriptionNakEvents.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.PersistentSubscriptionNakEvents) return object\n        var message = new $root.eventstore.proto.PersistentSubscriptionNakEvents()\n        if (object.subscriptionId != null) message.subscriptionId = String(object.subscriptionId)\n        if (object.processedEventIds) {\n          if (!Array.isArray(object.processedEventIds))\n            throw TypeError(\n              '.eventstore.proto.PersistentSubscriptionNakEvents.processedEventIds: array expected'\n            )\n          message.processedEventIds = []\n          for (var i = 0; i < object.processedEventIds.length; ++i)\n            if (typeof object.processedEventIds[i] === 'string')\n              $util.base64.decode(\n                object.processedEventIds[i],\n                (message.processedEventIds[i] = $util.newBuffer(\n                  $util.base64.length(object.processedEventIds[i])\n                )),\n                0\n              )\n            else if (object.processedEventIds[i].length)\n              message.processedEventIds[i] = object.processedEventIds[i]\n        }\n        if (object.message != null) message.message = String(object.message)\n        switch (object.action) {\n          case 'Unknown':\n          case 0:\n            message.action = 0\n            break\n          case 'Park':\n          case 1:\n            message.action = 1\n            break\n          case 'Retry':\n          case 2:\n            message.action = 2\n            break\n          case 'Skip':\n          case 3:\n            message.action = 3\n            break\n          case 'Stop':\n          case 4:\n            message.action = 4\n            break\n        }\n        return message\n      }\n\n      /**\n       * Creates a plain object from a PersistentSubscriptionNakEvents message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.PersistentSubscriptionNakEvents\n       * @static\n       * @param {eventstore.proto.PersistentSubscriptionNakEvents} message PersistentSubscriptionNakEvents\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      PersistentSubscriptionNakEvents.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.arrays || options.defaults) object.processedEventIds = []\n        if (options.defaults) {\n          object.subscriptionId = ''\n          object.message = ''\n          object.action = options.enums === String ? 'Unknown' : 0\n        }\n        if (message.subscriptionId != null && message.hasOwnProperty('subscriptionId'))\n          object.subscriptionId = message.subscriptionId\n        if (message.processedEventIds && message.processedEventIds.length) {\n          object.processedEventIds = []\n          for (var j = 0; j < message.processedEventIds.length; ++j)\n            object.processedEventIds[j] =\n              options.bytes === String\n                ? $util.base64.encode(\n                    message.processedEventIds[j],\n                    0,\n                    message.processedEventIds[j].length\n                  )\n                : options.bytes === Array\n                ? Array.prototype.slice.call(message.processedEventIds[j])\n                : message.processedEventIds[j]\n        }\n        if (message.message != null && message.hasOwnProperty('message'))\n          object.message = message.message\n        if (message.action != null && message.hasOwnProperty('action'))\n          object.action =\n            options.enums === String\n              ? $root.eventstore.proto.PersistentSubscriptionNakEvents.NakAction[message.action]\n              : message.action\n        return object\n      }\n\n      /**\n       * Converts this PersistentSubscriptionNakEvents to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.PersistentSubscriptionNakEvents\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      PersistentSubscriptionNakEvents.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      /**\n       * NakAction enum.\n       * @name eventstore.proto.PersistentSubscriptionNakEvents.NakAction\n       * @enum {string}\n       * @property {number} Unknown=0 Unknown value\n       * @property {number} Park=1 Park value\n       * @property {number} Retry=2 Retry value\n       * @property {number} Skip=3 Skip value\n       * @property {number} Stop=4 Stop value\n       */\n      PersistentSubscriptionNakEvents.NakAction = (function() {\n        var valuesById = {},\n          values = Object.create(valuesById)\n        values[(valuesById[0] = 'Unknown')] = 0\n        values[(valuesById[1] = 'Park')] = 1\n        values[(valuesById[2] = 'Retry')] = 2\n        values[(valuesById[3] = 'Skip')] = 3\n        values[(valuesById[4] = 'Stop')] = 4\n        return values\n      })()\n\n      return PersistentSubscriptionNakEvents\n    })()\n\n    proto.PersistentSubscriptionConfirmation = (function() {\n      /**\n       * Properties of a PersistentSubscriptionConfirmation.\n       * @memberof eventstore.proto\n       * @interface IPersistentSubscriptionConfirmation\n       * @property {number|Long} lastCommitPosition PersistentSubscriptionConfirmation lastCommitPosition\n       * @property {string} subscriptionId PersistentSubscriptionConfirmation subscriptionId\n       * @property {number|Long|null} [lastEventNumber] PersistentSubscriptionConfirmation lastEventNumber\n       */\n\n      /**\n       * Constructs a new PersistentSubscriptionConfirmation.\n       * @memberof eventstore.proto\n       * @classdesc Represents a PersistentSubscriptionConfirmation.\n       * @implements IPersistentSubscriptionConfirmation\n       * @constructor\n       * @param {eventstore.proto.IPersistentSubscriptionConfirmation=} [properties] Properties to set\n       */\n      function PersistentSubscriptionConfirmation(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * PersistentSubscriptionConfirmation lastCommitPosition.\n       * @member {number|Long} lastCommitPosition\n       * @memberof eventstore.proto.PersistentSubscriptionConfirmation\n       * @instance\n       */\n      PersistentSubscriptionConfirmation.prototype.lastCommitPosition = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0\n\n      /**\n       * PersistentSubscriptionConfirmation subscriptionId.\n       * @member {string} subscriptionId\n       * @memberof eventstore.proto.PersistentSubscriptionConfirmation\n       * @instance\n       */\n      PersistentSubscriptionConfirmation.prototype.subscriptionId = ''\n\n      /**\n       * PersistentSubscriptionConfirmation lastEventNumber.\n       * @member {number|Long} lastEventNumber\n       * @memberof eventstore.proto.PersistentSubscriptionConfirmation\n       * @instance\n       */\n      PersistentSubscriptionConfirmation.prototype.lastEventNumber = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0\n\n      /**\n       * Creates a new PersistentSubscriptionConfirmation instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.PersistentSubscriptionConfirmation\n       * @static\n       * @param {eventstore.proto.IPersistentSubscriptionConfirmation=} [properties] Properties to set\n       * @returns {eventstore.proto.PersistentSubscriptionConfirmation} PersistentSubscriptionConfirmation instance\n       */\n      PersistentSubscriptionConfirmation.create = function create(properties) {\n        return new PersistentSubscriptionConfirmation(properties)\n      }\n\n      /**\n       * Encodes the specified PersistentSubscriptionConfirmation message. Does not implicitly {@link eventstore.proto.PersistentSubscriptionConfirmation.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.PersistentSubscriptionConfirmation\n       * @static\n       * @param {eventstore.proto.IPersistentSubscriptionConfirmation} message PersistentSubscriptionConfirmation message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      PersistentSubscriptionConfirmation.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.lastCommitPosition)\n        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.subscriptionId)\n        if (message.lastEventNumber != null && message.hasOwnProperty('lastEventNumber'))\n          writer.uint32(/* id 3, wireType 0 =*/ 24).int64(message.lastEventNumber)\n        return writer\n      }\n\n      /**\n       * Encodes the specified PersistentSubscriptionConfirmation message, length delimited. Does not implicitly {@link eventstore.proto.PersistentSubscriptionConfirmation.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.PersistentSubscriptionConfirmation\n       * @static\n       * @param {eventstore.proto.IPersistentSubscriptionConfirmation} message PersistentSubscriptionConfirmation message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      PersistentSubscriptionConfirmation.encodeDelimited = function encodeDelimited(\n        message,\n        writer\n      ) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes a PersistentSubscriptionConfirmation message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.PersistentSubscriptionConfirmation\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.PersistentSubscriptionConfirmation} PersistentSubscriptionConfirmation\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      PersistentSubscriptionConfirmation.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.PersistentSubscriptionConfirmation()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              message.lastCommitPosition = reader.int64()\n              break\n            case 2:\n              message.subscriptionId = reader.string()\n              break\n            case 3:\n              message.lastEventNumber = reader.int64()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        if (!message.hasOwnProperty('lastCommitPosition'))\n          throw $util.ProtocolError(\"missing required 'lastCommitPosition'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('subscriptionId'))\n          throw $util.ProtocolError(\"missing required 'subscriptionId'\", {\n            instance: message\n          })\n        return message\n      }\n\n      /**\n       * Decodes a PersistentSubscriptionConfirmation message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.PersistentSubscriptionConfirmation\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.PersistentSubscriptionConfirmation} PersistentSubscriptionConfirmation\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      PersistentSubscriptionConfirmation.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies a PersistentSubscriptionConfirmation message.\n       * @function verify\n       * @memberof eventstore.proto.PersistentSubscriptionConfirmation\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      PersistentSubscriptionConfirmation.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        if (\n          !$util.isInteger(message.lastCommitPosition) &&\n          !(\n            message.lastCommitPosition &&\n            $util.isInteger(message.lastCommitPosition.low) &&\n            $util.isInteger(message.lastCommitPosition.high)\n          )\n        )\n          return 'lastCommitPosition: integer|Long expected'\n        if (!$util.isString(message.subscriptionId)) return 'subscriptionId: string expected'\n        if (message.lastEventNumber != null && message.hasOwnProperty('lastEventNumber'))\n          if (\n            !$util.isInteger(message.lastEventNumber) &&\n            !(\n              message.lastEventNumber &&\n              $util.isInteger(message.lastEventNumber.low) &&\n              $util.isInteger(message.lastEventNumber.high)\n            )\n          )\n            return 'lastEventNumber: integer|Long expected'\n        return null\n      }\n\n      /**\n       * Creates a PersistentSubscriptionConfirmation message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.PersistentSubscriptionConfirmation\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.PersistentSubscriptionConfirmation} PersistentSubscriptionConfirmation\n       */\n      PersistentSubscriptionConfirmation.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.PersistentSubscriptionConfirmation)\n          return object\n        var message = new $root.eventstore.proto.PersistentSubscriptionConfirmation()\n        if (object.lastCommitPosition != null)\n          if ($util.Long)\n            (message.lastCommitPosition = $util.Long.fromValue(\n              object.lastCommitPosition\n            )).unsigned = false\n          else if (typeof object.lastCommitPosition === 'string')\n            message.lastCommitPosition = parseInt(object.lastCommitPosition, 10)\n          else if (typeof object.lastCommitPosition === 'number')\n            message.lastCommitPosition = object.lastCommitPosition\n          else if (typeof object.lastCommitPosition === 'object')\n            message.lastCommitPosition = new $util.LongBits(\n              object.lastCommitPosition.low >>> 0,\n              object.lastCommitPosition.high >>> 0\n            ).toNumber()\n        if (object.subscriptionId != null) message.subscriptionId = String(object.subscriptionId)\n        if (object.lastEventNumber != null)\n          if ($util.Long)\n            (message.lastEventNumber = $util.Long.fromValue(\n              object.lastEventNumber\n            )).unsigned = false\n          else if (typeof object.lastEventNumber === 'string')\n            message.lastEventNumber = parseInt(object.lastEventNumber, 10)\n          else if (typeof object.lastEventNumber === 'number')\n            message.lastEventNumber = object.lastEventNumber\n          else if (typeof object.lastEventNumber === 'object')\n            message.lastEventNumber = new $util.LongBits(\n              object.lastEventNumber.low >>> 0,\n              object.lastEventNumber.high >>> 0\n            ).toNumber()\n        return message\n      }\n\n      /**\n       * Creates a plain object from a PersistentSubscriptionConfirmation message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.PersistentSubscriptionConfirmation\n       * @static\n       * @param {eventstore.proto.PersistentSubscriptionConfirmation} message PersistentSubscriptionConfirmation\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      PersistentSubscriptionConfirmation.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.defaults) {\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.lastCommitPosition =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.lastCommitPosition = options.longs === String ? '0' : 0\n          object.subscriptionId = ''\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.lastEventNumber =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.lastEventNumber = options.longs === String ? '0' : 0\n        }\n        if (message.lastCommitPosition != null && message.hasOwnProperty('lastCommitPosition'))\n          if (typeof message.lastCommitPosition === 'number')\n            object.lastCommitPosition =\n              options.longs === String\n                ? String(message.lastCommitPosition)\n                : message.lastCommitPosition\n          else\n            object.lastCommitPosition =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.lastCommitPosition)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.lastCommitPosition.low >>> 0,\n                    message.lastCommitPosition.high >>> 0\n                  ).toNumber()\n                : message.lastCommitPosition\n        if (message.subscriptionId != null && message.hasOwnProperty('subscriptionId'))\n          object.subscriptionId = message.subscriptionId\n        if (message.lastEventNumber != null && message.hasOwnProperty('lastEventNumber'))\n          if (typeof message.lastEventNumber === 'number')\n            object.lastEventNumber =\n              options.longs === String ? String(message.lastEventNumber) : message.lastEventNumber\n          else\n            object.lastEventNumber =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.lastEventNumber)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.lastEventNumber.low >>> 0,\n                    message.lastEventNumber.high >>> 0\n                  ).toNumber()\n                : message.lastEventNumber\n        return object\n      }\n\n      /**\n       * Converts this PersistentSubscriptionConfirmation to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.PersistentSubscriptionConfirmation\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      PersistentSubscriptionConfirmation.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      return PersistentSubscriptionConfirmation\n    })()\n\n    proto.PersistentSubscriptionStreamEventAppeared = (function() {\n      /**\n       * Properties of a PersistentSubscriptionStreamEventAppeared.\n       * @memberof eventstore.proto\n       * @interface IPersistentSubscriptionStreamEventAppeared\n       * @property {eventstore.proto.IResolvedIndexedEvent} event PersistentSubscriptionStreamEventAppeared event\n       */\n\n      /**\n       * Constructs a new PersistentSubscriptionStreamEventAppeared.\n       * @memberof eventstore.proto\n       * @classdesc Represents a PersistentSubscriptionStreamEventAppeared.\n       * @implements IPersistentSubscriptionStreamEventAppeared\n       * @constructor\n       * @param {eventstore.proto.IPersistentSubscriptionStreamEventAppeared=} [properties] Properties to set\n       */\n      function PersistentSubscriptionStreamEventAppeared(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * PersistentSubscriptionStreamEventAppeared event.\n       * @member {eventstore.proto.IResolvedIndexedEvent} event\n       * @memberof eventstore.proto.PersistentSubscriptionStreamEventAppeared\n       * @instance\n       */\n      PersistentSubscriptionStreamEventAppeared.prototype.event = null\n\n      /**\n       * Creates a new PersistentSubscriptionStreamEventAppeared instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.PersistentSubscriptionStreamEventAppeared\n       * @static\n       * @param {eventstore.proto.IPersistentSubscriptionStreamEventAppeared=} [properties] Properties to set\n       * @returns {eventstore.proto.PersistentSubscriptionStreamEventAppeared} PersistentSubscriptionStreamEventAppeared instance\n       */\n      PersistentSubscriptionStreamEventAppeared.create = function create(properties) {\n        return new PersistentSubscriptionStreamEventAppeared(properties)\n      }\n\n      /**\n       * Encodes the specified PersistentSubscriptionStreamEventAppeared message. Does not implicitly {@link eventstore.proto.PersistentSubscriptionStreamEventAppeared.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.PersistentSubscriptionStreamEventAppeared\n       * @static\n       * @param {eventstore.proto.IPersistentSubscriptionStreamEventAppeared} message PersistentSubscriptionStreamEventAppeared message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      PersistentSubscriptionStreamEventAppeared.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        $root.eventstore.proto.ResolvedIndexedEvent.encode(\n          message.event,\n          writer.uint32(/* id 1, wireType 2 =*/ 10).fork()\n        ).ldelim()\n        return writer\n      }\n\n      /**\n       * Encodes the specified PersistentSubscriptionStreamEventAppeared message, length delimited. Does not implicitly {@link eventstore.proto.PersistentSubscriptionStreamEventAppeared.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.PersistentSubscriptionStreamEventAppeared\n       * @static\n       * @param {eventstore.proto.IPersistentSubscriptionStreamEventAppeared} message PersistentSubscriptionStreamEventAppeared message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      PersistentSubscriptionStreamEventAppeared.encodeDelimited = function encodeDelimited(\n        message,\n        writer\n      ) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes a PersistentSubscriptionStreamEventAppeared message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.PersistentSubscriptionStreamEventAppeared\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.PersistentSubscriptionStreamEventAppeared} PersistentSubscriptionStreamEventAppeared\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      PersistentSubscriptionStreamEventAppeared.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.PersistentSubscriptionStreamEventAppeared()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              message.event = $root.eventstore.proto.ResolvedIndexedEvent.decode(\n                reader,\n                reader.uint32()\n              )\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        if (!message.hasOwnProperty('event'))\n          throw $util.ProtocolError(\"missing required 'event'\", {\n            instance: message\n          })\n        return message\n      }\n\n      /**\n       * Decodes a PersistentSubscriptionStreamEventAppeared message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.PersistentSubscriptionStreamEventAppeared\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.PersistentSubscriptionStreamEventAppeared} PersistentSubscriptionStreamEventAppeared\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      PersistentSubscriptionStreamEventAppeared.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies a PersistentSubscriptionStreamEventAppeared message.\n       * @function verify\n       * @memberof eventstore.proto.PersistentSubscriptionStreamEventAppeared\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      PersistentSubscriptionStreamEventAppeared.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        {\n          var error = $root.eventstore.proto.ResolvedIndexedEvent.verify(message.event)\n          if (error) return 'event.' + error\n        }\n        return null\n      }\n\n      /**\n       * Creates a PersistentSubscriptionStreamEventAppeared message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.PersistentSubscriptionStreamEventAppeared\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.PersistentSubscriptionStreamEventAppeared} PersistentSubscriptionStreamEventAppeared\n       */\n      PersistentSubscriptionStreamEventAppeared.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.PersistentSubscriptionStreamEventAppeared)\n          return object\n        var message = new $root.eventstore.proto.PersistentSubscriptionStreamEventAppeared()\n        if (object.event != null) {\n          if (typeof object.event !== 'object')\n            throw TypeError(\n              '.eventstore.proto.PersistentSubscriptionStreamEventAppeared.event: object expected'\n            )\n          message.event = $root.eventstore.proto.ResolvedIndexedEvent.fromObject(object.event)\n        }\n        return message\n      }\n\n      /**\n       * Creates a plain object from a PersistentSubscriptionStreamEventAppeared message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.PersistentSubscriptionStreamEventAppeared\n       * @static\n       * @param {eventstore.proto.PersistentSubscriptionStreamEventAppeared} message PersistentSubscriptionStreamEventAppeared\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      PersistentSubscriptionStreamEventAppeared.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.defaults) object.event = null\n        if (message.event != null && message.hasOwnProperty('event'))\n          object.event = $root.eventstore.proto.ResolvedIndexedEvent.toObject(\n            message.event,\n            options\n          )\n        return object\n      }\n\n      /**\n       * Converts this PersistentSubscriptionStreamEventAppeared to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.PersistentSubscriptionStreamEventAppeared\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      PersistentSubscriptionStreamEventAppeared.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      return PersistentSubscriptionStreamEventAppeared\n    })()\n\n    proto.SubscribeToStream = (function() {\n      /**\n       * Properties of a SubscribeToStream.\n       * @memberof eventstore.proto\n       * @interface ISubscribeToStream\n       * @property {string} eventStreamId SubscribeToStream eventStreamId\n       * @property {boolean} resolveLinkTos SubscribeToStream resolveLinkTos\n       */\n\n      /**\n       * Constructs a new SubscribeToStream.\n       * @memberof eventstore.proto\n       * @classdesc Represents a SubscribeToStream.\n       * @implements ISubscribeToStream\n       * @constructor\n       * @param {eventstore.proto.ISubscribeToStream=} [properties] Properties to set\n       */\n      function SubscribeToStream(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * SubscribeToStream eventStreamId.\n       * @member {string} eventStreamId\n       * @memberof eventstore.proto.SubscribeToStream\n       * @instance\n       */\n      SubscribeToStream.prototype.eventStreamId = ''\n\n      /**\n       * SubscribeToStream resolveLinkTos.\n       * @member {boolean} resolveLinkTos\n       * @memberof eventstore.proto.SubscribeToStream\n       * @instance\n       */\n      SubscribeToStream.prototype.resolveLinkTos = false\n\n      /**\n       * Creates a new SubscribeToStream instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.SubscribeToStream\n       * @static\n       * @param {eventstore.proto.ISubscribeToStream=} [properties] Properties to set\n       * @returns {eventstore.proto.SubscribeToStream} SubscribeToStream instance\n       */\n      SubscribeToStream.create = function create(properties) {\n        return new SubscribeToStream(properties)\n      }\n\n      /**\n       * Encodes the specified SubscribeToStream message. Does not implicitly {@link eventstore.proto.SubscribeToStream.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.SubscribeToStream\n       * @static\n       * @param {eventstore.proto.ISubscribeToStream} message SubscribeToStream message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      SubscribeToStream.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.eventStreamId)\n        writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.resolveLinkTos)\n        return writer\n      }\n\n      /**\n       * Encodes the specified SubscribeToStream message, length delimited. Does not implicitly {@link eventstore.proto.SubscribeToStream.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.SubscribeToStream\n       * @static\n       * @param {eventstore.proto.ISubscribeToStream} message SubscribeToStream message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      SubscribeToStream.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes a SubscribeToStream message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.SubscribeToStream\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.SubscribeToStream} SubscribeToStream\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      SubscribeToStream.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.SubscribeToStream()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              message.eventStreamId = reader.string()\n              break\n            case 2:\n              message.resolveLinkTos = reader.bool()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        if (!message.hasOwnProperty('eventStreamId'))\n          throw $util.ProtocolError(\"missing required 'eventStreamId'\", {\n            instance: message\n          })\n        if (!message.hasOwnProperty('resolveLinkTos'))\n          throw $util.ProtocolError(\"missing required 'resolveLinkTos'\", {\n            instance: message\n          })\n        return message\n      }\n\n      /**\n       * Decodes a SubscribeToStream message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.SubscribeToStream\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.SubscribeToStream} SubscribeToStream\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      SubscribeToStream.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies a SubscribeToStream message.\n       * @function verify\n       * @memberof eventstore.proto.SubscribeToStream\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      SubscribeToStream.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        if (!$util.isString(message.eventStreamId)) return 'eventStreamId: string expected'\n        if (typeof message.resolveLinkTos !== 'boolean') return 'resolveLinkTos: boolean expected'\n        return null\n      }\n\n      /**\n       * Creates a SubscribeToStream message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.SubscribeToStream\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.SubscribeToStream} SubscribeToStream\n       */\n      SubscribeToStream.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.SubscribeToStream) return object\n        var message = new $root.eventstore.proto.SubscribeToStream()\n        if (object.eventStreamId != null) message.eventStreamId = String(object.eventStreamId)\n        if (object.resolveLinkTos != null) message.resolveLinkTos = Boolean(object.resolveLinkTos)\n        return message\n      }\n\n      /**\n       * Creates a plain object from a SubscribeToStream message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.SubscribeToStream\n       * @static\n       * @param {eventstore.proto.SubscribeToStream} message SubscribeToStream\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      SubscribeToStream.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.defaults) {\n          object.eventStreamId = ''\n          object.resolveLinkTos = false\n        }\n        if (message.eventStreamId != null && message.hasOwnProperty('eventStreamId'))\n          object.eventStreamId = message.eventStreamId\n        if (message.resolveLinkTos != null && message.hasOwnProperty('resolveLinkTos'))\n          object.resolveLinkTos = message.resolveLinkTos\n        return object\n      }\n\n      /**\n       * Converts this SubscribeToStream to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.SubscribeToStream\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      SubscribeToStream.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      return SubscribeToStream\n    })()\n\n    proto.SubscriptionConfirmation = (function() {\n      /**\n       * Properties of a SubscriptionConfirmation.\n       * @memberof eventstore.proto\n       * @interface ISubscriptionConfirmation\n       * @property {number|Long} lastCommitPosition SubscriptionConfirmation lastCommitPosition\n       * @property {number|Long|null} [lastEventNumber] SubscriptionConfirmation lastEventNumber\n       */\n\n      /**\n       * Constructs a new SubscriptionConfirmation.\n       * @memberof eventstore.proto\n       * @classdesc Represents a SubscriptionConfirmation.\n       * @implements ISubscriptionConfirmation\n       * @constructor\n       * @param {eventstore.proto.ISubscriptionConfirmation=} [properties] Properties to set\n       */\n      function SubscriptionConfirmation(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * SubscriptionConfirmation lastCommitPosition.\n       * @member {number|Long} lastCommitPosition\n       * @memberof eventstore.proto.SubscriptionConfirmation\n       * @instance\n       */\n      SubscriptionConfirmation.prototype.lastCommitPosition = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0\n\n      /**\n       * SubscriptionConfirmation lastEventNumber.\n       * @member {number|Long} lastEventNumber\n       * @memberof eventstore.proto.SubscriptionConfirmation\n       * @instance\n       */\n      SubscriptionConfirmation.prototype.lastEventNumber = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0\n\n      /**\n       * Creates a new SubscriptionConfirmation instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.SubscriptionConfirmation\n       * @static\n       * @param {eventstore.proto.ISubscriptionConfirmation=} [properties] Properties to set\n       * @returns {eventstore.proto.SubscriptionConfirmation} SubscriptionConfirmation instance\n       */\n      SubscriptionConfirmation.create = function create(properties) {\n        return new SubscriptionConfirmation(properties)\n      }\n\n      /**\n       * Encodes the specified SubscriptionConfirmation message. Does not implicitly {@link eventstore.proto.SubscriptionConfirmation.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.SubscriptionConfirmation\n       * @static\n       * @param {eventstore.proto.ISubscriptionConfirmation} message SubscriptionConfirmation message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      SubscriptionConfirmation.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.lastCommitPosition)\n        if (message.lastEventNumber != null && message.hasOwnProperty('lastEventNumber'))\n          writer.uint32(/* id 2, wireType 0 =*/ 16).int64(message.lastEventNumber)\n        return writer\n      }\n\n      /**\n       * Encodes the specified SubscriptionConfirmation message, length delimited. Does not implicitly {@link eventstore.proto.SubscriptionConfirmation.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.SubscriptionConfirmation\n       * @static\n       * @param {eventstore.proto.ISubscriptionConfirmation} message SubscriptionConfirmation message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      SubscriptionConfirmation.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes a SubscriptionConfirmation message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.SubscriptionConfirmation\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.SubscriptionConfirmation} SubscriptionConfirmation\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      SubscriptionConfirmation.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.SubscriptionConfirmation()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              message.lastCommitPosition = reader.int64()\n              break\n            case 2:\n              message.lastEventNumber = reader.int64()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        if (!message.hasOwnProperty('lastCommitPosition'))\n          throw $util.ProtocolError(\"missing required 'lastCommitPosition'\", {\n            instance: message\n          })\n        return message\n      }\n\n      /**\n       * Decodes a SubscriptionConfirmation message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.SubscriptionConfirmation\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.SubscriptionConfirmation} SubscriptionConfirmation\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      SubscriptionConfirmation.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies a SubscriptionConfirmation message.\n       * @function verify\n       * @memberof eventstore.proto.SubscriptionConfirmation\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      SubscriptionConfirmation.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        if (\n          !$util.isInteger(message.lastCommitPosition) &&\n          !(\n            message.lastCommitPosition &&\n            $util.isInteger(message.lastCommitPosition.low) &&\n            $util.isInteger(message.lastCommitPosition.high)\n          )\n        )\n          return 'lastCommitPosition: integer|Long expected'\n        if (message.lastEventNumber != null && message.hasOwnProperty('lastEventNumber'))\n          if (\n            !$util.isInteger(message.lastEventNumber) &&\n            !(\n              message.lastEventNumber &&\n              $util.isInteger(message.lastEventNumber.low) &&\n              $util.isInteger(message.lastEventNumber.high)\n            )\n          )\n            return 'lastEventNumber: integer|Long expected'\n        return null\n      }\n\n      /**\n       * Creates a SubscriptionConfirmation message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.SubscriptionConfirmation\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.SubscriptionConfirmation} SubscriptionConfirmation\n       */\n      SubscriptionConfirmation.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.SubscriptionConfirmation) return object\n        var message = new $root.eventstore.proto.SubscriptionConfirmation()\n        if (object.lastCommitPosition != null)\n          if ($util.Long)\n            (message.lastCommitPosition = $util.Long.fromValue(\n              object.lastCommitPosition\n            )).unsigned = false\n          else if (typeof object.lastCommitPosition === 'string')\n            message.lastCommitPosition = parseInt(object.lastCommitPosition, 10)\n          else if (typeof object.lastCommitPosition === 'number')\n            message.lastCommitPosition = object.lastCommitPosition\n          else if (typeof object.lastCommitPosition === 'object')\n            message.lastCommitPosition = new $util.LongBits(\n              object.lastCommitPosition.low >>> 0,\n              object.lastCommitPosition.high >>> 0\n            ).toNumber()\n        if (object.lastEventNumber != null)\n          if ($util.Long)\n            (message.lastEventNumber = $util.Long.fromValue(\n              object.lastEventNumber\n            )).unsigned = false\n          else if (typeof object.lastEventNumber === 'string')\n            message.lastEventNumber = parseInt(object.lastEventNumber, 10)\n          else if (typeof object.lastEventNumber === 'number')\n            message.lastEventNumber = object.lastEventNumber\n          else if (typeof object.lastEventNumber === 'object')\n            message.lastEventNumber = new $util.LongBits(\n              object.lastEventNumber.low >>> 0,\n              object.lastEventNumber.high >>> 0\n            ).toNumber()\n        return message\n      }\n\n      /**\n       * Creates a plain object from a SubscriptionConfirmation message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.SubscriptionConfirmation\n       * @static\n       * @param {eventstore.proto.SubscriptionConfirmation} message SubscriptionConfirmation\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      SubscriptionConfirmation.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.defaults) {\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.lastCommitPosition =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.lastCommitPosition = options.longs === String ? '0' : 0\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false)\n            object.lastEventNumber =\n              options.longs === String\n                ? long.toString()\n                : options.longs === Number\n                ? long.toNumber()\n                : long\n          } else object.lastEventNumber = options.longs === String ? '0' : 0\n        }\n        if (message.lastCommitPosition != null && message.hasOwnProperty('lastCommitPosition'))\n          if (typeof message.lastCommitPosition === 'number')\n            object.lastCommitPosition =\n              options.longs === String\n                ? String(message.lastCommitPosition)\n                : message.lastCommitPosition\n          else\n            object.lastCommitPosition =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.lastCommitPosition)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.lastCommitPosition.low >>> 0,\n                    message.lastCommitPosition.high >>> 0\n                  ).toNumber()\n                : message.lastCommitPosition\n        if (message.lastEventNumber != null && message.hasOwnProperty('lastEventNumber'))\n          if (typeof message.lastEventNumber === 'number')\n            object.lastEventNumber =\n              options.longs === String ? String(message.lastEventNumber) : message.lastEventNumber\n          else\n            object.lastEventNumber =\n              options.longs === String\n                ? $util.Long.prototype.toString.call(message.lastEventNumber)\n                : options.longs === Number\n                ? new $util.LongBits(\n                    message.lastEventNumber.low >>> 0,\n                    message.lastEventNumber.high >>> 0\n                  ).toNumber()\n                : message.lastEventNumber\n        return object\n      }\n\n      /**\n       * Converts this SubscriptionConfirmation to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.SubscriptionConfirmation\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      SubscriptionConfirmation.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      return SubscriptionConfirmation\n    })()\n\n    proto.StreamEventAppeared = (function() {\n      /**\n       * Properties of a StreamEventAppeared.\n       * @memberof eventstore.proto\n       * @interface IStreamEventAppeared\n       * @property {eventstore.proto.IResolvedEvent} event StreamEventAppeared event\n       */\n\n      /**\n       * Constructs a new StreamEventAppeared.\n       * @memberof eventstore.proto\n       * @classdesc Represents a StreamEventAppeared.\n       * @implements IStreamEventAppeared\n       * @constructor\n       * @param {eventstore.proto.IStreamEventAppeared=} [properties] Properties to set\n       */\n      function StreamEventAppeared(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * StreamEventAppeared event.\n       * @member {eventstore.proto.IResolvedEvent} event\n       * @memberof eventstore.proto.StreamEventAppeared\n       * @instance\n       */\n      StreamEventAppeared.prototype.event = null\n\n      /**\n       * Creates a new StreamEventAppeared instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.StreamEventAppeared\n       * @static\n       * @param {eventstore.proto.IStreamEventAppeared=} [properties] Properties to set\n       * @returns {eventstore.proto.StreamEventAppeared} StreamEventAppeared instance\n       */\n      StreamEventAppeared.create = function create(properties) {\n        return new StreamEventAppeared(properties)\n      }\n\n      /**\n       * Encodes the specified StreamEventAppeared message. Does not implicitly {@link eventstore.proto.StreamEventAppeared.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.StreamEventAppeared\n       * @static\n       * @param {eventstore.proto.IStreamEventAppeared} message StreamEventAppeared message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      StreamEventAppeared.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        $root.eventstore.proto.ResolvedEvent.encode(\n          message.event,\n          writer.uint32(/* id 1, wireType 2 =*/ 10).fork()\n        ).ldelim()\n        return writer\n      }\n\n      /**\n       * Encodes the specified StreamEventAppeared message, length delimited. Does not implicitly {@link eventstore.proto.StreamEventAppeared.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.StreamEventAppeared\n       * @static\n       * @param {eventstore.proto.IStreamEventAppeared} message StreamEventAppeared message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      StreamEventAppeared.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes a StreamEventAppeared message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.StreamEventAppeared\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.StreamEventAppeared} StreamEventAppeared\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      StreamEventAppeared.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.StreamEventAppeared()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              message.event = $root.eventstore.proto.ResolvedEvent.decode(reader, reader.uint32())\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        if (!message.hasOwnProperty('event'))\n          throw $util.ProtocolError(\"missing required 'event'\", {\n            instance: message\n          })\n        return message\n      }\n\n      /**\n       * Decodes a StreamEventAppeared message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.StreamEventAppeared\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.StreamEventAppeared} StreamEventAppeared\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      StreamEventAppeared.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies a StreamEventAppeared message.\n       * @function verify\n       * @memberof eventstore.proto.StreamEventAppeared\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      StreamEventAppeared.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        {\n          var error = $root.eventstore.proto.ResolvedEvent.verify(message.event)\n          if (error) return 'event.' + error\n        }\n        return null\n      }\n\n      /**\n       * Creates a StreamEventAppeared message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.StreamEventAppeared\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.StreamEventAppeared} StreamEventAppeared\n       */\n      StreamEventAppeared.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.StreamEventAppeared) return object\n        var message = new $root.eventstore.proto.StreamEventAppeared()\n        if (object.event != null) {\n          if (typeof object.event !== 'object')\n            throw TypeError('.eventstore.proto.StreamEventAppeared.event: object expected')\n          message.event = $root.eventstore.proto.ResolvedEvent.fromObject(object.event)\n        }\n        return message\n      }\n\n      /**\n       * Creates a plain object from a StreamEventAppeared message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.StreamEventAppeared\n       * @static\n       * @param {eventstore.proto.StreamEventAppeared} message StreamEventAppeared\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      StreamEventAppeared.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.defaults) object.event = null\n        if (message.event != null && message.hasOwnProperty('event'))\n          object.event = $root.eventstore.proto.ResolvedEvent.toObject(message.event, options)\n        return object\n      }\n\n      /**\n       * Converts this StreamEventAppeared to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.StreamEventAppeared\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      StreamEventAppeared.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      return StreamEventAppeared\n    })()\n\n    proto.UnsubscribeFromStream = (function() {\n      /**\n       * Properties of an UnsubscribeFromStream.\n       * @memberof eventstore.proto\n       * @interface IUnsubscribeFromStream\n       */\n\n      /**\n       * Constructs a new UnsubscribeFromStream.\n       * @memberof eventstore.proto\n       * @classdesc Represents an UnsubscribeFromStream.\n       * @implements IUnsubscribeFromStream\n       * @constructor\n       * @param {eventstore.proto.IUnsubscribeFromStream=} [properties] Properties to set\n       */\n      function UnsubscribeFromStream(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * Creates a new UnsubscribeFromStream instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.UnsubscribeFromStream\n       * @static\n       * @param {eventstore.proto.IUnsubscribeFromStream=} [properties] Properties to set\n       * @returns {eventstore.proto.UnsubscribeFromStream} UnsubscribeFromStream instance\n       */\n      UnsubscribeFromStream.create = function create(properties) {\n        return new UnsubscribeFromStream(properties)\n      }\n\n      /**\n       * Encodes the specified UnsubscribeFromStream message. Does not implicitly {@link eventstore.proto.UnsubscribeFromStream.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.UnsubscribeFromStream\n       * @static\n       * @param {eventstore.proto.IUnsubscribeFromStream} message UnsubscribeFromStream message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      UnsubscribeFromStream.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        return writer\n      }\n\n      /**\n       * Encodes the specified UnsubscribeFromStream message, length delimited. Does not implicitly {@link eventstore.proto.UnsubscribeFromStream.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.UnsubscribeFromStream\n       * @static\n       * @param {eventstore.proto.IUnsubscribeFromStream} message UnsubscribeFromStream message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      UnsubscribeFromStream.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes an UnsubscribeFromStream message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.UnsubscribeFromStream\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.UnsubscribeFromStream} UnsubscribeFromStream\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      UnsubscribeFromStream.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.UnsubscribeFromStream()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        return message\n      }\n\n      /**\n       * Decodes an UnsubscribeFromStream message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.UnsubscribeFromStream\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.UnsubscribeFromStream} UnsubscribeFromStream\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      UnsubscribeFromStream.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies an UnsubscribeFromStream message.\n       * @function verify\n       * @memberof eventstore.proto.UnsubscribeFromStream\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      UnsubscribeFromStream.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        return null\n      }\n\n      /**\n       * Creates an UnsubscribeFromStream message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.UnsubscribeFromStream\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.UnsubscribeFromStream} UnsubscribeFromStream\n       */\n      UnsubscribeFromStream.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.UnsubscribeFromStream) return object\n        return new $root.eventstore.proto.UnsubscribeFromStream()\n      }\n\n      /**\n       * Creates a plain object from an UnsubscribeFromStream message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.UnsubscribeFromStream\n       * @static\n       * @param {eventstore.proto.UnsubscribeFromStream} message UnsubscribeFromStream\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      UnsubscribeFromStream.toObject = function toObject() {\n        return {}\n      }\n\n      /**\n       * Converts this UnsubscribeFromStream to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.UnsubscribeFromStream\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      UnsubscribeFromStream.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      return UnsubscribeFromStream\n    })()\n\n    proto.SubscriptionDropped = (function() {\n      /**\n       * Properties of a SubscriptionDropped.\n       * @memberof eventstore.proto\n       * @interface ISubscriptionDropped\n       * @property {eventstore.proto.SubscriptionDropped.SubscriptionDropReason|null} [reason] SubscriptionDropped reason\n       */\n\n      /**\n       * Constructs a new SubscriptionDropped.\n       * @memberof eventstore.proto\n       * @classdesc Represents a SubscriptionDropped.\n       * @implements ISubscriptionDropped\n       * @constructor\n       * @param {eventstore.proto.ISubscriptionDropped=} [properties] Properties to set\n       */\n      function SubscriptionDropped(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * SubscriptionDropped reason.\n       * @member {eventstore.proto.SubscriptionDropped.SubscriptionDropReason} reason\n       * @memberof eventstore.proto.SubscriptionDropped\n       * @instance\n       */\n      SubscriptionDropped.prototype.reason = 0\n\n      /**\n       * Creates a new SubscriptionDropped instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.SubscriptionDropped\n       * @static\n       * @param {eventstore.proto.ISubscriptionDropped=} [properties] Properties to set\n       * @returns {eventstore.proto.SubscriptionDropped} SubscriptionDropped instance\n       */\n      SubscriptionDropped.create = function create(properties) {\n        return new SubscriptionDropped(properties)\n      }\n\n      /**\n       * Encodes the specified SubscriptionDropped message. Does not implicitly {@link eventstore.proto.SubscriptionDropped.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.SubscriptionDropped\n       * @static\n       * @param {eventstore.proto.ISubscriptionDropped} message SubscriptionDropped message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      SubscriptionDropped.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        if (message.reason != null && message.hasOwnProperty('reason'))\n          writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.reason)\n        return writer\n      }\n\n      /**\n       * Encodes the specified SubscriptionDropped message, length delimited. Does not implicitly {@link eventstore.proto.SubscriptionDropped.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.SubscriptionDropped\n       * @static\n       * @param {eventstore.proto.ISubscriptionDropped} message SubscriptionDropped message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      SubscriptionDropped.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes a SubscriptionDropped message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.SubscriptionDropped\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.SubscriptionDropped} SubscriptionDropped\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      SubscriptionDropped.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.SubscriptionDropped()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              message.reason = reader.int32()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        return message\n      }\n\n      /**\n       * Decodes a SubscriptionDropped message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.SubscriptionDropped\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.SubscriptionDropped} SubscriptionDropped\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      SubscriptionDropped.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies a SubscriptionDropped message.\n       * @function verify\n       * @memberof eventstore.proto.SubscriptionDropped\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      SubscriptionDropped.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        if (message.reason != null && message.hasOwnProperty('reason'))\n          switch (message.reason) {\n            default:\n              return 'reason: enum value expected'\n            case 0:\n            case 1:\n            case 2:\n            case 3:\n            case 4:\n              break\n          }\n        return null\n      }\n\n      /**\n       * Creates a SubscriptionDropped message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.SubscriptionDropped\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.SubscriptionDropped} SubscriptionDropped\n       */\n      SubscriptionDropped.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.SubscriptionDropped) return object\n        var message = new $root.eventstore.proto.SubscriptionDropped()\n        switch (object.reason) {\n          case 'Unsubscribed':\n          case 0:\n            message.reason = 0\n            break\n          case 'AccessDenied':\n          case 1:\n            message.reason = 1\n            break\n          case 'NotFound':\n          case 2:\n            message.reason = 2\n            break\n          case 'PersistentSubscriptionDeleted':\n          case 3:\n            message.reason = 3\n            break\n          case 'SubscriberMaxCountReached':\n          case 4:\n            message.reason = 4\n            break\n        }\n        return message\n      }\n\n      /**\n       * Creates a plain object from a SubscriptionDropped message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.SubscriptionDropped\n       * @static\n       * @param {eventstore.proto.SubscriptionDropped} message SubscriptionDropped\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      SubscriptionDropped.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.defaults) object.reason = options.enums === String ? 'Unsubscribed' : 0\n        if (message.reason != null && message.hasOwnProperty('reason'))\n          object.reason =\n            options.enums === String\n              ? $root.eventstore.proto.SubscriptionDropped.SubscriptionDropReason[message.reason]\n              : message.reason\n        return object\n      }\n\n      /**\n       * Converts this SubscriptionDropped to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.SubscriptionDropped\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      SubscriptionDropped.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      /**\n       * SubscriptionDropReason enum.\n       * @name eventstore.proto.SubscriptionDropped.SubscriptionDropReason\n       * @enum {string}\n       * @property {number} Unsubscribed=0 Unsubscribed value\n       * @property {number} AccessDenied=1 AccessDenied value\n       * @property {number} NotFound=2 NotFound value\n       * @property {number} PersistentSubscriptionDeleted=3 PersistentSubscriptionDeleted value\n       * @property {number} SubscriberMaxCountReached=4 SubscriberMaxCountReached value\n       */\n      SubscriptionDropped.SubscriptionDropReason = (function() {\n        var valuesById = {},\n          values = Object.create(valuesById)\n        values[(valuesById[0] = 'Unsubscribed')] = 0\n        values[(valuesById[1] = 'AccessDenied')] = 1\n        values[(valuesById[2] = 'NotFound')] = 2\n        values[(valuesById[3] = 'PersistentSubscriptionDeleted')] = 3\n        values[(valuesById[4] = 'SubscriberMaxCountReached')] = 4\n        return values\n      })()\n\n      return SubscriptionDropped\n    })()\n\n    proto.NotHandled = (function() {\n      /**\n       * Properties of a NotHandled.\n       * @memberof eventstore.proto\n       * @interface INotHandled\n       * @property {eventstore.proto.NotHandled.NotHandledReason} reason NotHandled reason\n       * @property {eventstore.proto.NotHandled.IMasterInfo|null} [additionalInfo] NotHandled additionalInfo\n       */\n\n      /**\n       * Constructs a new NotHandled.\n       * @memberof eventstore.proto\n       * @classdesc Represents a NotHandled.\n       * @implements INotHandled\n       * @constructor\n       * @param {eventstore.proto.INotHandled=} [properties] Properties to set\n       */\n      function NotHandled(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * NotHandled reason.\n       * @member {eventstore.proto.NotHandled.NotHandledReason} reason\n       * @memberof eventstore.proto.NotHandled\n       * @instance\n       */\n      NotHandled.prototype.reason = 0\n\n      /**\n       * NotHandled additionalInfo.\n       * @member {eventstore.proto.NotHandled.IMasterInfo|null|undefined} additionalInfo\n       * @memberof eventstore.proto.NotHandled\n       * @instance\n       */\n      NotHandled.prototype.additionalInfo = null\n\n      /**\n       * Creates a new NotHandled instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.NotHandled\n       * @static\n       * @param {eventstore.proto.INotHandled=} [properties] Properties to set\n       * @returns {eventstore.proto.NotHandled} NotHandled instance\n       */\n      NotHandled.create = function create(properties) {\n        return new NotHandled(properties)\n      }\n\n      /**\n       * Encodes the specified NotHandled message. Does not implicitly {@link eventstore.proto.NotHandled.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.NotHandled\n       * @static\n       * @param {eventstore.proto.INotHandled} message NotHandled message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      NotHandled.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.reason)\n        if (message.additionalInfo != null && message.hasOwnProperty('additionalInfo'))\n          $root.eventstore.proto.NotHandled.MasterInfo.encode(\n            message.additionalInfo,\n            writer.uint32(/* id 2, wireType 2 =*/ 18).fork()\n          ).ldelim()\n        return writer\n      }\n\n      /**\n       * Encodes the specified NotHandled message, length delimited. Does not implicitly {@link eventstore.proto.NotHandled.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.NotHandled\n       * @static\n       * @param {eventstore.proto.INotHandled} message NotHandled message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      NotHandled.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes a NotHandled message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.NotHandled\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.NotHandled} NotHandled\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      NotHandled.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.NotHandled()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              message.reason = reader.int32()\n              break\n            case 2:\n              message.additionalInfo = $root.eventstore.proto.NotHandled.MasterInfo.decode(\n                reader,\n                reader.uint32()\n              )\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        if (!message.hasOwnProperty('reason'))\n          throw $util.ProtocolError(\"missing required 'reason'\", {\n            instance: message\n          })\n        return message\n      }\n\n      /**\n       * Decodes a NotHandled message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.NotHandled\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.NotHandled} NotHandled\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      NotHandled.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies a NotHandled message.\n       * @function verify\n       * @memberof eventstore.proto.NotHandled\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      NotHandled.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        switch (message.reason) {\n          default:\n            return 'reason: enum value expected'\n          case 0:\n          case 1:\n          case 2:\n            break\n        }\n        if (message.additionalInfo != null && message.hasOwnProperty('additionalInfo')) {\n          var error = $root.eventstore.proto.NotHandled.MasterInfo.verify(message.additionalInfo)\n          if (error) return 'additionalInfo.' + error\n        }\n        return null\n      }\n\n      /**\n       * Creates a NotHandled message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.NotHandled\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.NotHandled} NotHandled\n       */\n      NotHandled.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.NotHandled) return object\n        var message = new $root.eventstore.proto.NotHandled()\n        switch (object.reason) {\n          case 'NotReady':\n          case 0:\n            message.reason = 0\n            break\n          case 'TooBusy':\n          case 1:\n            message.reason = 1\n            break\n          case 'NotMaster':\n          case 2:\n            message.reason = 2\n            break\n        }\n        if (object.additionalInfo != null) {\n          if (typeof object.additionalInfo !== 'object')\n            throw TypeError('.eventstore.proto.NotHandled.additionalInfo: object expected')\n          message.additionalInfo = $root.eventstore.proto.NotHandled.MasterInfo.fromObject(\n            object.additionalInfo\n          )\n        }\n        return message\n      }\n\n      /**\n       * Creates a plain object from a NotHandled message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.NotHandled\n       * @static\n       * @param {eventstore.proto.NotHandled} message NotHandled\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      NotHandled.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.defaults) {\n          object.reason = options.enums === String ? 'NotReady' : 0\n          object.additionalInfo = null\n        }\n        if (message.reason != null && message.hasOwnProperty('reason'))\n          object.reason =\n            options.enums === String\n              ? $root.eventstore.proto.NotHandled.NotHandledReason[message.reason]\n              : message.reason\n        if (message.additionalInfo != null && message.hasOwnProperty('additionalInfo'))\n          object.additionalInfo = $root.eventstore.proto.NotHandled.MasterInfo.toObject(\n            message.additionalInfo,\n            options\n          )\n        return object\n      }\n\n      /**\n       * Converts this NotHandled to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.NotHandled\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      NotHandled.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      /**\n       * NotHandledReason enum.\n       * @name eventstore.proto.NotHandled.NotHandledReason\n       * @enum {string}\n       * @property {number} NotReady=0 NotReady value\n       * @property {number} TooBusy=1 TooBusy value\n       * @property {number} NotMaster=2 NotMaster value\n       */\n      NotHandled.NotHandledReason = (function() {\n        var valuesById = {},\n          values = Object.create(valuesById)\n        values[(valuesById[0] = 'NotReady')] = 0\n        values[(valuesById[1] = 'TooBusy')] = 1\n        values[(valuesById[2] = 'NotMaster')] = 2\n        return values\n      })()\n\n      NotHandled.MasterInfo = (function() {\n        /**\n         * Properties of a MasterInfo.\n         * @memberof eventstore.proto.NotHandled\n         * @interface IMasterInfo\n         * @property {string} externalTcpAddress MasterInfo externalTcpAddress\n         * @property {number} externalTcpPort MasterInfo externalTcpPort\n         * @property {string} externalHttpAddress MasterInfo externalHttpAddress\n         * @property {number} externalHttpPort MasterInfo externalHttpPort\n         * @property {string|null} [externalSecureTcpAddress] MasterInfo externalSecureTcpAddress\n         * @property {number|null} [externalSecureTcpPort] MasterInfo externalSecureTcpPort\n         */\n\n        /**\n         * Constructs a new MasterInfo.\n         * @memberof eventstore.proto.NotHandled\n         * @classdesc Represents a MasterInfo.\n         * @implements IMasterInfo\n         * @constructor\n         * @param {eventstore.proto.NotHandled.IMasterInfo=} [properties] Properties to set\n         */\n        function MasterInfo(properties) {\n          if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n        }\n\n        /**\n         * MasterInfo externalTcpAddress.\n         * @member {string} externalTcpAddress\n         * @memberof eventstore.proto.NotHandled.MasterInfo\n         * @instance\n         */\n        MasterInfo.prototype.externalTcpAddress = ''\n\n        /**\n         * MasterInfo externalTcpPort.\n         * @member {number} externalTcpPort\n         * @memberof eventstore.proto.NotHandled.MasterInfo\n         * @instance\n         */\n        MasterInfo.prototype.externalTcpPort = 0\n\n        /**\n         * MasterInfo externalHttpAddress.\n         * @member {string} externalHttpAddress\n         * @memberof eventstore.proto.NotHandled.MasterInfo\n         * @instance\n         */\n        MasterInfo.prototype.externalHttpAddress = ''\n\n        /**\n         * MasterInfo externalHttpPort.\n         * @member {number} externalHttpPort\n         * @memberof eventstore.proto.NotHandled.MasterInfo\n         * @instance\n         */\n        MasterInfo.prototype.externalHttpPort = 0\n\n        /**\n         * MasterInfo externalSecureTcpAddress.\n         * @member {string} externalSecureTcpAddress\n         * @memberof eventstore.proto.NotHandled.MasterInfo\n         * @instance\n         */\n        MasterInfo.prototype.externalSecureTcpAddress = ''\n\n        /**\n         * MasterInfo externalSecureTcpPort.\n         * @member {number} externalSecureTcpPort\n         * @memberof eventstore.proto.NotHandled.MasterInfo\n         * @instance\n         */\n        MasterInfo.prototype.externalSecureTcpPort = 0\n\n        /**\n         * Creates a new MasterInfo instance using the specified properties.\n         * @function create\n         * @memberof eventstore.proto.NotHandled.MasterInfo\n         * @static\n         * @param {eventstore.proto.NotHandled.IMasterInfo=} [properties] Properties to set\n         * @returns {eventstore.proto.NotHandled.MasterInfo} MasterInfo instance\n         */\n        MasterInfo.create = function create(properties) {\n          return new MasterInfo(properties)\n        }\n\n        /**\n         * Encodes the specified MasterInfo message. Does not implicitly {@link eventstore.proto.NotHandled.MasterInfo.verify|verify} messages.\n         * @function encode\n         * @memberof eventstore.proto.NotHandled.MasterInfo\n         * @static\n         * @param {eventstore.proto.NotHandled.IMasterInfo} message MasterInfo message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        MasterInfo.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create()\n          writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.externalTcpAddress)\n          writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.externalTcpPort)\n          writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.externalHttpAddress)\n          writer.uint32(/* id 4, wireType 0 =*/ 32).int32(message.externalHttpPort)\n          if (\n            message.externalSecureTcpAddress != null &&\n            message.hasOwnProperty('externalSecureTcpAddress')\n          )\n            writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.externalSecureTcpAddress)\n          if (\n            message.externalSecureTcpPort != null &&\n            message.hasOwnProperty('externalSecureTcpPort')\n          )\n            writer.uint32(/* id 6, wireType 0 =*/ 48).int32(message.externalSecureTcpPort)\n          return writer\n        }\n\n        /**\n         * Encodes the specified MasterInfo message, length delimited. Does not implicitly {@link eventstore.proto.NotHandled.MasterInfo.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof eventstore.proto.NotHandled.MasterInfo\n         * @static\n         * @param {eventstore.proto.NotHandled.IMasterInfo} message MasterInfo message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        MasterInfo.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim()\n        }\n\n        /**\n         * Decodes a MasterInfo message from the specified reader or buffer.\n         * @function decode\n         * @memberof eventstore.proto.NotHandled.MasterInfo\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {eventstore.proto.NotHandled.MasterInfo} MasterInfo\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        MasterInfo.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n          var end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.eventstore.proto.NotHandled.MasterInfo()\n          while (reader.pos < end) {\n            var tag = reader.uint32()\n            switch (tag >>> 3) {\n              case 1:\n                message.externalTcpAddress = reader.string()\n                break\n              case 2:\n                message.externalTcpPort = reader.int32()\n                break\n              case 3:\n                message.externalHttpAddress = reader.string()\n                break\n              case 4:\n                message.externalHttpPort = reader.int32()\n                break\n              case 5:\n                message.externalSecureTcpAddress = reader.string()\n                break\n              case 6:\n                message.externalSecureTcpPort = reader.int32()\n                break\n              default:\n                reader.skipType(tag & 7)\n                break\n            }\n          }\n          if (!message.hasOwnProperty('externalTcpAddress'))\n            throw $util.ProtocolError(\"missing required 'externalTcpAddress'\", {\n              instance: message\n            })\n          if (!message.hasOwnProperty('externalTcpPort'))\n            throw $util.ProtocolError(\"missing required 'externalTcpPort'\", {\n              instance: message\n            })\n          if (!message.hasOwnProperty('externalHttpAddress'))\n            throw $util.ProtocolError(\"missing required 'externalHttpAddress'\", {\n              instance: message\n            })\n          if (!message.hasOwnProperty('externalHttpPort'))\n            throw $util.ProtocolError(\"missing required 'externalHttpPort'\", {\n              instance: message\n            })\n          return message\n        }\n\n        /**\n         * Decodes a MasterInfo message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof eventstore.proto.NotHandled.MasterInfo\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {eventstore.proto.NotHandled.MasterInfo} MasterInfo\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        MasterInfo.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n          return this.decode(reader, reader.uint32())\n        }\n\n        /**\n         * Verifies a MasterInfo message.\n         * @function verify\n         * @memberof eventstore.proto.NotHandled.MasterInfo\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        MasterInfo.verify = function verify(message) {\n          if (typeof message !== 'object' || message === null) return 'object expected'\n          if (!$util.isString(message.externalTcpAddress))\n            return 'externalTcpAddress: string expected'\n          if (!$util.isInteger(message.externalTcpPort)) return 'externalTcpPort: integer expected'\n          if (!$util.isString(message.externalHttpAddress))\n            return 'externalHttpAddress: string expected'\n          if (!$util.isInteger(message.externalHttpPort))\n            return 'externalHttpPort: integer expected'\n          if (\n            message.externalSecureTcpAddress != null &&\n            message.hasOwnProperty('externalSecureTcpAddress')\n          )\n            if (!$util.isString(message.externalSecureTcpAddress))\n              return 'externalSecureTcpAddress: string expected'\n          if (\n            message.externalSecureTcpPort != null &&\n            message.hasOwnProperty('externalSecureTcpPort')\n          )\n            if (!$util.isInteger(message.externalSecureTcpPort))\n              return 'externalSecureTcpPort: integer expected'\n          return null\n        }\n\n        /**\n         * Creates a MasterInfo message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof eventstore.proto.NotHandled.MasterInfo\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {eventstore.proto.NotHandled.MasterInfo} MasterInfo\n         */\n        MasterInfo.fromObject = function fromObject(object) {\n          if (object instanceof $root.eventstore.proto.NotHandled.MasterInfo) return object\n          var message = new $root.eventstore.proto.NotHandled.MasterInfo()\n          if (object.externalTcpAddress != null)\n            message.externalTcpAddress = String(object.externalTcpAddress)\n          if (object.externalTcpPort != null) message.externalTcpPort = object.externalTcpPort | 0\n          if (object.externalHttpAddress != null)\n            message.externalHttpAddress = String(object.externalHttpAddress)\n          if (object.externalHttpPort != null)\n            message.externalHttpPort = object.externalHttpPort | 0\n          if (object.externalSecureTcpAddress != null)\n            message.externalSecureTcpAddress = String(object.externalSecureTcpAddress)\n          if (object.externalSecureTcpPort != null)\n            message.externalSecureTcpPort = object.externalSecureTcpPort | 0\n          return message\n        }\n\n        /**\n         * Creates a plain object from a MasterInfo message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof eventstore.proto.NotHandled.MasterInfo\n         * @static\n         * @param {eventstore.proto.NotHandled.MasterInfo} message MasterInfo\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        MasterInfo.toObject = function toObject(message, options) {\n          if (!options) options = {}\n          var object = {}\n          if (options.defaults) {\n            object.externalTcpAddress = ''\n            object.externalTcpPort = 0\n            object.externalHttpAddress = ''\n            object.externalHttpPort = 0\n            object.externalSecureTcpAddress = ''\n            object.externalSecureTcpPort = 0\n          }\n          if (message.externalTcpAddress != null && message.hasOwnProperty('externalTcpAddress'))\n            object.externalTcpAddress = message.externalTcpAddress\n          if (message.externalTcpPort != null && message.hasOwnProperty('externalTcpPort'))\n            object.externalTcpPort = message.externalTcpPort\n          if (message.externalHttpAddress != null && message.hasOwnProperty('externalHttpAddress'))\n            object.externalHttpAddress = message.externalHttpAddress\n          if (message.externalHttpPort != null && message.hasOwnProperty('externalHttpPort'))\n            object.externalHttpPort = message.externalHttpPort\n          if (\n            message.externalSecureTcpAddress != null &&\n            message.hasOwnProperty('externalSecureTcpAddress')\n          )\n            object.externalSecureTcpAddress = message.externalSecureTcpAddress\n          if (\n            message.externalSecureTcpPort != null &&\n            message.hasOwnProperty('externalSecureTcpPort')\n          )\n            object.externalSecureTcpPort = message.externalSecureTcpPort\n          return object\n        }\n\n        /**\n         * Converts this MasterInfo to JSON.\n         * @function toJSON\n         * @memberof eventstore.proto.NotHandled.MasterInfo\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        MasterInfo.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n        }\n\n        return MasterInfo\n      })()\n\n      return NotHandled\n    })()\n\n    proto.ScavengeDatabase = (function() {\n      /**\n       * Properties of a ScavengeDatabase.\n       * @memberof eventstore.proto\n       * @interface IScavengeDatabase\n       */\n\n      /**\n       * Constructs a new ScavengeDatabase.\n       * @memberof eventstore.proto\n       * @classdesc Represents a ScavengeDatabase.\n       * @implements IScavengeDatabase\n       * @constructor\n       * @param {eventstore.proto.IScavengeDatabase=} [properties] Properties to set\n       */\n      function ScavengeDatabase(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * Creates a new ScavengeDatabase instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.ScavengeDatabase\n       * @static\n       * @param {eventstore.proto.IScavengeDatabase=} [properties] Properties to set\n       * @returns {eventstore.proto.ScavengeDatabase} ScavengeDatabase instance\n       */\n      ScavengeDatabase.create = function create(properties) {\n        return new ScavengeDatabase(properties)\n      }\n\n      /**\n       * Encodes the specified ScavengeDatabase message. Does not implicitly {@link eventstore.proto.ScavengeDatabase.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.ScavengeDatabase\n       * @static\n       * @param {eventstore.proto.IScavengeDatabase} message ScavengeDatabase message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      ScavengeDatabase.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        return writer\n      }\n\n      /**\n       * Encodes the specified ScavengeDatabase message, length delimited. Does not implicitly {@link eventstore.proto.ScavengeDatabase.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.ScavengeDatabase\n       * @static\n       * @param {eventstore.proto.IScavengeDatabase} message ScavengeDatabase message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      ScavengeDatabase.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes a ScavengeDatabase message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.ScavengeDatabase\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.ScavengeDatabase} ScavengeDatabase\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      ScavengeDatabase.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.ScavengeDatabase()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        return message\n      }\n\n      /**\n       * Decodes a ScavengeDatabase message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.ScavengeDatabase\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.ScavengeDatabase} ScavengeDatabase\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      ScavengeDatabase.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies a ScavengeDatabase message.\n       * @function verify\n       * @memberof eventstore.proto.ScavengeDatabase\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      ScavengeDatabase.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        return null\n      }\n\n      /**\n       * Creates a ScavengeDatabase message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.ScavengeDatabase\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.ScavengeDatabase} ScavengeDatabase\n       */\n      ScavengeDatabase.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.ScavengeDatabase) return object\n        return new $root.eventstore.proto.ScavengeDatabase()\n      }\n\n      /**\n       * Creates a plain object from a ScavengeDatabase message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.ScavengeDatabase\n       * @static\n       * @param {eventstore.proto.ScavengeDatabase} message ScavengeDatabase\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      ScavengeDatabase.toObject = function toObject() {\n        return {}\n      }\n\n      /**\n       * Converts this ScavengeDatabase to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.ScavengeDatabase\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      ScavengeDatabase.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      return ScavengeDatabase\n    })()\n\n    proto.ScavengeDatabaseResponse = (function() {\n      /**\n       * Properties of a ScavengeDatabaseResponse.\n       * @memberof eventstore.proto\n       * @interface IScavengeDatabaseResponse\n       * @property {eventstore.proto.ScavengeDatabaseResponse.ScavengeResult} result ScavengeDatabaseResponse result\n       * @property {string|null} [scavengeId] ScavengeDatabaseResponse scavengeId\n       */\n\n      /**\n       * Constructs a new ScavengeDatabaseResponse.\n       * @memberof eventstore.proto\n       * @classdesc Represents a ScavengeDatabaseResponse.\n       * @implements IScavengeDatabaseResponse\n       * @constructor\n       * @param {eventstore.proto.IScavengeDatabaseResponse=} [properties] Properties to set\n       */\n      function ScavengeDatabaseResponse(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * ScavengeDatabaseResponse result.\n       * @member {eventstore.proto.ScavengeDatabaseResponse.ScavengeResult} result\n       * @memberof eventstore.proto.ScavengeDatabaseResponse\n       * @instance\n       */\n      ScavengeDatabaseResponse.prototype.result = 0\n\n      /**\n       * ScavengeDatabaseResponse scavengeId.\n       * @member {string} scavengeId\n       * @memberof eventstore.proto.ScavengeDatabaseResponse\n       * @instance\n       */\n      ScavengeDatabaseResponse.prototype.scavengeId = ''\n\n      /**\n       * Creates a new ScavengeDatabaseResponse instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.ScavengeDatabaseResponse\n       * @static\n       * @param {eventstore.proto.IScavengeDatabaseResponse=} [properties] Properties to set\n       * @returns {eventstore.proto.ScavengeDatabaseResponse} ScavengeDatabaseResponse instance\n       */\n      ScavengeDatabaseResponse.create = function create(properties) {\n        return new ScavengeDatabaseResponse(properties)\n      }\n\n      /**\n       * Encodes the specified ScavengeDatabaseResponse message. Does not implicitly {@link eventstore.proto.ScavengeDatabaseResponse.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.ScavengeDatabaseResponse\n       * @static\n       * @param {eventstore.proto.IScavengeDatabaseResponse} message ScavengeDatabaseResponse message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      ScavengeDatabaseResponse.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.result)\n        if (message.scavengeId != null && message.hasOwnProperty('scavengeId'))\n          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.scavengeId)\n        return writer\n      }\n\n      /**\n       * Encodes the specified ScavengeDatabaseResponse message, length delimited. Does not implicitly {@link eventstore.proto.ScavengeDatabaseResponse.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.ScavengeDatabaseResponse\n       * @static\n       * @param {eventstore.proto.IScavengeDatabaseResponse} message ScavengeDatabaseResponse message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      ScavengeDatabaseResponse.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes a ScavengeDatabaseResponse message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.ScavengeDatabaseResponse\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.ScavengeDatabaseResponse} ScavengeDatabaseResponse\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      ScavengeDatabaseResponse.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.ScavengeDatabaseResponse()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              message.result = reader.int32()\n              break\n            case 2:\n              message.scavengeId = reader.string()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        if (!message.hasOwnProperty('result'))\n          throw $util.ProtocolError(\"missing required 'result'\", {\n            instance: message\n          })\n        return message\n      }\n\n      /**\n       * Decodes a ScavengeDatabaseResponse message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.ScavengeDatabaseResponse\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.ScavengeDatabaseResponse} ScavengeDatabaseResponse\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      ScavengeDatabaseResponse.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies a ScavengeDatabaseResponse message.\n       * @function verify\n       * @memberof eventstore.proto.ScavengeDatabaseResponse\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      ScavengeDatabaseResponse.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        switch (message.result) {\n          default:\n            return 'result: enum value expected'\n          case 0:\n          case 1:\n          case 2:\n            break\n        }\n        if (message.scavengeId != null && message.hasOwnProperty('scavengeId'))\n          if (!$util.isString(message.scavengeId)) return 'scavengeId: string expected'\n        return null\n      }\n\n      /**\n       * Creates a ScavengeDatabaseResponse message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.ScavengeDatabaseResponse\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.ScavengeDatabaseResponse} ScavengeDatabaseResponse\n       */\n      ScavengeDatabaseResponse.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.ScavengeDatabaseResponse) return object\n        var message = new $root.eventstore.proto.ScavengeDatabaseResponse()\n        switch (object.result) {\n          case 'Started':\n          case 0:\n            message.result = 0\n            break\n          case 'InProgress':\n          case 1:\n            message.result = 1\n            break\n          case 'Unauthorized':\n          case 2:\n            message.result = 2\n            break\n        }\n        if (object.scavengeId != null) message.scavengeId = String(object.scavengeId)\n        return message\n      }\n\n      /**\n       * Creates a plain object from a ScavengeDatabaseResponse message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.ScavengeDatabaseResponse\n       * @static\n       * @param {eventstore.proto.ScavengeDatabaseResponse} message ScavengeDatabaseResponse\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      ScavengeDatabaseResponse.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.defaults) {\n          object.result = options.enums === String ? 'Started' : 0\n          object.scavengeId = ''\n        }\n        if (message.result != null && message.hasOwnProperty('result'))\n          object.result =\n            options.enums === String\n              ? $root.eventstore.proto.ScavengeDatabaseResponse.ScavengeResult[message.result]\n              : message.result\n        if (message.scavengeId != null && message.hasOwnProperty('scavengeId'))\n          object.scavengeId = message.scavengeId\n        return object\n      }\n\n      /**\n       * Converts this ScavengeDatabaseResponse to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.ScavengeDatabaseResponse\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      ScavengeDatabaseResponse.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      /**\n       * ScavengeResult enum.\n       * @name eventstore.proto.ScavengeDatabaseResponse.ScavengeResult\n       * @enum {string}\n       * @property {number} Started=0 Started value\n       * @property {number} InProgress=1 InProgress value\n       * @property {number} Unauthorized=2 Unauthorized value\n       */\n      ScavengeDatabaseResponse.ScavengeResult = (function() {\n        var valuesById = {},\n          values = Object.create(valuesById)\n        values[(valuesById[0] = 'Started')] = 0\n        values[(valuesById[1] = 'InProgress')] = 1\n        values[(valuesById[2] = 'Unauthorized')] = 2\n        return values\n      })()\n\n      return ScavengeDatabaseResponse\n    })()\n\n    proto.IdentifyClient = (function() {\n      /**\n       * Properties of an IdentifyClient.\n       * @memberof eventstore.proto\n       * @interface IIdentifyClient\n       * @property {number} version IdentifyClient version\n       * @property {string|null} [connectionName] IdentifyClient connectionName\n       */\n\n      /**\n       * Constructs a new IdentifyClient.\n       * @memberof eventstore.proto\n       * @classdesc Represents an IdentifyClient.\n       * @implements IIdentifyClient\n       * @constructor\n       * @param {eventstore.proto.IIdentifyClient=} [properties] Properties to set\n       */\n      function IdentifyClient(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * IdentifyClient version.\n       * @member {number} version\n       * @memberof eventstore.proto.IdentifyClient\n       * @instance\n       */\n      IdentifyClient.prototype.version = 0\n\n      /**\n       * IdentifyClient connectionName.\n       * @member {string} connectionName\n       * @memberof eventstore.proto.IdentifyClient\n       * @instance\n       */\n      IdentifyClient.prototype.connectionName = ''\n\n      /**\n       * Creates a new IdentifyClient instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.IdentifyClient\n       * @static\n       * @param {eventstore.proto.IIdentifyClient=} [properties] Properties to set\n       * @returns {eventstore.proto.IdentifyClient} IdentifyClient instance\n       */\n      IdentifyClient.create = function create(properties) {\n        return new IdentifyClient(properties)\n      }\n\n      /**\n       * Encodes the specified IdentifyClient message. Does not implicitly {@link eventstore.proto.IdentifyClient.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.IdentifyClient\n       * @static\n       * @param {eventstore.proto.IIdentifyClient} message IdentifyClient message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      IdentifyClient.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.version)\n        if (message.connectionName != null && message.hasOwnProperty('connectionName'))\n          writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.connectionName)\n        return writer\n      }\n\n      /**\n       * Encodes the specified IdentifyClient message, length delimited. Does not implicitly {@link eventstore.proto.IdentifyClient.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.IdentifyClient\n       * @static\n       * @param {eventstore.proto.IIdentifyClient} message IdentifyClient message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      IdentifyClient.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes an IdentifyClient message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.IdentifyClient\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.IdentifyClient} IdentifyClient\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      IdentifyClient.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.IdentifyClient()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            case 1:\n              message.version = reader.int32()\n              break\n            case 2:\n              message.connectionName = reader.string()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        if (!message.hasOwnProperty('version'))\n          throw $util.ProtocolError(\"missing required 'version'\", {\n            instance: message\n          })\n        return message\n      }\n\n      /**\n       * Decodes an IdentifyClient message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.IdentifyClient\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.IdentifyClient} IdentifyClient\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      IdentifyClient.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies an IdentifyClient message.\n       * @function verify\n       * @memberof eventstore.proto.IdentifyClient\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      IdentifyClient.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        if (!$util.isInteger(message.version)) return 'version: integer expected'\n        if (message.connectionName != null && message.hasOwnProperty('connectionName'))\n          if (!$util.isString(message.connectionName)) return 'connectionName: string expected'\n        return null\n      }\n\n      /**\n       * Creates an IdentifyClient message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.IdentifyClient\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.IdentifyClient} IdentifyClient\n       */\n      IdentifyClient.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.IdentifyClient) return object\n        var message = new $root.eventstore.proto.IdentifyClient()\n        if (object.version != null) message.version = object.version | 0\n        if (object.connectionName != null) message.connectionName = String(object.connectionName)\n        return message\n      }\n\n      /**\n       * Creates a plain object from an IdentifyClient message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.IdentifyClient\n       * @static\n       * @param {eventstore.proto.IdentifyClient} message IdentifyClient\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      IdentifyClient.toObject = function toObject(message, options) {\n        if (!options) options = {}\n        var object = {}\n        if (options.defaults) {\n          object.version = 0\n          object.connectionName = ''\n        }\n        if (message.version != null && message.hasOwnProperty('version'))\n          object.version = message.version\n        if (message.connectionName != null && message.hasOwnProperty('connectionName'))\n          object.connectionName = message.connectionName\n        return object\n      }\n\n      /**\n       * Converts this IdentifyClient to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.IdentifyClient\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      IdentifyClient.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      return IdentifyClient\n    })()\n\n    proto.ClientIdentified = (function() {\n      /**\n       * Properties of a ClientIdentified.\n       * @memberof eventstore.proto\n       * @interface IClientIdentified\n       */\n\n      /**\n       * Constructs a new ClientIdentified.\n       * @memberof eventstore.proto\n       * @classdesc Represents a ClientIdentified.\n       * @implements IClientIdentified\n       * @constructor\n       * @param {eventstore.proto.IClientIdentified=} [properties] Properties to set\n       */\n      function ClientIdentified(properties) {\n        if (properties)\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]]\n      }\n\n      /**\n       * Creates a new ClientIdentified instance using the specified properties.\n       * @function create\n       * @memberof eventstore.proto.ClientIdentified\n       * @static\n       * @param {eventstore.proto.IClientIdentified=} [properties] Properties to set\n       * @returns {eventstore.proto.ClientIdentified} ClientIdentified instance\n       */\n      ClientIdentified.create = function create(properties) {\n        return new ClientIdentified(properties)\n      }\n\n      /**\n       * Encodes the specified ClientIdentified message. Does not implicitly {@link eventstore.proto.ClientIdentified.verify|verify} messages.\n       * @function encode\n       * @memberof eventstore.proto.ClientIdentified\n       * @static\n       * @param {eventstore.proto.IClientIdentified} message ClientIdentified message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      ClientIdentified.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create()\n        return writer\n      }\n\n      /**\n       * Encodes the specified ClientIdentified message, length delimited. Does not implicitly {@link eventstore.proto.ClientIdentified.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof eventstore.proto.ClientIdentified\n       * @static\n       * @param {eventstore.proto.IClientIdentified} message ClientIdentified message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n      ClientIdentified.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim()\n      }\n\n      /**\n       * Decodes a ClientIdentified message from the specified reader or buffer.\n       * @function decode\n       * @memberof eventstore.proto.ClientIdentified\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {eventstore.proto.ClientIdentified} ClientIdentified\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      ClientIdentified.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader)\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.eventstore.proto.ClientIdentified()\n        while (reader.pos < end) {\n          var tag = reader.uint32()\n          switch (tag >>> 3) {\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n        return message\n      }\n\n      /**\n       * Decodes a ClientIdentified message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof eventstore.proto.ClientIdentified\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {eventstore.proto.ClientIdentified} ClientIdentified\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      ClientIdentified.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader)\n        return this.decode(reader, reader.uint32())\n      }\n\n      /**\n       * Verifies a ClientIdentified message.\n       * @function verify\n       * @memberof eventstore.proto.ClientIdentified\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n      ClientIdentified.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected'\n        return null\n      }\n\n      /**\n       * Creates a ClientIdentified message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof eventstore.proto.ClientIdentified\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {eventstore.proto.ClientIdentified} ClientIdentified\n       */\n      ClientIdentified.fromObject = function fromObject(object) {\n        if (object instanceof $root.eventstore.proto.ClientIdentified) return object\n        return new $root.eventstore.proto.ClientIdentified()\n      }\n\n      /**\n       * Creates a plain object from a ClientIdentified message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof eventstore.proto.ClientIdentified\n       * @static\n       * @param {eventstore.proto.ClientIdentified} message ClientIdentified\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n      ClientIdentified.toObject = function toObject() {\n        return {}\n      }\n\n      /**\n       * Converts this ClientIdentified to JSON.\n       * @function toJSON\n       * @memberof eventstore.proto.ClientIdentified\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n      ClientIdentified.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions)\n      }\n\n      return ClientIdentified\n    })()\n\n    return proto\n  })()\n\n  return eventstore\n})()\n\nmodule.exports = $root\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/src/protobuf/model.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 300,
    "kind": "variable",
    "name": "$protobuf",
    "memberof": "src/protobuf/model.js",
    "static": true,
    "longname": "src/protobuf/model.js~$protobuf",
    "access": "public",
    "export": false,
    "importPath": "eventstore-ts-client/src/protobuf/model.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 301,
    "kind": "variable",
    "name": "$Reader",
    "memberof": "src/protobuf/model.js",
    "static": true,
    "longname": "src/protobuf/model.js~$Reader",
    "access": "public",
    "export": false,
    "importPath": "eventstore-ts-client/src/protobuf/model.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 302,
    "kind": "variable",
    "name": "$root",
    "memberof": "src/protobuf/model.js",
    "static": true,
    "longname": "src/protobuf/model.js~$root",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/protobuf/model.js",
    "importStyle": "$root",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 303,
    "kind": "file",
    "name": "src/protobuf/uuidBufferConvert.ts",
    "content": "import * as eventstoreError from '../errors'\n\n/**\n * Converts a uuid as string from buffer\n * It returns an empty string for uuid set to null or throws EventstoreProtocolError for invalid buffer length\n */\nexport function uuidFromBuffer(buffer: Buffer): string {\n  if (buffer.length !== 16) {\n    throw eventstoreError.newProtocolError(`Invalid buffer length for uuid: ${buffer.length}`)\n  }\n\n  if (buffer.equals(Buffer.alloc(16))) {\n    return ''\n  }\n\n  const str = buffer.toString('hex')\n  return `${str.slice(0, 8)}-${str.slice(8, 12)}-${str.slice(12, 16)}-${str.slice(\n    16,\n    20\n  )}-${str.slice(20)}`\n}\n\n/**\n * Converts a uuid string to buffer representation\n * throws EventstoreProtocolError for invalid input string length\n */\nexport function uuidToBuffer(uuid: string | null): Buffer {\n  if (!uuid) {\n    return Buffer.alloc(16)\n  }\n  const hexStr = uuid.replace(/-/g, '')\n  if (uuid.length !== 36 || hexStr.length !== 32) {\n    throw eventstoreError.newProtocolError(`Invalid UUID string: ${uuid}`)\n  }\n  return Buffer.from(hexStr, 'hex')\n}\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/src/protobuf/uuidBufferConvert.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 304,
    "kind": "function",
    "name": "uuidFromBuffer",
    "memberof": "src/protobuf/uuidBufferConvert.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/protobuf/uuidBufferConvert.ts~uuidFromBuffer",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/protobuf/uuidBufferConvert.ts",
    "importStyle": "{uuidFromBuffer}",
    "description": "Converts a uuid as string from buffer\nIt returns an empty string for uuid set to null or throws EventstoreProtocolError for invalid buffer length",
    "lineNumber": 7,
    "params": [
      {
        "types": [
          "Buffer"
        ],
        "name": "buffer"
      }
    ],
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 305,
    "kind": "function",
    "name": "uuidToBuffer",
    "memberof": "src/protobuf/uuidBufferConvert.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/protobuf/uuidBufferConvert.ts~uuidToBuffer",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/protobuf/uuidBufferConvert.ts",
    "importStyle": "{uuidToBuffer}",
    "description": "Converts a uuid string to buffer representation\nthrows EventstoreProtocolError for invalid input string length",
    "lineNumber": 27,
    "params": [
      {
        "types": [
          "string",
          "null"
        ],
        "name": "uuid"
      }
    ],
    "type": {
      "types": [
        "Buffer"
      ]
    }
  },
  {
    "__docId__": 306,
    "kind": "file",
    "name": "src/stream/Stream.ts",
    "content": "import {Eventstore, WriteResult, Position} from '../eventstore'\nimport {Event} from '../event'\nimport uuid = require('uuid/v4')\nimport * as bunyan from 'bunyan'\nimport * as model from '../protobuf/model'\nimport {EventstoreCommand} from '../protobuf/EventstoreCommand'\nimport {ExpectedVersion} from '../protobuf/ExpectedVersion'\nimport {StreamPosition} from './StreamPosition'\nimport {Transaction} from './Transaction'\nimport {\n  Subscription,\n  PersistentSubscriptionConfig,\n  setPersistentSubscriptionConfig,\n  PersistentSubscription\n} from '../subscription'\nimport * as eventstoreError from '../errors'\nimport {UserCredentials} from '../eventstore/EventstoreSettings'\nimport Long = require('long')\nimport {JSONValue} from '../JSON'\nimport {StreamWalker} from '../StreamWalker'\n\n/** protobuf shorthand */\nconst protobuf = model.eventstore.proto\n\n/**\n * @typedef {object} StreamOptions\n * @property {boolean} requireMaster indicates if operations require master node\n * @property {boolean} resolveLinks indicates if event links should be resolved on read operations\n * @property {UserCredentials | null} credentials user credentials if others than default connection credentials\n */\nexport interface StreamOptions {\n  requireMaster: boolean\n  resolveLinks: boolean\n  credentials: UserCredentials | null\n}\n\n/**\n * Base class for handling a stream\n */\nexport class Stream {\n  /** eventstore instance */\n  protected esConnection: Eventstore\n  /** bunyan logger */\n  public log: bunyan\n  /** id of stream */\n  protected streamId: string\n  /** stream options */\n  protected options: StreamOptions\n  /** default read slice size */\n  protected defaultSliceSize: number = 100\n\n  /**\n   * Creates an instance of Stream.\n   */\n  public constructor(eventstore: Eventstore, streamId: string, options: StreamOptions) {\n    this.esConnection = eventstore\n    this.streamId = streamId\n    this.log = this.esConnection.logger.child\n      ? this.esConnection.logger.child({module: 'Stream'})\n      : this.esConnection.logger\n\n    this.options = options\n  }\n\n  /**\n   * Return name of stream instance\n   */\n  public get name(): string {\n    return 'Stream: ' + this.streamId\n  }\n\n  /**\n   * Gets id  of stream\n   */\n  public get id(): string {\n    return this.streamId\n  }\n\n  /**\n   * Enforces to use master node for any read/write operation\n   */\n  public requiresMaster(): Stream {\n    this.options.requireMaster = true\n    return this\n  }\n\n  /**\n   * Set credentials for any read/write operation\n   */\n  public withCredentials(credentials: UserCredentials): Stream {\n    this.options.credentials = credentials\n    return this\n  }\n\n  /**\n   * Enforce to resolve links on read operations\n   */\n  public resolveAllLinks(): Stream {\n    this.options.resolveLinks = true\n    return this\n  }\n\n  /**\n   * Appends array of events to stream\n   */\n  protected appendEvents(\n    events: Event[],\n    expectedVersion: ExpectedVersion | number | Long = -2,\n    requireMaster?: boolean,\n    credentials?: UserCredentials\n  ): Promise<WriteResult> {\n    if (requireMaster === undefined) {\n      requireMaster = this.options.requireMaster\n    }\n    const eventArrayTransformed: model.eventstore.proto.NewEvent[] = events.map(\n      (event): model.eventstore.proto.NewEvent => {\n        if (!event.isNew()) {\n          throw eventstoreError.newOperationError(\n            `Event ${event.name} is already stored in eventstore`\n          )\n        }\n        return event.toRaw()\n      }\n    )\n\n    const raw = protobuf.WriteEvents.fromObject({\n      eventStreamId: this.streamId,\n      expectedVersion: expectedVersion,\n      events: eventArrayTransformed,\n      requireMaster: requireMaster === undefined ? this.options.requireMaster : requireMaster\n    })\n    return new Promise(\n      (resolve, reject): void => {\n        const setToWritten = (): void => {\n          events.forEach((event): void => event.freeze())\n          resolve()\n        }\n\n        this.esConnection\n          .getConnection()\n          .sendCommand(\n            uuid(),\n            EventstoreCommand.WriteEvents,\n            Buffer.from(protobuf.WriteEvents.encode(raw).finish()),\n            credentials || this.options.credentials,\n            {\n              resolve: setToWritten,\n              reject\n            }\n          )\n      }\n    )\n  }\n\n  /**\n   * Indicates if given stream is a metadata stream or a regular steam\n   */\n  public isMetaStream(): boolean {\n    return this.streamId.startsWith('$$')\n  }\n\n  /**\n   * Append single event or array of events to stream\n   */\n  public async append(\n    event: Event | Event[],\n    expectedVersion: ExpectedVersion | number | Long = -2,\n    requireMaster?: boolean,\n    credentials?: UserCredentials\n  ): Promise<WriteResult> {\n    if (Array.isArray(event)) {\n      return await this.appendEvents(event, expectedVersion, requireMaster, credentials)\n    } else {\n      return await this.appendEvents([event], expectedVersion, requireMaster, credentials)\n    }\n  }\n\n  /**\n   * Hard deletes a stream - stream with same name can not be used in future\n   */\n  public async hardDelete(\n    expectedVersion: ExpectedVersion = ExpectedVersion.Any,\n    requireMaster?: boolean,\n    credentials?: UserCredentials\n  ): Promise<Position> {\n    this.log.debug(\n      {fn: 'hardDelete', streamId: this.streamId},\n      `Hard delete Stream ${this.streamId}`\n    )\n    return await this.delete(true, expectedVersion, requireMaster, credentials)\n  }\n\n  /**\n   * Soft deletes a stream - stream with same name can be used in future and indexes are preserved\n   */\n  public async softDelete(\n    expectedVersion: ExpectedVersion = ExpectedVersion.Any,\n    requireMaster?: boolean,\n    credentials?: UserCredentials\n  ): Promise<Position> {\n    this.log.debug(\n      {fn: 'softDelete', streamId: this.streamId},\n      `Soft delete Stream ${this.streamId}`\n    )\n    return await this.delete(false, expectedVersion, requireMaster, credentials)\n  }\n\n  /**\n   * Delete a stream - can't be called directly\n   * Use softDelete or hardDelete instead\n   */\n  protected delete(\n    hardDelete: boolean,\n    expectedVersion: ExpectedVersion = ExpectedVersion.Any,\n    requireMaster?: boolean,\n    credentials?: UserCredentials\n  ): Promise<Position> {\n    if (this.isMetaStream()) {\n      throw eventstoreError.newBadRequestError(\n        `You can not delete metadata stream ${this.streamId}`\n      )\n    }\n    if (requireMaster === undefined) {\n      requireMaster = this.options.requireMaster\n    }\n    return new Promise(\n      (resolve, reject): void => {\n        const raw = protobuf.DeleteStream.fromObject({\n          eventStreamId: this.streamId,\n          expectedVersion,\n          requireMaster: requireMaster === undefined ? this.requiresMaster : requireMaster,\n          hardDelete\n        })\n        this.esConnection\n          .getConnection()\n          .sendCommand(\n            uuid(),\n            EventstoreCommand.DeleteStream,\n            Buffer.from(protobuf.DeleteStream.encode(raw).finish()),\n            credentials || this.options.credentials,\n            {\n              resolve,\n              reject\n            }\n          )\n      }\n    )\n  }\n\n  /**\n   * Get event at specified position from stream\n   */\n  public async getEventByNumber(\n    eventNumber: Long | number,\n    resolveLinks?: boolean,\n    requireMaster?: boolean,\n    credentials?: UserCredentials\n  ): Promise<Event | null> {\n    if (requireMaster === undefined) {\n      requireMaster = this.options.requireMaster\n    }\n    const result: model.eventstore.proto.IResolvedIndexedEvent = await new Promise(\n      (resolve, reject): void => {\n        const raw = protobuf.ReadEvent.fromObject({\n          eventStreamId: this.streamId,\n          eventNumber: eventNumber,\n          resolveLinkTos: resolveLinks === undefined ? this.options.resolveLinks : resolveLinks,\n          requireMaster: requireMaster === undefined ? this.options.requireMaster : requireMaster\n        })\n        this.esConnection\n          .getConnection()\n          .sendCommand(\n            uuid(),\n            EventstoreCommand.ReadEvent,\n            Buffer.from(protobuf.ReadEvent.encode(raw).finish()),\n            credentials || this.options.credentials,\n            {\n              resolve,\n              reject\n            }\n          )\n      }\n    )\n    if (!result.event && !result.link) {\n      return null\n    }\n\n    return Event.fromRaw(result.event || result.link)\n  }\n\n  /**\n   * Returns first event from stream\n   */\n  public async getFirstEvent(\n    resolveLinks?: boolean,\n    requireMaster?: boolean,\n    credentials?: UserCredentials\n  ): Promise<Event | null> {\n    return await this.getEventByNumber(\n      StreamPosition.Start,\n      resolveLinks,\n      requireMaster,\n      credentials\n    )\n  }\n\n  /**\n   * Returns last event from stream\n   */\n  public async getLastEvent(\n    resolveLinks?: boolean,\n    requireMaster?: boolean,\n    credentials?: UserCredentials\n  ): Promise<Event | null> {\n    return await this.getEventByNumber(StreamPosition.End, resolveLinks, requireMaster, credentials)\n  }\n\n  /**\n   * Returns stream metadata if set or\n   */\n  public async getMetadata(\n    requireMaster?: boolean,\n    credentials?: UserCredentials\n  ): Promise<\n    | {\n        $correlationId?: string\n      } & {[k: string]: JSONValue}\n    | null\n  > {\n    if (this.isMetaStream()) {\n      throw eventstoreError.newBadRequestError(\n        `You can not get metadata of metadata stream ${this.streamId}`\n      )\n    }\n    try {\n      const metadataEvent = await this.esConnection\n        .fromStream(`$$${this.streamId}`, {\n          resolveLinks: true,\n          requireMaster: requireMaster === undefined ? this.options.requireMaster : requireMaster,\n          credentials: credentials || this.options.credentials\n        })\n        .getLastEvent()\n\n      if (metadataEvent) {\n        metadataEvent.freeze()\n        // eslint-disable-next-line @typescript-eslint/no-angle-bracket-type-assertion\n        return {...(<object>metadataEvent.data)}\n      } else return null\n    } catch (err) {\n      if (err.name === 'EventstoreNoStreamError') {\n        return null\n      }\n      throw err\n    }\n  }\n\n  /**\n   * Set metadata for stream\n   */\n  public async setMetadata(\n    newMetadata: {},\n    requireMaster?: boolean,\n    credentials?: UserCredentials\n  ): Promise<void> {\n    if (this.isMetaStream()) {\n      throw eventstoreError.newBadRequestError(\n        `You can not set metadata for metadata stream ${this.streamId}`\n      )\n    }\n    const newMetaEvent = new Event('$metadata', newMetadata)\n    await this.esConnection\n      .fromStream(`$$${this.streamId}`, {\n        resolveLinks: false,\n        requireMaster: requireMaster === undefined ? this.options.requireMaster : requireMaster,\n        credentials: credentials || this.options.credentials\n      })\n      .append(newMetaEvent, ExpectedVersion.Any, requireMaster, credentials)\n  }\n\n  /**\n   * Creates a new instance of {Transaction} for current stream\n   */\n  public async startTransaction(\n    expectedVersion: ExpectedVersion = ExpectedVersion.Any,\n    requireMaster?: boolean,\n    credentials?: UserCredentials\n  ): Promise<Transaction> {\n    if (this.isMetaStream()) {\n      throw eventstoreError.newBadRequestError(\n        `Transactions fpr metadata stream ${this.streamId} not supported`\n      )\n    }\n    const transactionId: Long = await new Promise(\n      (resolve, reject): void => {\n        const raw = protobuf.TransactionStart.fromObject({\n          eventStreamId: this.streamId,\n          expectedVersion: expectedVersion,\n          requireMaster: requireMaster === undefined ? this.options.requireMaster : requireMaster\n        })\n        this.esConnection\n          .getConnection()\n          .sendCommand(\n            uuid(),\n            EventstoreCommand.TransactionStart,\n            Buffer.from(protobuf.TransactionStart.encode(raw).finish()),\n            credentials || this.options.credentials,\n            {\n              resolve,\n              reject\n            }\n          )\n      }\n    )\n\n    return new Transaction(\n      this,\n      transactionId,\n      this.esConnection,\n      requireMaster === undefined ? this.options.requireMaster : requireMaster,\n      credentials\n    )\n  }\n\n  /**\n   * Reads a slice from current stream in given direction starting at given position\n   */\n  protected async readSlice(\n    direction: EventstoreCommand,\n    fromEventNumber: number | Long = 0,\n    maxSliceCount?: number,\n    resolveLinks?: boolean,\n    requireMaster?: boolean,\n    credentials?: UserCredentials\n  ): Promise<model.eventstore.proto.ReadStreamEventsCompleted> {\n    return await new Promise(\n      (resolve, reject): void => {\n        const raw = protobuf.ReadStreamEvents.fromObject({\n          eventStreamId: this.streamId,\n          fromEventNumber,\n          maxCount: maxSliceCount || this.defaultSliceSize,\n          resolveLinkTos: resolveLinks === undefined ? this.options.resolveLinks : resolveLinks,\n          requireMaster: requireMaster === undefined ? this.options.requireMaster : requireMaster\n        })\n        this.esConnection\n          .getConnection()\n          .sendCommand(\n            uuid(),\n            direction,\n            Buffer.from(protobuf.ReadStreamEvents.encode(raw).finish()),\n            credentials || this.options.credentials,\n            {\n              resolve,\n              reject\n            }\n          )\n      }\n    )\n  }\n\n  /**\n   * Read a slice from stream in forward direction starting at given position\n   */\n  public async readSliceForward(\n    fromEventNumber: number | Long = StreamPosition.Start,\n    maxSliceCount?: number,\n    resolveLinks?: boolean,\n    requireMaster?: boolean,\n    credentials?: UserCredentials\n  ): Promise<model.eventstore.proto.ReadStreamEventsCompleted> {\n    return await this.readSlice(\n      EventstoreCommand.ReadStreamEventsForward,\n      fromEventNumber,\n      maxSliceCount,\n      resolveLinks,\n      requireMaster,\n      credentials\n    )\n  }\n\n  /**\n   * Read a slice from stream in backward direction starting at given position\n   */\n  public async readSliceBackward(\n    fromEventNumber: number | Long = StreamPosition.End,\n    maxSliceCount?: number,\n    resolveLinks?: boolean,\n    requireMaster?: boolean,\n    credentials?: UserCredentials\n  ): Promise<model.eventstore.proto.ReadStreamEventsCompleted> {\n    return await this.readSlice(\n      EventstoreCommand.ReadStreamEventsBackward,\n      fromEventNumber,\n      maxSliceCount,\n      resolveLinks,\n      requireMaster,\n      credentials\n    )\n  }\n\n  /**\n   * Walk through all events of stream\n   */\n  protected async walkStream(\n    forward: boolean,\n    start: Long | number,\n    resolveLinks?: boolean,\n    requireMaster?: boolean,\n    credentials?: UserCredentials\n  ): Promise<StreamWalker> {\n    const that = this\n    const resolveLinksTos = resolveLinks === undefined ? this.options.resolveLinks : resolveLinks\n    const maxCount = this.defaultSliceSize\n    const getSlice = forward ? 'readSliceForward' : 'readSliceBackward'\n    if (requireMaster === undefined) {\n      requireMaster = this.options.requireMaster\n    }\n    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\n    const asyncGenerator = async function*(begin: Long | number) {\n      let index = 0\n      //fetch first slice\n      let readResult = that[getSlice](begin, maxCount, resolveLinksTos, requireMaster, credentials)\n      let result = await readResult\n      if (!result.isEndOfStream) {\n        //we have more so start fetching in background\n        begin = result.nextEventNumber\n        readResult = that[getSlice](begin, maxCount, resolveLinksTos, requireMaster, credentials)\n      }\n      while (true) {\n        if (index < result.events.length) {\n          const entry = result.events[index++]\n          yield Event.fromRaw(entry.event || entry.link)\n        } else if (result.isEndOfStream) {\n          return null\n        } else {\n          index = 0\n          //wait for background fetch and grab result\n          result = await readResult\n          if (!result.isEndOfStream) {\n            //if there are more events start fetching in background\n            begin = result.nextEventNumber\n            readResult = that[getSlice](\n              begin,\n              maxCount,\n              resolveLinksTos,\n              requireMaster,\n              credentials\n            )\n          }\n        }\n      }\n    }\n\n    return new StreamWalker(asyncGenerator(start))\n  }\n\n  /**\n   * Walk through all events in stream forward\n   */\n  public async walkStreamForward(\n    start: Long | number = StreamPosition.Start,\n    resolveLinkTos?: boolean,\n    requireMaster?: boolean,\n    credentials?: UserCredentials\n  ): Promise<StreamWalker> {\n    return await this.walkStream(true, start, resolveLinkTos, requireMaster, credentials)\n  }\n\n  /**\n   * Walk through all events in stream backward\n   */\n  public async walkStreamBackward(\n    start: Long | number = StreamPosition.End,\n    resolveLinkTos?: boolean,\n    requireMaster?: boolean,\n    credentials?: UserCredentials\n  ): Promise<StreamWalker> {\n    return await this.walkStream(false, start, resolveLinkTos, requireMaster, credentials)\n  }\n\n  /**\n   * Subscribe to current stream and return a subscription\n   */\n  public async subscribe(\n    resolveLinkTos?: boolean,\n    credentials?: UserCredentials\n  ): Promise<Subscription> {\n    return await this.esConnection\n      .getConnection()\n      .subscribeToStream(this, resolveLinkTos, credentials || this.options.credentials || null)\n  }\n\n  /**\n   * Creates a persistent subscription for current stream\n   * This operation needs admin rights and a master connection\n   */\n  public async createPersistentSubscription(\n    subscriptionGroupName: string,\n    customConfig: PersistentSubscriptionConfig | {} = {},\n    credentials?: UserCredentials\n  ): Promise<PersistentSubscription> {\n    const settings = setPersistentSubscriptionConfig(customConfig)\n\n    await new Promise(\n      (resolve, reject): void => {\n        const raw = protobuf.CreatePersistentSubscription.fromObject({\n          subscriptionGroupName,\n          eventStreamId: this.id,\n          ...settings\n        })\n        this.esConnection\n          .getConnection()\n          .sendCommand(\n            uuid(),\n            EventstoreCommand.CreatePersistentSubscription,\n            Buffer.from(protobuf.CreatePersistentSubscription.encode(raw).finish()),\n            credentials || this.options.credentials,\n            {\n              resolve,\n              reject\n            }\n          )\n      }\n    )\n    return new PersistentSubscription(\n      this,\n      this.esConnection,\n      this.options.credentials,\n      subscriptionGroupName\n    )\n  }\n\n  /**\n   * Returns a instance of persistance subscription given by group name\n   */\n  public getPersistentSubscription(\n    subscriptionGroupName: string,\n    credentials?: UserCredentials\n  ): PersistentSubscription {\n    return new PersistentSubscription(\n      this,\n      this.esConnection,\n      credentials || this.options.credentials,\n      subscriptionGroupName\n    )\n  }\n}\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/src/stream/Stream.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 307,
    "kind": "variable",
    "name": "protobuf",
    "memberof": "src/stream/Stream.ts",
    "static": true,
    "longname": "src/stream/Stream.ts~protobuf",
    "access": "public",
    "export": false,
    "importPath": "eventstore-ts-client/src/stream/Stream.ts",
    "importStyle": null,
    "description": "protobuf shorthand",
    "lineNumber": 23,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 308,
    "kind": "typedef",
    "name": "StreamOptions",
    "memberof": "src/stream/Stream.ts",
    "static": true,
    "longname": "src/stream/Stream.ts~StreamOptions",
    "access": "public",
    "description": "",
    "lineNumber": 31,
    "properties": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "requireMaster",
        "description": "indicates if operations require master node"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "resolveLinks",
        "description": "indicates if event links should be resolved on read operations"
      },
      {
        "nullable": null,
        "types": [
          "UserCredentials ",
          " null"
        ],
        "spread": false,
        "optional": false,
        "name": "credentials",
        "description": "user credentials if others than default connection credentials"
      }
    ],
    "type": {
      "types": [
        "object"
      ],
      "optional": false,
      "name": "StreamOptions"
    }
  },
  {
    "__docId__": 309,
    "kind": "class",
    "name": "Stream",
    "memberof": "src/stream/Stream.ts",
    "static": true,
    "longname": "src/stream/Stream.ts~Stream",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/stream/Stream.ts",
    "importStyle": "{Stream}",
    "description": "Base class for handling a stream",
    "lineNumber": 40,
    "interface": false
  },
  {
    "__docId__": 310,
    "kind": "member",
    "name": "esConnection",
    "memberof": "src/stream/Stream.ts~Stream",
    "static": false,
    "longname": "src/stream/Stream.ts~Stream#esConnection",
    "access": "protected",
    "description": "eventstore instance",
    "lineNumber": 42,
    "type": {
      "types": [
        "Eventstore"
      ]
    }
  },
  {
    "__docId__": 311,
    "kind": "member",
    "name": "log",
    "memberof": "src/stream/Stream.ts~Stream",
    "static": false,
    "longname": "src/stream/Stream.ts~Stream#log",
    "access": "public",
    "description": "bunyan logger",
    "lineNumber": 44,
    "type": {
      "types": [
        "bunyan"
      ]
    }
  },
  {
    "__docId__": 312,
    "kind": "member",
    "name": "streamId",
    "memberof": "src/stream/Stream.ts~Stream",
    "static": false,
    "longname": "src/stream/Stream.ts~Stream#streamId",
    "access": "protected",
    "description": "id of stream",
    "lineNumber": 46,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 313,
    "kind": "member",
    "name": "options",
    "memberof": "src/stream/Stream.ts~Stream",
    "static": false,
    "longname": "src/stream/Stream.ts~Stream#options",
    "access": "protected",
    "description": "stream options",
    "lineNumber": 48,
    "type": {
      "types": [
        "StreamOptions"
      ]
    }
  },
  {
    "__docId__": 314,
    "kind": "member",
    "name": "defaultSliceSize",
    "memberof": "src/stream/Stream.ts~Stream",
    "static": false,
    "longname": "src/stream/Stream.ts~Stream#defaultSliceSize",
    "access": "protected",
    "description": "default read slice size",
    "lineNumber": 50,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 315,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/stream/Stream.ts~Stream",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stream/Stream.ts~Stream#constructor",
    "access": "public",
    "description": "Creates an instance of Stream.",
    "lineNumber": 55
  },
  {
    "__docId__": 320,
    "kind": "get",
    "name": "name",
    "memberof": "src/stream/Stream.ts~Stream",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stream/Stream.ts~Stream#name",
    "access": "public",
    "description": "Return name of stream instance",
    "lineNumber": 68,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 321,
    "kind": "get",
    "name": "id",
    "memberof": "src/stream/Stream.ts~Stream",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stream/Stream.ts~Stream#id",
    "access": "public",
    "description": "Gets id  of stream",
    "lineNumber": 75,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 322,
    "kind": "method",
    "name": "requiresMaster",
    "memberof": "src/stream/Stream.ts~Stream",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stream/Stream.ts~Stream#requiresMaster",
    "access": "public",
    "description": "Enforces to use master node for any read/write operation",
    "lineNumber": 82,
    "params": [],
    "type": {
      "types": [
        "Stream"
      ]
    }
  },
  {
    "__docId__": 323,
    "kind": "method",
    "name": "withCredentials",
    "memberof": "src/stream/Stream.ts~Stream",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stream/Stream.ts~Stream#withCredentials",
    "access": "public",
    "description": "Set credentials for any read/write operation",
    "lineNumber": 90,
    "params": [
      {
        "types": [
          "UserCredentials"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Stream"
      ]
    }
  },
  {
    "__docId__": 324,
    "kind": "method",
    "name": "resolveAllLinks",
    "memberof": "src/stream/Stream.ts~Stream",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stream/Stream.ts~Stream#resolveAllLinks",
    "access": "public",
    "description": "Enforce to resolve links on read operations",
    "lineNumber": 98,
    "params": [],
    "type": {
      "types": [
        "Stream"
      ]
    }
  },
  {
    "__docId__": 325,
    "kind": "method",
    "name": "appendEvents",
    "memberof": "src/stream/Stream.ts~Stream",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stream/Stream.ts~Stream#appendEvents",
    "access": "protected",
    "description": "Appends array of events to stream",
    "lineNumber": 106,
    "params": [
      {
        "types": [],
        "name": "events"
      },
      {
        "types": [
          "*"
        ],
        "name": "expectedVersion",
        "optional": true
      },
      {
        "types": [],
        "name": "requireMaster"
      },
      {
        "types": [
          "UserCredentials"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 326,
    "kind": "method",
    "name": "isMetaStream",
    "memberof": "src/stream/Stream.ts~Stream",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stream/Stream.ts~Stream#isMetaStream",
    "access": "public",
    "description": "Indicates if given stream is a metadata stream or a regular steam",
    "lineNumber": 158,
    "params": [],
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 327,
    "kind": "method",
    "name": "append",
    "memberof": "src/stream/Stream.ts~Stream",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/stream/Stream.ts~Stream#append",
    "access": "public",
    "description": "Append single event or array of events to stream",
    "lineNumber": 165,
    "params": [
      {
        "types": [
          "Event"
        ],
        "name": "event"
      },
      {
        "types": [
          "*"
        ],
        "name": "expectedVersion",
        "optional": true
      },
      {
        "types": [],
        "name": "requireMaster"
      },
      {
        "types": [
          "UserCredentials"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 328,
    "kind": "method",
    "name": "hardDelete",
    "memberof": "src/stream/Stream.ts~Stream",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/stream/Stream.ts~Stream#hardDelete",
    "access": "public",
    "description": "Hard deletes a stream - stream with same name can not be used in future",
    "lineNumber": 181,
    "params": [
      {
        "types": [
          "*"
        ],
        "name": "expectedVersion",
        "optional": true
      },
      {
        "types": [],
        "name": "requireMaster"
      },
      {
        "types": [
          "UserCredentials"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 329,
    "kind": "method",
    "name": "softDelete",
    "memberof": "src/stream/Stream.ts~Stream",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/stream/Stream.ts~Stream#softDelete",
    "access": "public",
    "description": "Soft deletes a stream - stream with same name can be used in future and indexes are preserved",
    "lineNumber": 196,
    "params": [
      {
        "types": [
          "*"
        ],
        "name": "expectedVersion",
        "optional": true
      },
      {
        "types": [],
        "name": "requireMaster"
      },
      {
        "types": [
          "UserCredentials"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 330,
    "kind": "method",
    "name": "delete",
    "memberof": "src/stream/Stream.ts~Stream",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stream/Stream.ts~Stream#delete",
    "access": "protected",
    "description": "Delete a stream - can't be called directly\nUse softDelete or hardDelete instead",
    "lineNumber": 212,
    "params": [
      {
        "types": [],
        "name": "hardDelete"
      },
      {
        "types": [
          "*"
        ],
        "name": "expectedVersion",
        "optional": true
      },
      {
        "types": [],
        "name": "requireMaster"
      },
      {
        "types": [
          "UserCredentials"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 331,
    "kind": "method",
    "name": "getEventByNumber",
    "memberof": "src/stream/Stream.ts~Stream",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/stream/Stream.ts~Stream#getEventByNumber",
    "access": "public",
    "description": "Get event at specified position from stream",
    "lineNumber": 253,
    "params": [
      {
        "types": [
          "Long",
          "number"
        ],
        "name": "eventNumber"
      },
      {
        "types": [],
        "name": "resolveLinks"
      },
      {
        "types": [],
        "name": "requireMaster"
      },
      {
        "types": [
          "UserCredentials"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 332,
    "kind": "method",
    "name": "getFirstEvent",
    "memberof": "src/stream/Stream.ts~Stream",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/stream/Stream.ts~Stream#getFirstEvent",
    "access": "public",
    "description": "Returns first event from stream",
    "lineNumber": 294,
    "params": [
      {
        "types": [],
        "name": "resolveLinks"
      },
      {
        "types": [],
        "name": "requireMaster"
      },
      {
        "types": [
          "UserCredentials"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 333,
    "kind": "method",
    "name": "getLastEvent",
    "memberof": "src/stream/Stream.ts~Stream",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/stream/Stream.ts~Stream#getLastEvent",
    "access": "public",
    "description": "Returns last event from stream",
    "lineNumber": 310,
    "params": [
      {
        "types": [],
        "name": "resolveLinks"
      },
      {
        "types": [],
        "name": "requireMaster"
      },
      {
        "types": [
          "UserCredentials"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 334,
    "kind": "method",
    "name": "getMetadata",
    "memberof": "src/stream/Stream.ts~Stream",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/stream/Stream.ts~Stream#getMetadata",
    "access": "public",
    "description": "Returns stream metadata if set or",
    "lineNumber": 321,
    "params": [
      {
        "types": [],
        "name": "requireMaster"
      },
      {
        "types": [
          "UserCredentials"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 335,
    "kind": "method",
    "name": "setMetadata",
    "memberof": "src/stream/Stream.ts~Stream",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/stream/Stream.ts~Stream#setMetadata",
    "access": "public",
    "description": "Set metadata for stream",
    "lineNumber": 360,
    "params": [
      {
        "types": [],
        "name": "newMetadata"
      },
      {
        "types": [],
        "name": "requireMaster"
      },
      {
        "types": [
          "UserCredentials"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 336,
    "kind": "method",
    "name": "startTransaction",
    "memberof": "src/stream/Stream.ts~Stream",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/stream/Stream.ts~Stream#startTransaction",
    "access": "public",
    "description": "Creates a new instance of {Transaction} for current stream",
    "lineNumber": 383,
    "params": [
      {
        "types": [
          "*"
        ],
        "name": "expectedVersion",
        "optional": true
      },
      {
        "types": [],
        "name": "requireMaster"
      },
      {
        "types": [
          "UserCredentials"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 337,
    "kind": "method",
    "name": "readSlice",
    "memberof": "src/stream/Stream.ts~Stream",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/stream/Stream.ts~Stream#readSlice",
    "access": "protected",
    "description": "Reads a slice from current stream in given direction starting at given position",
    "lineNumber": 427,
    "params": [
      {
        "types": [
          "EventstoreCommand"
        ],
        "name": "direction"
      },
      {
        "types": [
          "number",
          "Long",
          "number"
        ],
        "name": "fromEventNumber",
        "optional": true,
        "defaultRaw": 0,
        "defaultValue": "0"
      },
      {
        "types": [],
        "name": "maxSliceCount"
      },
      {
        "types": [],
        "name": "resolveLinks"
      },
      {
        "types": [],
        "name": "requireMaster"
      },
      {
        "types": [
          "UserCredentials"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 338,
    "kind": "method",
    "name": "readSliceForward",
    "memberof": "src/stream/Stream.ts~Stream",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/stream/Stream.ts~Stream#readSliceForward",
    "access": "public",
    "description": "Read a slice from stream in forward direction starting at given position",
    "lineNumber": 463,
    "params": [
      {
        "types": [
          "*"
        ],
        "name": "fromEventNumber",
        "optional": true
      },
      {
        "types": [],
        "name": "maxSliceCount"
      },
      {
        "types": [],
        "name": "resolveLinks"
      },
      {
        "types": [],
        "name": "requireMaster"
      },
      {
        "types": [
          "UserCredentials"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 339,
    "kind": "method",
    "name": "readSliceBackward",
    "memberof": "src/stream/Stream.ts~Stream",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/stream/Stream.ts~Stream#readSliceBackward",
    "access": "public",
    "description": "Read a slice from stream in backward direction starting at given position",
    "lineNumber": 483,
    "params": [
      {
        "types": [
          "*"
        ],
        "name": "fromEventNumber",
        "optional": true
      },
      {
        "types": [],
        "name": "maxSliceCount"
      },
      {
        "types": [],
        "name": "resolveLinks"
      },
      {
        "types": [],
        "name": "requireMaster"
      },
      {
        "types": [
          "UserCredentials"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 340,
    "kind": "method",
    "name": "walkStream",
    "memberof": "src/stream/Stream.ts~Stream",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/stream/Stream.ts~Stream#walkStream",
    "access": "protected",
    "description": "Walk through all events of stream",
    "lineNumber": 503,
    "params": [
      {
        "types": [],
        "name": "forward"
      },
      {
        "types": [
          "Long",
          "number"
        ],
        "name": "start"
      },
      {
        "types": [],
        "name": "resolveLinks"
      },
      {
        "types": [],
        "name": "requireMaster"
      },
      {
        "types": [
          "UserCredentials"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 341,
    "kind": "method",
    "name": "walkStreamForward",
    "memberof": "src/stream/Stream.ts~Stream",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/stream/Stream.ts~Stream#walkStreamForward",
    "access": "public",
    "description": "Walk through all events in stream forward",
    "lineNumber": 559,
    "params": [
      {
        "types": [
          "*"
        ],
        "name": "start",
        "optional": true
      },
      {
        "types": [],
        "name": "resolveLinkTos"
      },
      {
        "types": [],
        "name": "requireMaster"
      },
      {
        "types": [
          "UserCredentials"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 342,
    "kind": "method",
    "name": "walkStreamBackward",
    "memberof": "src/stream/Stream.ts~Stream",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/stream/Stream.ts~Stream#walkStreamBackward",
    "access": "public",
    "description": "Walk through all events in stream backward",
    "lineNumber": 571,
    "params": [
      {
        "types": [
          "*"
        ],
        "name": "start",
        "optional": true
      },
      {
        "types": [],
        "name": "resolveLinkTos"
      },
      {
        "types": [],
        "name": "requireMaster"
      },
      {
        "types": [
          "UserCredentials"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 343,
    "kind": "method",
    "name": "subscribe",
    "memberof": "src/stream/Stream.ts~Stream",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/stream/Stream.ts~Stream#subscribe",
    "access": "public",
    "description": "Subscribe to current stream and return a subscription",
    "lineNumber": 583,
    "params": [
      {
        "types": [],
        "name": "resolveLinkTos"
      },
      {
        "types": [
          "UserCredentials"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 344,
    "kind": "method",
    "name": "createPersistentSubscription",
    "memberof": "src/stream/Stream.ts~Stream",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/stream/Stream.ts~Stream#createPersistentSubscription",
    "access": "public",
    "description": "Creates a persistent subscription for current stream\nThis operation needs admin rights and a master connection",
    "lineNumber": 596,
    "params": [
      {
        "types": [],
        "name": "subscriptionGroupName"
      },
      {
        "types": [
          "{}"
        ],
        "name": "customConfig",
        "optional": true,
        "defaultRaw": {},
        "defaultValue": "{}"
      },
      {
        "types": [
          "UserCredentials"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 345,
    "kind": "method",
    "name": "getPersistentSubscription",
    "memberof": "src/stream/Stream.ts~Stream",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stream/Stream.ts~Stream#getPersistentSubscription",
    "access": "public",
    "description": "Returns a instance of persistance subscription given by group name",
    "lineNumber": 635,
    "params": [
      {
        "types": [],
        "name": "subscriptionGroupName"
      },
      {
        "types": [
          "UserCredentials"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "PersistentSubscription"
      ]
    }
  },
  {
    "__docId__": 346,
    "kind": "file",
    "name": "src/stream/StreamPosition.ts",
    "content": "/** typescript enumeration for stream position constants */\nexport enum StreamPosition {\n  Start = 0,\n  End = -1\n}\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/src/stream/StreamPosition.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 347,
    "kind": "file",
    "name": "src/stream/Transaction.ts",
    "content": "import {Stream} from './Stream'\nimport {Event} from '../event'\nimport uuid = require('uuid/v4')\nimport * as model from '../protobuf/model'\nimport {EventstoreCommand} from '../protobuf/EventstoreCommand'\nimport * as eventstoreError from '../errors'\nimport {UserCredentials} from '../eventstore/EventstoreSettings'\nimport {Eventstore} from '../eventstore'\n\n/** protobuf shorthand */\nconst protobuf = model.eventstore.proto\n\n/**\n * Base class for handling transaction writes to stream\n */\nexport class Transaction {\n  /** id of transaction */\n  protected transactionId: Long\n  /** corresponding stream */\n  protected stream: Stream\n  /** current connection */\n  protected esConnection: Eventstore\n  /** indicates if transaction is committed */\n  protected committed: boolean = false\n  /** indicates if transaction is rolled back */\n  protected rolledBack: boolean = false\n  /** indicates if transaction needs master node */\n  protected requireMaster: boolean\n  /** credentials for transaction */\n  protected credentials: UserCredentials | null = null\n\n  /**\n   *  Creates an instance of Transaction.\n   */\n  public constructor(\n    stream: Stream,\n    transactionId: Long,\n    esConnection: Eventstore,\n    requireMaster: boolean,\n    credentials: UserCredentials | null = null\n  ) {\n    this.stream = stream\n    this.transactionId = transactionId\n    this.esConnection = esConnection\n    this.requireMaster = requireMaster\n    this.credentials = credentials\n  }\n\n  /**\n   * Gets whether is committed\n   */\n  public get isCommitted(): boolean {\n    return this.committed\n  }\n\n  /**\n   * Gets whether is rolled back\n   */\n  public get isRolledBack(): boolean {\n    return this.rolledBack\n  }\n\n  /**\n   * Appends single event or array of events to transaction\n   */\n  public async append(\n    event: Event | Event[],\n    requireMaster?: boolean,\n    credentials?: UserCredentials | null\n  ): Promise<void> {\n    if (Array.isArray(event)) {\n      return await this.appendEvents(event, requireMaster, credentials)\n    } else {\n      return await this.appendEvents([event], requireMaster, credentials)\n    }\n  }\n\n  /**\n   * Appends array of evens to transaction\n   */\n  protected async appendEvents(\n    events: Event[],\n    requireMaster?: boolean,\n    credentials?: UserCredentials | null\n  ): Promise<void> {\n    if (this.isCommitted) {\n      throw eventstoreError.newInvalidTransactionError(\n        `Transaction ${this.transactionId} is already committed`\n      )\n    }\n    if (this.isRolledBack) {\n      throw eventstoreError.newInvalidTransactionError(\n        `Transaction ${this.transactionId} is already rolled back`\n      )\n    }\n    if (requireMaster === undefined) {\n      requireMaster = this.requireMaster\n    }\n    const eventArrayTransformed: model.eventstore.proto.NewEvent[] = events.map(\n      (event): model.eventstore.proto.NewEvent => {\n        if (!event.isNew()) {\n          throw eventstoreError.newOperationError(\n            `Event ${event.name} is already stored in eventstore`\n          )\n        }\n        return event.toRaw()\n      }\n    )\n    const raw = protobuf.TransactionWrite.fromObject({\n      transactionId: this.transactionId,\n      events: eventArrayTransformed,\n      requireMaster: requireMaster\n    })\n    raw.transactionId = this.transactionId\n    await new Promise(\n      (resolve, reject): void => {\n        const setToWritten = (id: Long): void => {\n          events.forEach((event): void => event.freeze())\n          resolve(id)\n        }\n        this.esConnection\n          .getConnection()\n          .sendCommand(\n            uuid(),\n            EventstoreCommand.TransactionWrite,\n            Buffer.from(protobuf.TransactionWrite.encode(raw).finish()),\n            credentials || this.credentials,\n            {\n              resolve: setToWritten,\n              reject\n            }\n          )\n      }\n    )\n  }\n\n  /**\n   * Commits transaction\n   */\n  public async commit(\n    requireMaster?: boolean,\n    credentials?: UserCredentials | null\n  ): Promise<void> {\n    if (this.isCommitted) {\n      throw eventstoreError.newInvalidTransactionError(\n        `Transaction ${this.transactionId} is already committed`\n      )\n    }\n    if (this.isRolledBack) {\n      throw eventstoreError.newInvalidTransactionError(\n        `Transaction ${this.transactionId} is already roled back`\n      )\n    }\n    if (requireMaster === undefined) {\n      requireMaster = this.requireMaster\n    }\n    await new Promise(\n      (resolve, reject): void => {\n        const rejectFunction = (err: Error): void => {\n          this.committed = true\n          this.rolledBack = true\n          reject(err)\n        }\n        const raw = protobuf.TransactionCommit.fromObject({\n          transactionId: this.transactionId,\n          requireMaster: requireMaster\n        })\n        this.esConnection\n          .getConnection()\n          .sendCommand(\n            uuid(),\n            EventstoreCommand.TransactionCommit,\n            Buffer.from(protobuf.TransactionCommit.encode(raw).finish()),\n            credentials || this.credentials,\n            {\n              resolve,\n              reject: rejectFunction\n            }\n          )\n      }\n    )\n    this.committed = true\n  }\n\n  /**\n   * Roles back transaction\n   */\n  public roleBack(): void {\n    this.rolledBack = true\n  }\n\n  /**\n   * Gets transaction id\n   */\n  public get id(): Long {\n    return this.transactionId\n  }\n\n  /**\n   * Gets transaction name\n   */\n  public get name(): string {\n    return 'Transaction: ' + this.transactionId\n  }\n}\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/src/stream/Transaction.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 348,
    "kind": "variable",
    "name": "protobuf",
    "memberof": "src/stream/Transaction.ts",
    "static": true,
    "longname": "src/stream/Transaction.ts~protobuf",
    "access": "public",
    "export": false,
    "importPath": "eventstore-ts-client/src/stream/Transaction.ts",
    "importStyle": null,
    "description": "protobuf shorthand",
    "lineNumber": 11,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 349,
    "kind": "class",
    "name": "Transaction",
    "memberof": "src/stream/Transaction.ts",
    "static": true,
    "longname": "src/stream/Transaction.ts~Transaction",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/stream/Transaction.ts",
    "importStyle": "{Transaction}",
    "description": "Base class for handling transaction writes to stream",
    "lineNumber": 16,
    "interface": false
  },
  {
    "__docId__": 350,
    "kind": "member",
    "name": "transactionId",
    "memberof": "src/stream/Transaction.ts~Transaction",
    "static": false,
    "longname": "src/stream/Transaction.ts~Transaction#transactionId",
    "access": "protected",
    "description": "id of transaction",
    "lineNumber": 18,
    "type": {
      "types": [
        "Long"
      ]
    }
  },
  {
    "__docId__": 351,
    "kind": "member",
    "name": "stream",
    "memberof": "src/stream/Transaction.ts~Transaction",
    "static": false,
    "longname": "src/stream/Transaction.ts~Transaction#stream",
    "access": "protected",
    "description": "corresponding stream",
    "lineNumber": 20,
    "type": {
      "types": [
        "Stream"
      ]
    }
  },
  {
    "__docId__": 352,
    "kind": "member",
    "name": "esConnection",
    "memberof": "src/stream/Transaction.ts~Transaction",
    "static": false,
    "longname": "src/stream/Transaction.ts~Transaction#esConnection",
    "access": "protected",
    "description": "current connection",
    "lineNumber": 22,
    "type": {
      "types": [
        "Eventstore"
      ]
    }
  },
  {
    "__docId__": 353,
    "kind": "member",
    "name": "committed",
    "memberof": "src/stream/Transaction.ts~Transaction",
    "static": false,
    "longname": "src/stream/Transaction.ts~Transaction#committed",
    "access": "protected",
    "description": "indicates if transaction is committed",
    "lineNumber": 24,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 354,
    "kind": "member",
    "name": "rolledBack",
    "memberof": "src/stream/Transaction.ts~Transaction",
    "static": false,
    "longname": "src/stream/Transaction.ts~Transaction#rolledBack",
    "access": "protected",
    "description": "indicates if transaction is rolled back",
    "lineNumber": 26,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 355,
    "kind": "member",
    "name": "requireMaster",
    "memberof": "src/stream/Transaction.ts~Transaction",
    "static": false,
    "longname": "src/stream/Transaction.ts~Transaction#requireMaster",
    "access": "protected",
    "description": "indicates if transaction needs master node",
    "lineNumber": 28,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 356,
    "kind": "member",
    "name": "credentials",
    "memberof": "src/stream/Transaction.ts~Transaction",
    "static": false,
    "longname": "src/stream/Transaction.ts~Transaction#credentials",
    "access": "protected",
    "description": "credentials for transaction",
    "lineNumber": 30,
    "type": {
      "types": [
        "UserCredentials",
        "null"
      ]
    }
  },
  {
    "__docId__": 357,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/stream/Transaction.ts~Transaction",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stream/Transaction.ts~Transaction#constructor",
    "access": "public",
    "description": " Creates an instance of Transaction.",
    "lineNumber": 35
  },
  {
    "__docId__": 363,
    "kind": "get",
    "name": "isCommitted",
    "memberof": "src/stream/Transaction.ts~Transaction",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stream/Transaction.ts~Transaction#isCommitted",
    "access": "public",
    "description": "Gets whether is committed",
    "lineNumber": 52,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 364,
    "kind": "get",
    "name": "isRolledBack",
    "memberof": "src/stream/Transaction.ts~Transaction",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stream/Transaction.ts~Transaction#isRolledBack",
    "access": "public",
    "description": "Gets whether is rolled back",
    "lineNumber": 59,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 365,
    "kind": "method",
    "name": "append",
    "memberof": "src/stream/Transaction.ts~Transaction",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/stream/Transaction.ts~Transaction#append",
    "access": "public",
    "description": "Appends single event or array of events to transaction",
    "lineNumber": 66,
    "params": [
      {
        "types": [
          "Event"
        ],
        "name": "event"
      },
      {
        "types": [],
        "name": "requireMaster"
      },
      {
        "types": [
          "UserCredentials",
          "null"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 366,
    "kind": "method",
    "name": "appendEvents",
    "memberof": "src/stream/Transaction.ts~Transaction",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/stream/Transaction.ts~Transaction#appendEvents",
    "access": "protected",
    "description": "Appends array of evens to transaction",
    "lineNumber": 81,
    "params": [
      {
        "types": [],
        "name": "events"
      },
      {
        "types": [],
        "name": "requireMaster"
      },
      {
        "types": [
          "UserCredentials",
          "null"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 367,
    "kind": "method",
    "name": "commit",
    "memberof": "src/stream/Transaction.ts~Transaction",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/stream/Transaction.ts~Transaction#commit",
    "access": "public",
    "description": "Commits transaction",
    "lineNumber": 140,
    "params": [
      {
        "types": [],
        "name": "requireMaster"
      },
      {
        "types": [
          "UserCredentials",
          "null"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 371,
    "kind": "method",
    "name": "roleBack",
    "memberof": "src/stream/Transaction.ts~Transaction",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stream/Transaction.ts~Transaction#roleBack",
    "access": "public",
    "description": "Roles back transaction",
    "lineNumber": 188,
    "params": [],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 373,
    "kind": "get",
    "name": "id",
    "memberof": "src/stream/Transaction.ts~Transaction",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stream/Transaction.ts~Transaction#id",
    "access": "public",
    "description": "Gets transaction id",
    "lineNumber": 195,
    "type": {
      "types": [
        "Long"
      ]
    }
  },
  {
    "__docId__": 374,
    "kind": "get",
    "name": "name",
    "memberof": "src/stream/Transaction.ts~Transaction",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/stream/Transaction.ts~Transaction#name",
    "access": "public",
    "description": "Gets transaction name",
    "lineNumber": 202,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 375,
    "kind": "file",
    "name": "src/stream/index.ts",
    "content": "export {Stream, StreamOptions} from './Stream'\nexport {StreamPosition} from './StreamPosition'\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/src/stream/index.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 376,
    "kind": "file",
    "name": "src/subscription/PersistentSubscription.ts",
    "content": "import {Stream} from '../stream'\nimport {UserCredentials, Eventstore} from '../eventstore'\nimport {EventEmitter} from 'events'\nimport {EventstoreCommand} from '../protobuf/EventstoreCommand'\nimport * as model from '../protobuf/model'\nimport uuid = require('uuid/v4')\nimport {PersistentSubscriptionConfig, setPersistentSubscriptionConfig, SubscriptionStatus} from '.'\nimport Long from 'long'\nimport {Event} from '../event'\nimport {uuidToBuffer} from '../protobuf/uuidBufferConvert'\n\n/** protobuf shorthand */\nconst protobuf = model.eventstore.proto\n\n/**\n * Represents a persistent subscription\n *\n * @emits {dropped} emitted when subscription is disconnected\n * @emits {event}\n * @emits {event-eventnametolowercase}\n */\nexport class PersistentSubscription extends EventEmitter {\n  /** corresponding stream  */\n  public stream: Stream\n  /** connection to use */\n  protected esConnection: Eventstore\n  /** name of subscription */\n  public subscriptionGroupName: string\n  /** user credentials */\n  protected credentials: UserCredentials | null = null\n  /** last commit position */\n  public lastCommitPosition: Long = Long.fromNumber(0)\n  /** last event number */\n  public lastEventNumber: Long | null = null\n  /** id of persistent subscription (uuid)*/\n  public id: string = uuid()\n  /** subscription id send back from eventstore */\n  public subscriptionId: string\n  /** count of max concurrent events */\n  public allowedInFlightMessages: number = 10\n  /** status of subscription */\n  protected status: SubscriptionStatus = SubscriptionStatus.disconnected\n  /** indicate if incoming events should automatically acknowledged */\n  public autoAcknowledge: boolean = true\n\n  /**\n   * Creates an instance of persistent subscription.\n   */\n  public constructor(\n    stream: Stream,\n    esConnection: Eventstore,\n    credentials: UserCredentials | null,\n    subscriptionGroupName: string\n  ) {\n    super()\n    this.stream = stream\n    this.esConnection = esConnection\n    this.subscriptionGroupName = subscriptionGroupName\n    this.credentials = credentials\n\n    this.subscriptionId = `${this.stream.id} :: ${this.subscriptionGroupName}`\n\n    this.on(\n      'dropped',\n      (): void => {\n        this.state = SubscriptionStatus.disconnected\n      }\n    )\n  }\n\n  /**\n   * Gets name\n   */\n  public get name(): string {\n    return `PersistentSubscription: ${this.stream.id} :: ${this.subscriptionGroupName}`\n  }\n\n  /**\n   * Gets state\n   */\n  public get state(): SubscriptionStatus {\n    return this.status\n  }\n\n  /**\n   * Sets state\n   */\n  public set state(newStatus: SubscriptionStatus) {\n    this.emit(SubscriptionStatus[newStatus])\n    this.status = newStatus\n  }\n\n  /**\n   * Connects persistent subscription\n   */\n  public async subscribe(\n    allowedInFlightMessages: number = 10,\n    credentials?: UserCredentials | null\n  ): Promise<PersistentSubscription> {\n    this.allowedInFlightMessages = allowedInFlightMessages\n    if (credentials) {\n      this.credentials = credentials\n    }\n    const result = await this.esConnection\n      .getConnection()\n      .connectToPersistentSubscription(this, allowedInFlightMessages, this.credentials)\n    this.subscriptionId = result.subscriptionId\n    this.state = SubscriptionStatus.connected\n    return this\n  }\n\n  /**\n   * Unsubscribe from stream\n   */\n  public async unsubscribe(credentials?: UserCredentials | null): Promise<void> {\n    await this.esConnection\n      .getConnection()\n      .unsubscribeFromPersistentSubscription(this.id, credentials || this.credentials)\n  }\n\n  /**\n   * Deletes persistent subscription\n   */\n  public async delete(credentials?: UserCredentials | null): Promise<PersistentSubscription> {\n    const result: PersistentSubscription = await new Promise(\n      (resolve, reject): void => {\n        const raw = protobuf.UpdatePersistentSubscription.fromObject({\n          subscriptionGroupName: this.subscriptionGroupName,\n          eventStreamId: this.stream.id\n        })\n        this.esConnection\n          .getConnection()\n          .sendCommand(\n            uuid(),\n            EventstoreCommand.DeletePersistentSubscription,\n            Buffer.from(protobuf.DeletePersistentSubscription.encode(raw).finish()),\n            credentials || this.credentials,\n            {\n              resolve,\n              reject\n            }\n          )\n      }\n    )\n    this.state = SubscriptionStatus.disconnected\n    return result\n  }\n\n  /**\n   * Updates persistent subscription\n   */\n  public async update(\n    customConfig: PersistentSubscriptionConfig | {},\n    credentials?: UserCredentials\n  ): Promise<PersistentSubscription> {\n    const settings = setPersistentSubscriptionConfig(customConfig)\n\n    return await new Promise(\n      (resolve, reject): void => {\n        const raw = protobuf.UpdatePersistentSubscription.fromObject({\n          subscriptionGroupName: this.subscriptionGroupName,\n          eventStreamId: this.stream.id,\n          ...settings\n        })\n        this.esConnection\n          .getConnection()\n          .sendCommand(\n            uuid(),\n            EventstoreCommand.UpdatePersistentSubscription,\n            Buffer.from(protobuf.UpdatePersistentSubscription.encode(raw).finish()),\n            credentials || this.credentials,\n            {\n              resolve,\n              reject\n            }\n          )\n      }\n    )\n  }\n\n  /**\n   * Called when event from eventstore arrives\n   */\n  public eventAppeared(event: Event): void {\n    this.emit('event', event)\n    this.emit(`event-${event.name.toLocaleLowerCase()}`, event)\n  }\n\n  /**\n   * Acknowledges single event\n   */\n  public acknowledgeEvent(event: Event, credentials?: UserCredentials): void {\n    return this.acknowledgeEvents([event], credentials)\n  }\n\n  /**\n   * Acknowledges array of events\n   */\n  public acknowledgeEvents(events: Event[], credentials?: UserCredentials): void {\n    const processedEventIds = events.map(\n      (event): Buffer => {\n        return uuidToBuffer(event.id)\n      }\n    )\n\n    const raw = protobuf.PersistentSubscriptionAckEvents.fromObject({\n      subscriptionId: this.subscriptionId,\n      processedEventIds\n    })\n    this.esConnection\n      .getConnection()\n      .sendCommand(\n        this.id,\n        EventstoreCommand.PersistentSubscriptionAckEvents,\n        Buffer.from(protobuf.PersistentSubscriptionAckEvents.encode(raw).finish()),\n        credentials || this.credentials\n      )\n  }\n\n  /**\n   * Not acknowledge single event\n   */\n  public notAcknowledgeEvent(\n    event: Event,\n    reason: model.eventstore.proto.PersistentSubscriptionNakEvents.NakAction = model.eventstore\n      .proto.PersistentSubscriptionNakEvents.NakAction.Unknown,\n    message?: string,\n    credentials?: UserCredentials\n  ): void {\n    return this.notAcknowledgeEvents([event], reason, message, credentials)\n  }\n\n  /**\n   * Not acknowledge array of events\n   */\n  public notAcknowledgeEvents(\n    events: Event[],\n    reason: model.eventstore.proto.PersistentSubscriptionNakEvents.NakAction = model.eventstore\n      .proto.PersistentSubscriptionNakEvents.NakAction.Unknown,\n    message?: string,\n    credentials?: UserCredentials\n  ): void {\n    const processedEventIds = events.map(\n      (event): Buffer => {\n        return uuidToBuffer(event.id)\n      }\n    )\n    const raw = protobuf.PersistentSubscriptionNakEvents.fromObject({\n      subscriptionId: this.subscriptionId,\n      processedEventIds,\n      message,\n      action: reason\n    })\n    this.esConnection\n      .getConnection()\n      .sendCommand(\n        this.id,\n        EventstoreCommand.PersistentSubscriptionNakEvents,\n        Buffer.from(protobuf.PersistentSubscriptionNakEvents.encode(raw).finish()),\n        credentials || this.credentials\n      )\n  }\n}\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/src/subscription/PersistentSubscription.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 377,
    "kind": "variable",
    "name": "protobuf",
    "memberof": "src/subscription/PersistentSubscription.ts",
    "static": true,
    "longname": "src/subscription/PersistentSubscription.ts~protobuf",
    "access": "public",
    "export": false,
    "importPath": "eventstore-ts-client/src/subscription/PersistentSubscription.ts",
    "importStyle": null,
    "description": "protobuf shorthand",
    "lineNumber": 13,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 378,
    "kind": "class",
    "name": "PersistentSubscription",
    "memberof": "src/subscription/PersistentSubscription.ts",
    "static": true,
    "longname": "src/subscription/PersistentSubscription.ts~PersistentSubscription",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/subscription/PersistentSubscription.ts",
    "importStyle": "{PersistentSubscription}",
    "description": "Represents a persistent subscription",
    "lineNumber": 22,
    "emits": [
      {
        "types": [
          "dropped"
        ],
        "description": "emitted when subscription is disconnected"
      },
      {
        "types": [
          "event"
        ],
        "description": ""
      },
      {
        "types": [
          "event-eventnametolowercase"
        ],
        "description": ""
      }
    ],
    "interface": false,
    "extends": [
      "events~EventEmitter"
    ]
  },
  {
    "__docId__": 379,
    "kind": "member",
    "name": "stream",
    "memberof": "src/subscription/PersistentSubscription.ts~PersistentSubscription",
    "static": false,
    "longname": "src/subscription/PersistentSubscription.ts~PersistentSubscription#stream",
    "access": "public",
    "description": "corresponding stream",
    "lineNumber": 24,
    "type": {
      "types": [
        "Stream"
      ]
    }
  },
  {
    "__docId__": 380,
    "kind": "member",
    "name": "esConnection",
    "memberof": "src/subscription/PersistentSubscription.ts~PersistentSubscription",
    "static": false,
    "longname": "src/subscription/PersistentSubscription.ts~PersistentSubscription#esConnection",
    "access": "protected",
    "description": "connection to use",
    "lineNumber": 26,
    "type": {
      "types": [
        "Eventstore"
      ]
    }
  },
  {
    "__docId__": 381,
    "kind": "member",
    "name": "subscriptionGroupName",
    "memberof": "src/subscription/PersistentSubscription.ts~PersistentSubscription",
    "static": false,
    "longname": "src/subscription/PersistentSubscription.ts~PersistentSubscription#subscriptionGroupName",
    "access": "public",
    "description": "name of subscription",
    "lineNumber": 28,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 382,
    "kind": "member",
    "name": "credentials",
    "memberof": "src/subscription/PersistentSubscription.ts~PersistentSubscription",
    "static": false,
    "longname": "src/subscription/PersistentSubscription.ts~PersistentSubscription#credentials",
    "access": "protected",
    "description": "user credentials",
    "lineNumber": 30,
    "type": {
      "types": [
        "UserCredentials",
        "null"
      ]
    }
  },
  {
    "__docId__": 383,
    "kind": "member",
    "name": "lastCommitPosition",
    "memberof": "src/subscription/PersistentSubscription.ts~PersistentSubscription",
    "static": false,
    "longname": "src/subscription/PersistentSubscription.ts~PersistentSubscription#lastCommitPosition",
    "access": "public",
    "description": "last commit position",
    "lineNumber": 32,
    "type": {
      "types": [
        "Long"
      ]
    }
  },
  {
    "__docId__": 384,
    "kind": "member",
    "name": "lastEventNumber",
    "memberof": "src/subscription/PersistentSubscription.ts~PersistentSubscription",
    "static": false,
    "longname": "src/subscription/PersistentSubscription.ts~PersistentSubscription#lastEventNumber",
    "access": "public",
    "description": "last event number",
    "lineNumber": 34,
    "type": {
      "types": [
        "Long",
        "null"
      ]
    }
  },
  {
    "__docId__": 385,
    "kind": "member",
    "name": "id",
    "memberof": "src/subscription/PersistentSubscription.ts~PersistentSubscription",
    "static": false,
    "longname": "src/subscription/PersistentSubscription.ts~PersistentSubscription#id",
    "access": "public",
    "description": "id of persistent subscription (uuid)",
    "lineNumber": 36,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 386,
    "kind": "member",
    "name": "subscriptionId",
    "memberof": "src/subscription/PersistentSubscription.ts~PersistentSubscription",
    "static": false,
    "longname": "src/subscription/PersistentSubscription.ts~PersistentSubscription#subscriptionId",
    "access": "public",
    "description": "subscription id send back from eventstore",
    "lineNumber": 38,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 387,
    "kind": "member",
    "name": "allowedInFlightMessages",
    "memberof": "src/subscription/PersistentSubscription.ts~PersistentSubscription",
    "static": false,
    "longname": "src/subscription/PersistentSubscription.ts~PersistentSubscription#allowedInFlightMessages",
    "access": "public",
    "description": "count of max concurrent events",
    "lineNumber": 40,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 388,
    "kind": "member",
    "name": "status",
    "memberof": "src/subscription/PersistentSubscription.ts~PersistentSubscription",
    "static": false,
    "longname": "src/subscription/PersistentSubscription.ts~PersistentSubscription#status",
    "access": "protected",
    "description": "status of subscription",
    "lineNumber": 42,
    "type": {
      "types": [
        "SubscriptionStatus"
      ]
    }
  },
  {
    "__docId__": 389,
    "kind": "member",
    "name": "autoAcknowledge",
    "memberof": "src/subscription/PersistentSubscription.ts~PersistentSubscription",
    "static": false,
    "longname": "src/subscription/PersistentSubscription.ts~PersistentSubscription#autoAcknowledge",
    "access": "public",
    "description": "indicate if incoming events should automatically acknowledged",
    "lineNumber": 44,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 390,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/subscription/PersistentSubscription.ts~PersistentSubscription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/subscription/PersistentSubscription.ts~PersistentSubscription#constructor",
    "access": "public",
    "description": "Creates an instance of persistent subscription.",
    "lineNumber": 49
  },
  {
    "__docId__": 397,
    "kind": "get",
    "name": "name",
    "memberof": "src/subscription/PersistentSubscription.ts~PersistentSubscription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/subscription/PersistentSubscription.ts~PersistentSubscription#name",
    "access": "public",
    "description": "Gets name",
    "lineNumber": 74,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 398,
    "kind": "get",
    "name": "state",
    "memberof": "src/subscription/PersistentSubscription.ts~PersistentSubscription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/subscription/PersistentSubscription.ts~PersistentSubscription#state",
    "access": "public",
    "description": "Gets state",
    "lineNumber": 81,
    "type": {
      "types": [
        "SubscriptionStatus"
      ]
    }
  },
  {
    "__docId__": 399,
    "kind": "set",
    "name": "state",
    "memberof": "src/subscription/PersistentSubscription.ts~PersistentSubscription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/subscription/PersistentSubscription.ts~PersistentSubscription#state",
    "access": "public",
    "description": "Sets state",
    "lineNumber": 88,
    "type": {
      "types": [
        "SubscriptionStatus"
      ]
    }
  },
  {
    "__docId__": 401,
    "kind": "method",
    "name": "subscribe",
    "memberof": "src/subscription/PersistentSubscription.ts~PersistentSubscription",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/subscription/PersistentSubscription.ts~PersistentSubscription#subscribe",
    "access": "public",
    "description": "Connects persistent subscription",
    "lineNumber": 96,
    "params": [
      {
        "types": [
          "number"
        ],
        "name": "allowedInFlightMessages",
        "optional": true,
        "defaultRaw": 10,
        "defaultValue": "10"
      },
      {
        "types": [
          "UserCredentials",
          "null"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 406,
    "kind": "method",
    "name": "unsubscribe",
    "memberof": "src/subscription/PersistentSubscription.ts~PersistentSubscription",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/subscription/PersistentSubscription.ts~PersistentSubscription#unsubscribe",
    "access": "public",
    "description": "Unsubscribe from stream",
    "lineNumber": 115,
    "params": [
      {
        "types": [
          "UserCredentials",
          "null"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 407,
    "kind": "method",
    "name": "delete",
    "memberof": "src/subscription/PersistentSubscription.ts~PersistentSubscription",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/subscription/PersistentSubscription.ts~PersistentSubscription#delete",
    "access": "public",
    "description": "Deletes persistent subscription",
    "lineNumber": 124,
    "params": [
      {
        "types": [
          "UserCredentials",
          "null"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 409,
    "kind": "method",
    "name": "update",
    "memberof": "src/subscription/PersistentSubscription.ts~PersistentSubscription",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/subscription/PersistentSubscription.ts~PersistentSubscription#update",
    "access": "public",
    "description": "Updates persistent subscription",
    "lineNumber": 152,
    "params": [
      {
        "types": [
          "PersistentSubscriptionConfig"
        ],
        "name": "customConfig"
      },
      {
        "types": [
          "UserCredentials"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 410,
    "kind": "method",
    "name": "eventAppeared",
    "memberof": "src/subscription/PersistentSubscription.ts~PersistentSubscription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/subscription/PersistentSubscription.ts~PersistentSubscription#eventAppeared",
    "access": "public",
    "description": "Called when event from eventstore arrives",
    "lineNumber": 184,
    "params": [
      {
        "types": [
          "Event"
        ],
        "name": "event"
      }
    ],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 411,
    "kind": "method",
    "name": "acknowledgeEvent",
    "memberof": "src/subscription/PersistentSubscription.ts~PersistentSubscription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/subscription/PersistentSubscription.ts~PersistentSubscription#acknowledgeEvent",
    "access": "public",
    "description": "Acknowledges single event",
    "lineNumber": 192,
    "params": [
      {
        "types": [
          "Event"
        ],
        "name": "event"
      },
      {
        "types": [
          "UserCredentials"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 412,
    "kind": "method",
    "name": "acknowledgeEvents",
    "memberof": "src/subscription/PersistentSubscription.ts~PersistentSubscription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/subscription/PersistentSubscription.ts~PersistentSubscription#acknowledgeEvents",
    "access": "public",
    "description": "Acknowledges array of events",
    "lineNumber": 199,
    "params": [
      {
        "types": [],
        "name": "events"
      },
      {
        "types": [
          "UserCredentials"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 413,
    "kind": "method",
    "name": "notAcknowledgeEvent",
    "memberof": "src/subscription/PersistentSubscription.ts~PersistentSubscription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/subscription/PersistentSubscription.ts~PersistentSubscription#notAcknowledgeEvent",
    "access": "public",
    "description": "Not acknowledge single event",
    "lineNumber": 223,
    "params": [
      {
        "types": [
          "Event"
        ],
        "name": "event"
      },
      {
        "types": [
          "*"
        ],
        "name": "reason",
        "optional": true
      },
      {
        "types": [],
        "name": "message"
      },
      {
        "types": [
          "UserCredentials"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 414,
    "kind": "method",
    "name": "notAcknowledgeEvents",
    "memberof": "src/subscription/PersistentSubscription.ts~PersistentSubscription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/subscription/PersistentSubscription.ts~PersistentSubscription#notAcknowledgeEvents",
    "access": "public",
    "description": "Not acknowledge array of events",
    "lineNumber": 236,
    "params": [
      {
        "types": [],
        "name": "events"
      },
      {
        "types": [
          "*"
        ],
        "name": "reason",
        "optional": true
      },
      {
        "types": [],
        "name": "message"
      },
      {
        "types": [
          "UserCredentials"
        ],
        "name": "credentials"
      }
    ],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 415,
    "kind": "file",
    "name": "src/subscription/PersistentSubscriptionConfig.ts",
    "content": "import {StreamPosition} from '../stream/StreamPosition'\nimport Long = require('long')\n\n/** constant definition of consumer strategies */\nexport const SystemConsumerStrategies = {\n  DispatchToSingle: 'DispatchToSingle',\n  RoundRobin: 'RoundRobin',\n  Pinned: 'Pinned'\n}\n\n/**\n * typescript interface for Persistent subscription config\n */\nexport interface PersistentSubscriptionConfig {\n  resolveLinkTos: boolean\n  startFrom: Long | number\n  messageTimeoutMilliseconds: number\n  recordStatistics: boolean\n  maxRetryCount: number\n  liveBufferSize: number\n  bufferSize: number\n  readBatchSize: number\n  checkpointAfterTime: number\n  checkpointMinCount: number\n  checkpointMaxCount: number\n  subscriberMaxCount: number\n  namedConsumerStrategy: string\n  preferRoundRobin: boolean\n}\n\n/** default persistent subscription config */\nconst defaultPersistentSubscriptionConfig: PersistentSubscriptionConfig = {\n  resolveLinkTos: true,\n  startFrom: StreamPosition.Start,\n  messageTimeoutMilliseconds: 10000,\n  recordStatistics: false,\n  maxRetryCount: 10,\n  liveBufferSize: 500,\n  bufferSize: 500,\n  readBatchSize: 20,\n  checkpointAfterTime: 1000,\n  checkpointMinCount: 10,\n  checkpointMaxCount: 500,\n  subscriberMaxCount: 10,\n  namedConsumerStrategy: SystemConsumerStrategies.RoundRobin,\n  preferRoundRobin: true\n}\n\n/**\n * merges given settings with default settings\n */\nexport function setPersistentSubscriptionConfig(\n  customSettings: object | PersistentSubscriptionConfig\n): PersistentSubscriptionConfig {\n  return {...defaultPersistentSubscriptionConfig, ...customSettings}\n}\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/src/subscription/PersistentSubscriptionConfig.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 416,
    "kind": "variable",
    "name": "SystemConsumerStrategies",
    "memberof": "src/subscription/PersistentSubscriptionConfig.ts",
    "static": true,
    "longname": "src/subscription/PersistentSubscriptionConfig.ts~SystemConsumerStrategies",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/subscription/PersistentSubscriptionConfig.ts",
    "importStyle": "{SystemConsumerStrategies}",
    "description": "constant definition of consumer strategies",
    "lineNumber": 5,
    "type": {
      "types": [
        "{\"DispatchToSingle\": string, \"RoundRobin\": string, \"Pinned\": string}"
      ]
    }
  },
  {
    "__docId__": 417,
    "kind": "variable",
    "name": "defaultPersistentSubscriptionConfig",
    "memberof": "src/subscription/PersistentSubscriptionConfig.ts",
    "static": true,
    "longname": "src/subscription/PersistentSubscriptionConfig.ts~defaultPersistentSubscriptionConfig",
    "access": "public",
    "export": false,
    "importPath": "eventstore-ts-client/src/subscription/PersistentSubscriptionConfig.ts",
    "importStyle": null,
    "description": "default persistent subscription config",
    "lineNumber": 32,
    "type": {
      "types": [
        "{\"resolveLinkTos\": boolean, \"startFrom\": *, \"messageTimeoutMilliseconds\": number, \"recordStatistics\": *, \"maxRetryCount\": number, \"liveBufferSize\": number, \"bufferSize\": number, \"readBatchSize\": number, \"checkpointAfterTime\": number, \"checkpointMinCount\": number, \"checkpointMaxCount\": number, \"subscriberMaxCount\": number, \"namedConsumerStrategy\": *, \"preferRoundRobin\": boolean}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 418,
    "kind": "function",
    "name": "setPersistentSubscriptionConfig",
    "memberof": "src/subscription/PersistentSubscriptionConfig.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/subscription/PersistentSubscriptionConfig.ts~setPersistentSubscriptionConfig",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/subscription/PersistentSubscriptionConfig.ts",
    "importStyle": "{setPersistentSubscriptionConfig}",
    "description": null,
    "lineNumber": 52,
    "undocument": true,
    "params": [
      {
        "types": [
          "object",
          "PersistentSubscriptionConfig"
        ],
        "name": "customSettings"
      }
    ],
    "type": {
      "types": [
        "PersistentSubscriptionConfig"
      ]
    }
  },
  {
    "__docId__": 419,
    "kind": "file",
    "name": "src/subscription/Subscription.ts",
    "content": "import {EventEmitter} from 'events'\nimport * as model from '../protobuf/model'\nimport {UserCredentials, Position} from '../eventstore'\nimport {Stream} from '../stream'\nimport {TCPConnection} from '../eventstore/TCPConnection'\nimport * as bunyan from 'bunyan'\nimport {Event} from '../event'\n\n/**\n * Base class for handling subscriptions\n * @emits {subscribed}\n * @emits {dropped}\n * @emits {event}\n * @emits {event-eventnametolowercase}\n * @emits {error}\n */\nexport class Subscription extends EventEmitter {\n  /** uuid4 of subscription */\n  protected subscriptionId: string\n  /** indicates if subscription is running */\n  public isSubscribed: boolean = false\n  /** connection to use */\n  protected tcpConnection: TCPConnection\n  /** credentials for subscription */\n  protected credentials: UserCredentials | null = null\n  /** instance of corresponding stream */\n  protected stream: Stream\n  /** indicates if events should be full resolved */\n  protected resolveLinkTos: boolean\n  /** logger */\n  public log: bunyan\n  /** global log position */\n  protected position: Position | null = null\n\n  /**\n   * Creates an instance of subscription.\n   */\n  public constructor(\n    subscriptionId: string,\n    tcpConnection: TCPConnection,\n    stream: Stream,\n    resolveLinkTos: boolean,\n    credentials: UserCredentials | null\n  ) {\n    super()\n    this.subscriptionId = subscriptionId\n    this.tcpConnection = tcpConnection\n    this.credentials = credentials\n    this.stream = stream\n    this.resolveLinkTos = resolveLinkTos\n    this.on('subscribed', this.onSubscribed)\n    this.on('dropped', this.onDropped)\n    this.on('event', this.onEvent)\n    this.on('error', this.onError)\n    this.log = stream.log.child({module: 'Subscription', subscriptionId: this.id})\n  }\n\n  /**\n   * Returns subscriptionId\n   */\n  public get id(): string {\n    return this.subscriptionId\n  }\n\n  /**\n   * Returns subscription nam\n   */\n  public get name(): string {\n    return 'Subscription: ' + this.subscriptionId\n  }\n\n  /**\n   * Gets get credentials\n   */\n  public get getCredentials(): UserCredentials | null {\n    return this.credentials\n  }\n\n  /**\n   * Gets resolve link tos\n   */\n  public getResolveLinkTos(): boolean {\n    return this.resolveLinkTos\n  }\n\n  /**\n   * Unsubscribe from stream\n   */\n  public async unsubscribe(): Promise<void> {\n    this.log.debug({fn: 'unsubscribe'}, 'unsubscribe subscription')\n    await this.tcpConnection.unsubscribeFromStream(this.id)\n  }\n\n  /**\n   * Called when event from eventstore arrives\n   */\n  public eventAppeared(event: Event, position: Position): void {\n    this.emit('event', event, position)\n    this.emit(`event-${event.name.toLocaleLowerCase()}`, event, position)\n  }\n\n  /**\n   * Called when subscription was dropped\n   */\n  protected onDropped(\n    reason: model.eventstore.proto.SubscriptionDropped.SubscriptionDropReason\n  ): void {\n    this.log.debug({reason}, 'Subscription dropped')\n  }\n\n  /**\n   * Determines whether event on\n   */\n  protected onEvent(event: Event, position: Position): void {\n    this.position = position\n    this.log.debug({eventName: event.name, eventId: event.id}, 'Event received')\n  }\n\n  /**\n   * Called when subscription is established\n   */\n  protected onSubscribed(): void {\n    this.log.debug(\n      {subscriptionId: this.subscriptionId, stream: this.stream.id},\n      'Subscription started'\n    )\n  }\n\n  /**\n   * Called when error appears\n   */\n  protected onError(err: Error): void {\n    this.log.error({err, subscriptionId: this.subscriptionId}, 'Error on subscription')\n  }\n}\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/src/subscription/Subscription.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 420,
    "kind": "class",
    "name": "Subscription",
    "memberof": "src/subscription/Subscription.ts",
    "static": true,
    "longname": "src/subscription/Subscription.ts~Subscription",
    "access": "public",
    "export": true,
    "importPath": "eventstore-ts-client/src/subscription/Subscription.ts",
    "importStyle": "{Subscription}",
    "description": "Base class for handling subscriptions",
    "lineNumber": 17,
    "emits": [
      {
        "types": [
          "subscribed"
        ],
        "description": ""
      },
      {
        "types": [
          "dropped"
        ],
        "description": ""
      },
      {
        "types": [
          "event"
        ],
        "description": ""
      },
      {
        "types": [
          "event-eventnametolowercase"
        ],
        "description": ""
      },
      {
        "types": [
          "error"
        ],
        "description": ""
      }
    ],
    "interface": false,
    "extends": [
      "events~EventEmitter"
    ]
  },
  {
    "__docId__": 421,
    "kind": "member",
    "name": "subscriptionId",
    "memberof": "src/subscription/Subscription.ts~Subscription",
    "static": false,
    "longname": "src/subscription/Subscription.ts~Subscription#subscriptionId",
    "access": "protected",
    "description": "uuid4 of subscription",
    "lineNumber": 19,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 422,
    "kind": "member",
    "name": "isSubscribed",
    "memberof": "src/subscription/Subscription.ts~Subscription",
    "static": false,
    "longname": "src/subscription/Subscription.ts~Subscription#isSubscribed",
    "access": "public",
    "description": "indicates if subscription is running",
    "lineNumber": 21,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 423,
    "kind": "member",
    "name": "tcpConnection",
    "memberof": "src/subscription/Subscription.ts~Subscription",
    "static": false,
    "longname": "src/subscription/Subscription.ts~Subscription#tcpConnection",
    "access": "protected",
    "description": "connection to use",
    "lineNumber": 23,
    "type": {
      "types": [
        "TCPConnection"
      ]
    }
  },
  {
    "__docId__": 424,
    "kind": "member",
    "name": "credentials",
    "memberof": "src/subscription/Subscription.ts~Subscription",
    "static": false,
    "longname": "src/subscription/Subscription.ts~Subscription#credentials",
    "access": "protected",
    "description": "credentials for subscription",
    "lineNumber": 25,
    "type": {
      "types": [
        "UserCredentials",
        "null"
      ]
    }
  },
  {
    "__docId__": 425,
    "kind": "member",
    "name": "stream",
    "memberof": "src/subscription/Subscription.ts~Subscription",
    "static": false,
    "longname": "src/subscription/Subscription.ts~Subscription#stream",
    "access": "protected",
    "description": "instance of corresponding stream",
    "lineNumber": 27,
    "type": {
      "types": [
        "Stream"
      ]
    }
  },
  {
    "__docId__": 426,
    "kind": "member",
    "name": "resolveLinkTos",
    "memberof": "src/subscription/Subscription.ts~Subscription",
    "static": false,
    "longname": "src/subscription/Subscription.ts~Subscription#resolveLinkTos",
    "access": "protected",
    "description": "indicates if events should be full resolved",
    "lineNumber": 29,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 427,
    "kind": "member",
    "name": "log",
    "memberof": "src/subscription/Subscription.ts~Subscription",
    "static": false,
    "longname": "src/subscription/Subscription.ts~Subscription#log",
    "access": "public",
    "description": "logger",
    "lineNumber": 31,
    "type": {
      "types": [
        "bunyan"
      ]
    }
  },
  {
    "__docId__": 428,
    "kind": "member",
    "name": "position",
    "memberof": "src/subscription/Subscription.ts~Subscription",
    "static": false,
    "longname": "src/subscription/Subscription.ts~Subscription#position",
    "access": "protected",
    "description": "global log position",
    "lineNumber": 33,
    "type": {
      "types": [
        "Position",
        "null"
      ]
    }
  },
  {
    "__docId__": 429,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/subscription/Subscription.ts~Subscription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/subscription/Subscription.ts~Subscription#constructor",
    "access": "public",
    "description": "Creates an instance of subscription.",
    "lineNumber": 38
  },
  {
    "__docId__": 436,
    "kind": "get",
    "name": "id",
    "memberof": "src/subscription/Subscription.ts~Subscription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/subscription/Subscription.ts~Subscription#id",
    "access": "public",
    "description": "Returns subscriptionId",
    "lineNumber": 61,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 437,
    "kind": "get",
    "name": "name",
    "memberof": "src/subscription/Subscription.ts~Subscription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/subscription/Subscription.ts~Subscription#name",
    "access": "public",
    "description": "Returns subscription nam",
    "lineNumber": 68,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 438,
    "kind": "get",
    "name": "getCredentials",
    "memberof": "src/subscription/Subscription.ts~Subscription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/subscription/Subscription.ts~Subscription#getCredentials",
    "access": "public",
    "description": "Gets get credentials",
    "lineNumber": 75,
    "type": {
      "types": [
        "UserCredentials",
        "null"
      ]
    }
  },
  {
    "__docId__": 439,
    "kind": "method",
    "name": "getResolveLinkTos",
    "memberof": "src/subscription/Subscription.ts~Subscription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/subscription/Subscription.ts~Subscription#getResolveLinkTos",
    "access": "public",
    "description": "Gets resolve link tos",
    "lineNumber": 82,
    "params": [],
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 440,
    "kind": "method",
    "name": "unsubscribe",
    "memberof": "src/subscription/Subscription.ts~Subscription",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/subscription/Subscription.ts~Subscription#unsubscribe",
    "access": "public",
    "description": "Unsubscribe from stream",
    "lineNumber": 89,
    "params": [],
    "type": {
      "types": [
        "Promise"
      ]
    }
  },
  {
    "__docId__": 441,
    "kind": "method",
    "name": "eventAppeared",
    "memberof": "src/subscription/Subscription.ts~Subscription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/subscription/Subscription.ts~Subscription#eventAppeared",
    "access": "public",
    "description": "Called when event from eventstore arrives",
    "lineNumber": 97,
    "params": [
      {
        "types": [
          "Event"
        ],
        "name": "event"
      },
      {
        "types": [
          "Position"
        ],
        "name": "position"
      }
    ],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 442,
    "kind": "method",
    "name": "onDropped",
    "memberof": "src/subscription/Subscription.ts~Subscription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/subscription/Subscription.ts~Subscription#onDropped",
    "access": "protected",
    "description": "Called when subscription was dropped",
    "lineNumber": 105,
    "params": [
      {
        "types": [],
        "name": "reason"
      }
    ],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 443,
    "kind": "method",
    "name": "onEvent",
    "memberof": "src/subscription/Subscription.ts~Subscription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/subscription/Subscription.ts~Subscription#onEvent",
    "access": "protected",
    "description": "Determines whether event on",
    "lineNumber": 114,
    "params": [
      {
        "types": [
          "Event"
        ],
        "name": "event"
      },
      {
        "types": [
          "Position"
        ],
        "name": "position"
      }
    ],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 445,
    "kind": "method",
    "name": "onSubscribed",
    "memberof": "src/subscription/Subscription.ts~Subscription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/subscription/Subscription.ts~Subscription#onSubscribed",
    "access": "protected",
    "description": "Called when subscription is established",
    "lineNumber": 122,
    "params": [],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 446,
    "kind": "method",
    "name": "onError",
    "memberof": "src/subscription/Subscription.ts~Subscription",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/subscription/Subscription.ts~Subscription#onError",
    "access": "protected",
    "description": "Called when error appears",
    "lineNumber": 132,
    "params": [
      {
        "types": [
          "Error"
        ],
        "name": "err"
      }
    ],
    "type": {
      "types": [
        "void"
      ]
    }
  },
  {
    "__docId__": 447,
    "kind": "file",
    "name": "src/subscription/index.ts",
    "content": "export {Subscription} from './Subscription'\nexport {PersistentSubscription} from './PersistentSubscription'\nexport {\n  setPersistentSubscriptionConfig,\n  PersistentSubscriptionConfig,\n  SystemConsumerStrategies\n} from './PersistentSubscriptionConfig'\n\nexport enum SubscriptionStatus {\n  disconnected,\n  connected,\n  catchup,\n  live,\n  paused\n}\n\nexport enum SubscriptionDropReason {\n  Unsubscribed = 0,\n  AccessDenied = 1,\n  NotFound = 2,\n  PersistentSubscriptionDeleted = 3,\n  SubscriberMaxCountReached = 4\n}\n\nexport enum NakAction {\n  Unknown = 0,\n  Park = 1,\n  Retry = 2,\n  Skip = 3,\n  Stop = 4\n}\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/src/subscription/index.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "kind": "index",
    "content": "# Eventstore typescript / ES6 javascript client lib\n\n[![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)\n[![Build Status](https://travis-ci.com/sebastianwessel/eventstore-ts-client.svg?branch=master)](https://travis-ci.com/sebastianwessel/eventstore-ts-client)\n[![Quality Gate Status](https://sonarcloud.io/api/project_badges/measure?project=sebastianwessel_eventstore-ts-client&metric=alert_status)](https://sonarcloud.io/dashboard?id=sebastianwessel_eventstore-ts-client)\n[![Coverage](https://sonarcloud.io/api/project_badges/measure?project=sebastianwessel_eventstore-ts-client&metric=coverage)](https://sonarcloud.io/dashboard?id=sebastianwessel_eventstore-ts-client)\n[![Lines of Code](https://sonarcloud.io/api/project_badges/measure?project=sebastianwessel_eventstore-ts-client&metric=ncloc)](https://sonarcloud.io/dashboard?id=sebastianwessel_eventstore-ts-client)\n\n[![Security Rating](https://sonarcloud.io/api/project_badges/measure?project=sebastianwessel_eventstore-ts-client&metric=security_rating)](https://sonarcloud.io/dashboard?id=sebastianwessel_eventstore-ts-client)\n[![Reliability Rating](https://sonarcloud.io/api/project_badges/measure?project=sebastianwessel_eventstore-ts-client&metric=reliability_rating)](https://sonarcloud.io/dashboard?id=sebastianwessel_eventstore-ts-client)\n[![Maintainability Rating](https://sonarcloud.io/api/project_badges/measure?project=sebastianwessel_eventstore-ts-client&metric=sqale_rating)](https://sonarcloud.io/dashboard?id=sebastianwessel_eventstore-ts-client)\n[![Vulnerabilities](https://sonarcloud.io/api/project_badges/measure?project=sebastianwessel_eventstore-ts-client&metric=vulnerabilities)](https://sonarcloud.io/dashboard?id=sebastianwessel_eventstore-ts-client)\n[![doc coverage](https://sebastianwessel.github.io/eventstore-ts-client/badge.svg)](https://sebastianwessel.github.io/eventstore-ts-client)\n\nEventstore node.js javascript client library written in typescript with ES6 async/await syntax.\n\nThis repository is **in BETA status**\n\nMain focus on this lib are:\n\n- available for typescript\n- available for ES6 with async/await syntax\n- well documented\n- clean code\n- proper code readability\n- proper testing\n- nice error handling\n\n## Documentation\n\nFull documentation is available at **[https://sebastianwessel.github.io/eventstore-ts-client/](https://sebastianwessel.github.io/eventstore-ts-client/)**\n\n## Requirements\n\nYou will need to have node.js version >=10 installed to use this lib because it's based on async iterators.  \nIt's tested against eventstore version 5, but should also work on lower versions in general.  \nExpect some shortcut function for accessing standard projections which are not part of lower eventstore versions.\n\n## Installation\n\nInstallation is as simple as most packages.  \nJust install package in your projects root with:\n\n```bash\nnpm i --save eventstore-ts-client\n```\n\n## Quick-Start\n\n```javascript\nconst {Eventstore, Event} = require('eventstore-ts-client')\nconst es = new Eventstore({\n  uri: 'tcp://admin:changeit@127.0.0.1:1113'\n})\nawait es.connect()\n\n\nconst eventA = new Event('EventA',{\n  some: 'string data',\n  num : 1\n})\nawait es.atStream('mystream').append(eventA)\n\nconst eventB = new Event('EventB',{\n  text: 'other string',\n  count : 2\n})\n\neventB.correlationId = eventA.id\nawait es.atStream('mystream').append(eventB)\n\nconst eventC = new Event('EventC')\nconst eventD = new Event('EventD')\n\nawait es.atStream('mystream').append([eventC, eventD])\n\nconst events = await es\n      .stream('mystream')\n      .walkStreamForward()\n\nfor await (const event of events) {\n  console.log(event.name)\n}\n\nawait es.close()\n```\n\nFor full documentation please visit:\n**[https://sebastianwessel.github.io/eventstore-ts-client/](https://sebastianwessel.github.io/eventstore-ts-client/)**\n\n## Building\n\nTo build this lib just clone this repo and run:\n\n```bash\nnpm install\nnpm run build\n```\n\n*Maybe you need to change file attributes of scripts inside of `scripts/` folder to be executable*\n\n## Test lib\n\neventstore-ts-client tests are heavily based on integration tests.\n\nTest are running against a 3 node eventstore cluster which will configured and filled with some test data and settings.  \nYou will need to have docker installed on your machine to be able to run tests.  \nThe setup contains a script which does all stuff for you - just type:\n\n```bash\nnpm run test\n```\n\nRunning tests will also generate some code coverage report to be used in tools like sonarqube\n\n## Apache 2.0 License\n\nsee [LICENSE](LICENSE)",
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"name\": \"eventstore-ts-client\",\n  \"version\": \"0.6.0\",\n  \"description\": \"Eventstore node.js javascript client library written in typescript with ES6 async/await syntax\",\n  \"main\": \"dist/index.js\",\n  \"typings\": \"dist/index.d.ts\",\n  \"scripts\": {\n    \"build\": \"./scripts/build.sh\",\n    \"lint\": \"eslint --cache .\",\n    \"lint:fix\": \"eslint . --fix\",\n    \"test\": \"./scripts/allTest.sh\",\n    \"nyc:all\": \"nyc --reporter=json --reporter=lcov --reporter=text mocha test/**/*.test.ts\",\n    \"test:unit\": \"mocha test/unitTests/**/*.test.ts\",\n    \"test:local\": \"mocha test/**/*.test.ts\",\n    \"doc\": \"esdoc\"\n  },\n  \"files\": [\n    \"dist/**/*\"\n  ],\n  \"pre-push\": [\n    \"lint\"\n  ],\n  \"engines\": {\n    \"node\": \">=10.0.0\",\n    \"npm\": \">=6.0.0\"\n  },\n  \"engineStrict\": true,\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"dependencies\": {\n    \"@types/bunyan\": \"^1.8.6\",\n    \"@types/long\": \"^4.0.0\",\n    \"@types/node\": \"^11.13.7\",\n    \"@types/request-promise-native\": \"^1.0.16\",\n    \"@types/uuid\": \"^3.4.4\",\n    \"bunyan\": \"^1.8.12\",\n    \"long\": \"^4.0.0\",\n    \"protobufjs\": \"^6.8.8\",\n    \"request\": \"^2.88.0\",\n    \"request-promise-native\": \"^1.0.7\",\n    \"uuid4\": \"^1.1.4\"\n  },\n  \"devDependencies\": {\n    \"@istanbuljs/nyc-config-typescript\": \"^0.1.1\",\n    \"@types/chai\": \"^4.1.7\",\n    \"@types/mocha\": \"^5.2.6\",\n    \"@types/sinon\": \"^7.0.11\",\n    \"@typescript-eslint/eslint-plugin\": \"^1.7.0\",\n    \"@typescript-eslint/parser\": \"^1.7.0\",\n    \"acorn\": \"^6.1.1\",\n    \"chai\": \"^4.2.0\",\n    \"@sebastianwessel/esdoc\": \"latest\",\n    \"@sebastianwessel/esdoc-ecmascript-proposal-plugin\": \"latest\",\n    \"@sebastianwessel/esdoc-integrate-manual-plugin\": \"latest\",\n    \"esdoc-node\": \"^1.0.4\",\n    \"@sebastianwessel/esdoc-standard-plugin\": \"latest\",\n    \"@sebastianwessel/esdoc-typescript-plugin\": \"latest\",\n    \"eslint\": \"^5.16.0\",\n    \"eslint-config-prettier\": \"^4.1.0\",\n    \"eslint-plugin-json\": \"^1.4.0\",\n    \"eslint-plugin-prettier\": \"^3.0.1\",\n    \"git-pre-push\": \"0.0.5\",\n    \"mocha\": \"^6.1.4\",\n    \"nyc\": \"^14.0.0\",\n    \"prettier\": \"^1.17.0\",\n    \"sinon\": \"^7.3.2\",\n    \"source-map-support\": \"^0.5.12\",\n    \"ts-node\": \"^8.1.0\",\n    \"typescript\": \"^3.4.5\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/sebastianwessel/eventstore-ts-client.git\"\n  },\n  \"keywords\": [\n    \"eventstore\",\n    \"geteventstore\",\n    \"event store\",\n    \"node\",\n    \"nodejs\",\n    \"node.js\",\n    \"javascript\",\n    \"client\",\n    \"typescript\",\n    \"eventsource\",\n    \"eventsourcing\",\n    \"event sourcing\",\n    \"cqrs\",\n    \"ddd\",\n    \"event\",\n    \"es6\",\n    \"async\",\n    \"await\"\n  ],\n  \"author\": \"Sebastian Wessel\",\n  \"license\": \"Apache-2.0\",\n  \"bugs\": {\n    \"url\": \"https://github.com/sebastianwessel/eventstore-ts-client/issues\"\n  },\n  \"homepage\": \"https://sebastianwessel.github.io/eventstore-ts-client/\"\n}\n",
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manualIndex",
    "globalIndex": true,
    "content": "# Eventstore typescript / ES6 javascript client lib\n\n[![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)\n[![Build Status](https://travis-ci.com/sebastianwessel/eventstore-ts-client.svg?branch=master)](https://travis-ci.com/sebastianwessel/eventstore-ts-client)\n[![Quality Gate Status](https://sonarcloud.io/api/project_badges/measure?project=sebastianwessel_eventstore-ts-client&metric=alert_status)](https://sonarcloud.io/dashboard?id=sebastianwessel_eventstore-ts-client)\n[![Coverage](https://sonarcloud.io/api/project_badges/measure?project=sebastianwessel_eventstore-ts-client&metric=coverage)](https://sonarcloud.io/dashboard?id=sebastianwessel_eventstore-ts-client)\n[![Lines of Code](https://sonarcloud.io/api/project_badges/measure?project=sebastianwessel_eventstore-ts-client&metric=ncloc)](https://sonarcloud.io/dashboard?id=sebastianwessel_eventstore-ts-client)\n\n[![Security Rating](https://sonarcloud.io/api/project_badges/measure?project=sebastianwessel_eventstore-ts-client&metric=security_rating)](https://sonarcloud.io/dashboard?id=sebastianwessel_eventstore-ts-client)\n[![Reliability Rating](https://sonarcloud.io/api/project_badges/measure?project=sebastianwessel_eventstore-ts-client&metric=reliability_rating)](https://sonarcloud.io/dashboard?id=sebastianwessel_eventstore-ts-client)\n[![Maintainability Rating](https://sonarcloud.io/api/project_badges/measure?project=sebastianwessel_eventstore-ts-client&metric=sqale_rating)](https://sonarcloud.io/dashboard?id=sebastianwessel_eventstore-ts-client)\n[![Vulnerabilities](https://sonarcloud.io/api/project_badges/measure?project=sebastianwessel_eventstore-ts-client&metric=vulnerabilities)](https://sonarcloud.io/dashboard?id=sebastianwessel_eventstore-ts-client)\n[![doc coverage](https://sebastianwessel.github.io/eventstore-ts-client/badge.svg)](https://sebastianwessel.github.io/eventstore-ts-client)\n\nEventstore node.js javascript client library written in typescript with ES6 async/await syntax.\n\nThis repository is **in BETA status**\n\nMain focus on this lib are:\n\n- available for typescript\n- available for ES6 with async/await syntax\n- well documented\n- clean code\n- proper code readability\n- proper testing\n- nice error handling\n\n## Documentation\n\nFull documentation is available at **[https://sebastianwessel.github.io/eventstore-ts-client/](https://sebastianwessel.github.io/eventstore-ts-client/)**\n\n## Requirements\n\nYou will need to have node.js version >=10 installed to use this lib because it's based on async iterators.  \nIt's tested against eventstore version 5, but should also work on lower versions in general.  \nExpect some shortcut function for accessing standard projections which are not part of lower eventstore versions.\n\n## Installation\n\nInstallation is as simple as most packages.  \nJust install package in your projects root with:\n\n```bash\nnpm i --save eventstore-ts-client\n```\n\n## Quick-Start\n\n```javascript\nconst {Eventstore, Event} = require('eventstore-ts-client')\nconst es = new Eventstore({\n  uri: 'tcp://admin:changeit@127.0.0.1:1113'\n})\nawait es.connect()\n\n\nconst eventA = new Event('EventA',{\n  some: 'string data',\n  num : 1\n})\nawait es.atStream('mystream').append(eventA)\n\nconst eventB = new Event('EventB',{\n  text: 'other string',\n  count : 2\n})\n\neventB.correlationId = eventA.id\nawait es.atStream('mystream').append(eventB)\n\nconst eventC = new Event('EventC')\nconst eventD = new Event('EventD')\n\nawait es.atStream('mystream').append([eventC, eventD])\n\nconst events = await es\n      .stream('mystream')\n      .walkStreamForward()\n\nfor await (const event of events) {\n  console.log(event.name)\n}\n\nawait es.close()\n```\n\nFor full documentation please visit:\n**[https://sebastianwessel.github.io/eventstore-ts-client/](https://sebastianwessel.github.io/eventstore-ts-client/)**\n\n## Building\n\nTo build this lib just clone this repo and run:\n\n```bash\nnpm install\nnpm run build\n```\n\n*Maybe you need to change file attributes of scripts inside of `scripts/` folder to be executable*\n\n## Test lib\n\neventstore-ts-client tests are heavily based on integration tests.\n\nTest are running against a 3 node eventstore cluster which will configured and filled with some test data and settings.  \nYou will need to have docker installed on your machine to be able to run tests.  \nThe setup contains a script which does all stuff for you - just type:\n\n```bash\nnpm run test\n```\n\nRunning tests will also generate some code coverage report to be used in tools like sonarqube\n\n## Apache 2.0 License\n\nsee [LICENSE](LICENSE)",
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/readme.md",
    "name": "./readme.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manualAsset",
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/manual/asset",
    "name": "./manual/asset",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/manual/readme.md",
    "name": "./manual/readme.md",
    "content": "# General\n\nThis library tries to help you to communicate with eventstore in a smooth way.\n\nThere are a couple of things like error handling or function naming which should help you to write nice and speaking code.\n\nIt follows async/await style to avoid \"callback hell\" as well.\n\n## speaking code\n\nInstead of having some base function with lots of parameters this lib provides some nice syntax and alias functions.  \nInstead of writing:\n\n```javascript\nvar esConnection = esClient.createConnection(connSettings, \"tcp://localhost:1113\");\nesConnection.connect();\n\nvar eventId = uuid.v4();\nvar eventData = {\n  a : Math.random(),\n  b : uuid.v4()\n};\nvar event = esClient.createJsonEventData(eventId, eventData, null, 'TestWasDone');\n\nesConnection.appendToStream('streamName', esClient.expectedVersion.any, event,someDifferentCredentials)\n  .then(function(result) {\n      console.log(\"Stored event:\", eventId);\n  })\n```\n\nyou should write something like:\n\n```javascript\nconst eventstore = new Eventstore('tcp://localhost:1113')\nawait eventstore.connect()\n\nconst eventTestWasDone = new Event('TestWasDone',{\n  a : Math.random(),\n  b : uuid.v4()\n})\n\nawait eventstore\n  .atStream('streamName')\n  .withCredentials(someDifferentCredentials)\n  .requiresMaster()\n  .append(eventTestWasDone)\n\n console.log(\"Stored event:\", eventTestWasDone.id)\n```\n\nAs you can see your code becomes a lot more self speaking and also someone who isn't familiar with your program or even unfamiliar with javascript/typescript is able to understand what these lines of code are doing.\n\nOf course you're able to use function parameters as well if you prefer it, but it's not recommended\n\n## Error handling\n\nThis client lib also uses named errors - so no need to parse error messages.  \nJust use `error.name` to identify different errors.  \nAlso the error instance may contain an additional field `causedBy` which will hold some error object if there was an error before which causes the current error.\n\nList of possible errors:\n\n- `EventstoreAccessDeniedError`\n- `EventstoreAlreadyExistError`\n- `EventstoreBadRequestError`\n- `EventstoreCommitTimeoutError`\n- `EventstoreConnectionError`\n- `EventstoreDoesNotExistError`\n- `EventstoreForwardTimeoutError`\n- `EventstoreImplementationError`\n- `EventstoreInvalidTransactionError`\n- `EventstoreNoStreamError`\n- `EventstoreNotAuthenticatedError`\n- `EventstoreNotFoundError`\n- `EventstoreNotHandledError`\n- `EventstoreNotModifiedError`\n- `EventstoreOperationError`\n- `EventstorePrepareTimeoutError`\n- `EventstoreProtocolError`\n- `EventstoreStreamDeletedError`\n- `EventstoreTimeoutError`\n- `EventstoreUnspecificError`\n- `EventstoreWrongExpectedVersionError`\n\n## request response queue\n\nThis lib does not use a queue for outgoing requests and commands.  \nMost outgoing requests will result in promises which will get resolved as soon as an valid response without error code arrives.  \nIf an connection to eventstore get lost while sending a request you will get an connection error immediately and this library will not try to resend requests for you.\n\nI strongly believe it's up to program logic to handle unexpected lost connection failures while sending some requests.  \nIt depends very hard on each usecase how to handle such failures and also if it's possible to reconnect or not.  \nTo avoid unsolvable questions like \"What to do with requests when...\" and because tcp connections are duplex connections there is no request queue.\nThis library tries to do as much as possible in real time and/or in asynchronous fashion.\n\nIf a correlating response for a request contains some error code the request promise will be rejected with correlating error.  \nIf no response arrives within given timeout setting the request will promise will be rejected with an `EventstoreTimeoutError`.",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/manual/eventstore.md",
    "name": "./manual/eventstore.md",
    "content": "# Eventstore\n\n## connecting\n\nMain connection parameters are set inside of connection uri  \nThis lib supports connecting to single instance via tcp and auto discovering to clusters also.  \nConnections can be unsecured or encrypted\n\n```javascript\n// connection to single instance at local at port 1113 with username and password\nconst es = new Eventstore({\n  uri: 'tcp://username:userpassword@127.0.0.1:1113'\n})\n\nawait es.connect()\n```\n\n```javascript\n// connection to cluster at domain escluster.net at port 2112 with username and password\nconst es = new Eventstore({\n  uri: 'discover://username:password@escluster.net:2112'\n})\n\nawait es.connect()\n\n//...same with some additional properties like encryption and connect to master only\nconst es = new Eventstore({\n  uri: 'discover://username:password@escluster.net:2112',\n  requireMaster:true,\n  useSSL: true,\n  validateServer: true,\n  secureContext: {\n    ca: fs.readFileSync('./rootCA.crt'),\n    key: fs.readFileSync('./domain.key'),\n    cert: fs.readFileSync('./domain.crt')\n  }\n})\n\nawait es.connect()\n```\n\n## disconnecting\n\nIt's highly recommended to close a connection in save way.  \nYou should use `es.disconnect()` for proper shut down, because this function sets current connection to state `drain`.  \nThis means the connection does not accept outgoing requests any longer and waits if necessary for outstanding responses from eventstore.  \n\n## emitted events\n\n- `connected` emitted as soon as connection is established\n- `secureConnect` emitted when connection is secured connected\n- `ready` emitted after `connected` after authentication and identify client\n- `reconnect` emitted as soon as lib tries to reconnect (param: reconnect count)\n- `close` emitted as soon as connection is closed\n- `drain` emitted when connection drains existing requests before connection close\n- `error` emitted on connection errors (param: error)\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/manual/streams.md",
    "name": "./manual/streams.md",
    "content": "# Streams\n\n## accessing steams\n\nYou can use different methods to get an stream instance:\n\n- `stream('streamId')`\n- `fromStream('streamId')`\n- `atStream('streamId')`\n\nTechnically they do same, but with these different named function calls you can improve readability of your code.\nYou can use it like:\n\n```javascript\nconst eventstore = new Eventstore()\nawait eventstore.connect()\n\nawait eventstore\n      .stream('streamId')\n      .softDelete()\n```\n\nor if you know you will do some read operation:\n\n```javascript\nconst eventstore = new Eventstore()\nawait eventstore.connect()\n\nconst metadata = await eventstore\n      .fromStream('userstream')\n      .getMetadata()\n```\n\nor if you do some write operation do it this way:\n\n```javascript\nconst eventstore = new Eventstore()\n\nconst eventUsernameChanged = new Event('UsernameChanged')\nawait eventstore.connect()\n\nawait eventstore\n      .atStream('userstream')\n      .append(eventUsernameChanged)\n```\n\n## writing to streams\n\nWriting to streams is simple by using `.append()` function at a stream instance.\n\n```javascript\nconst eventstore = new Eventstore()\nawait eventstore.connect()\n\nconst eventA = new Event('EventA',{\n  some: 'string data',\n  num : 1\n})\nawait eventstore.atStream('mystream').append(eventA)\n\nconst eventB = new Event('EventB',{\n  text: 'other string',\n  count : 2\n})\n\neventB.correlationId = eventA.id\nawait eventstore.atStream('mystream').append(eventB)\n\nconst eventC = new Event('EventC')\nconst eventD = new Event('EventD')\n\nawait eventstore.atStream('mystream').append([eventC, eventD])\n```\n\n## reading from stream\n\nIt's recommended to use an async iterator to fetch events from streams.  \n\n```javascript\nconst eventstore = new Eventstore()\nawait eventstore.connect()\n\nconst events = await eventstore\n      .stream('streamId')\n      .walkStreamForward()\n\nfor await (const event of events) {\n  console.log(event.name)\n}\n```\n\nYou can use handy functions of async iterator returned by `.walkStreamForward()` and `.walkStreamBackward()`.  \nThey are similar to array functions:\n\n- `map()`\n- `filter()`\n- `forEach()`\n- `reduce()`\n- `toArray()`\n- `every()`\n\n```javascript\nconst walker = await eventstore\n  .stream('streamId')\n  .walkStreamForward()\n\nconst result = await walker\n  .filter((event) => event.name != 'EventB')\n  .map((event) => {\n    return event.name\n  })\n  .toArray()\n\nconsole.log(result)\n```\n\n## reading all events\n\nIt's possible to read all events from eventstore.  \nIt uses same behavior as regular async iterator for streams but it **needs admin rights**.\n\n```javascript\nconst eventstore = new Eventstore()\nawait eventstore.connect()\n\nconst events = await eventstore.walkAllForward()\n\nfor await (const event of events) {\n  console.log(event.name)\n}\n```\n\nor it reverse from end to beginning\n\n```javascript\nconst eventstore = new Eventstore()\nawait eventstore.connect()\n\nconst events = await eventstore.walkAllBackward()\n\nfor await (const event of events) {\n  console.log(event.name)\n}\n```",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/manual/subscriptions.md",
    "name": "./manual/subscriptions.md",
    "content": "# Subscriptions\n\nThere are 3 different subscription types.  \nSimple stream subscriptions, persistent subscriptions and catchUp subscriptions.\n\n## subscribe to stream\n\nYou can use `subscribe()` at stream instances and simply adding listener(s) to returned subscription.  \nThere are two options.\n\nListen to all events:\n\n```javascript\nconst eventstore = new Eventstore()\nawait eventstore.connect()\n\nsubscription = await eventstore\n      .stream('streamId')\n      .subscribe()\n\nsubscription.on('event', (event) => {\n  console.log(event.name)\n})\n\n```\n\nListen for specific event:\n\n```javascript\nconst eventstore = new Eventstore()\nawait eventstore.connect()\n\nsubscription = await eventstore\n      .stream('streamId')\n      .subscribe()\n\n// listen for \"event-\"+ lowercase event name\nsubscription.on('event-specificeventa', (event) => {\n  console.log('log only SpecificEventA')\n})\n\n```\n\nWith this approach you're able to add different listeners for different needs to one single stream subscription.\n\n## persistent subscription\n\nYou can create persistent subscriptions (**needs admin rights**)\n\n```javascript\nconst eventstore = new Eventstore()\nawait eventstore.connect()\n\nconst persistentSubscription = await eventstore\n  .atStream('myStream')\n  .withCredentials({username: 'admin', password: 'changeit'})\n  .createPersistentSubscription('persistentsubscription')\n```\n\nYou can update an existing persistent subscription (**needs admin rights**)\n\n```javascript\nconst eventstore = new Eventstore()\nawait eventstore.connect()\n\nconst newConfig = {\n    messageTimeoutMilliseconds : 30000\n  }\n\nconst persistentSubscription = await eventstore\n  .atStream('myStream')\n  .withCredentials({username: 'admin', password: 'changeit'})\n  .getPersistentSubscription('persistentsubscription')\n  .update(newConfig)\n```\n\nYou can delete an existing persistent subscription (**needs admin rights**)\n\n```javascript\nconst eventstore = new Eventstore()\nawait eventstore.connect()\n\nconst newConfig = {\n    messageTimeoutMilliseconds : 30000\n  }\n\nconst persistentSubscription = eventstore\n  .atStream('myStream')\n  .withCredentials({username: 'admin', password: 'changeit'})\n  .getPersistentSubscription('persistentsubscription')\n  \nawait persistentSubscription.delete()\n```\n\nYou can connect to an existing persistent subscription\n\n```javascript\nconst eventstore = new Eventstore()\nawait eventstore.connect()\n\nconst newConfig = {\n    messageTimeoutMilliseconds : 30000\n  }\n\nconst persistentSubscription = eventstore\n  .atStream('myStream')\n  .getPersistentSubscription('persistentsubscription')\n  \nawait persistentSubscription.subscribe()\n```\n\nUnsubscribing an existing persistent subscription is also pretty easy\n\n```javascript\nawait persistentSubscription.unsubscribe()\n```\n\n## catchUp subscriptions\n\n/** TODO **/  \nnot implemented yet\n\n## emitted events\n\n- `subscribed` emitted after subscription is established\n- `dropped` emitted when subscription is dropped\n- `event` emitted when event appeared (param: Event)\n- `event-eventnametolowercase` emitted when event appeared (param: Event)\n- `error` emitted in error case (param: Error)",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/manual/events.md",
    "name": "./manual/events.md",
    "content": "# Events\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/manual/testing.md",
    "name": "./manual/testing.md",
    "content": "# Testing\n\n[![Quality Gate Status](https://sonarcloud.io/api/project_badges/measure?project=sebastianwessel_eventstore-ts-client&metric=alert_status)](https://sonarcloud.io/dashboard?id=sebastianwessel_eventstore-ts-client)\n[![Coverage](https://sonarcloud.io/api/project_badges/measure?project=sebastianwessel_eventstore-ts-client&metric=coverage)](https://sonarcloud.io/dashboard?id=sebastianwessel_eventstore-ts-client)\n[![codecov](https://codecov.io/gh/sebastianwessel/eventstore-ts-client/branch/master/graph/badge.svg)](https://codecov.io/gh/sebastianwessel/eventstore-ts-client)\n[![doc coverage](https://sebastianwessel.github.io/eventstore-ts-client/badge.svg)](https://sebastianwessel.github.io/eventstore-ts-client)\n[![Lines of Code](https://sonarcloud.io/api/project_badges/measure?project=sebastianwessel_eventstore-ts-client&metric=ncloc)](https://sonarcloud.io/dashboard?id=sebastianwessel_eventstore-ts-client)\n[![Bugs](https://sonarcloud.io/api/project_badges/measure?project=sebastianwessel_eventstore-ts-client&metric=bugs)](https://sonarcloud.io/dashboard?id=sebastianwessel_eventstore-ts-client)\n[![Code Smells](https://sonarcloud.io/api/project_badges/measure?project=sebastianwessel_eventstore-ts-client&metric=code_smells)](https://sonarcloud.io/dashboard?id=sebastianwessel_eventstore-ts-client)\n[![Security Rating](https://sonarcloud.io/api/project_badges/measure?project=sebastianwessel_eventstore-ts-client&metric=security_rating)](https://sonarcloud.io/dashboard?id=sebastianwessel_eventstore-ts-client)\n[![Reliability Rating](https://sonarcloud.io/api/project_badges/measure?project=sebastianwessel_eventstore-ts-client&metric=reliability_rating)](https://sonarcloud.io/dashboard?id=sebastianwessel_eventstore-ts-client)\n[![Maintainability Rating](https://sonarcloud.io/api/project_badges/measure?project=sebastianwessel_eventstore-ts-client&metric=sqale_rating)](https://sonarcloud.io/dashboard?id=sebastianwessel_eventstore-ts-client)\n[![Vulnerabilities](https://sonarcloud.io/api/project_badges/measure?project=sebastianwessel_eventstore-ts-client&metric=vulnerabilities)](https://sonarcloud.io/dashboard?id=sebastianwessel_eventstore-ts-client)\n\nTests are implemented as integration tests against a real eventstore cluster.  \nYou can find code coverage analysis at **[sonarcloud.com](https://sonarcloud.io/dashboard?id=sebastianwessel_eventstore-ts-client)** and at **[codecov.io](https://codecov.io/gh/sebastianwessel/eventstore-ts-client)**\n\n## requirements\n\n- node > 10\n- linux or mac for running bash scripts\n- installed Docker\n\n## running tests\n\n- install all dependencies `npm install`\n- run tests `npm run test`\n\n## test suite\n\nThe whole tests are configured and started by `scripts/allTest.sh`\n\n- starting eventstore with 3 cluster instances\n- building test container - a docker container containing this repository\n- adding test users to eventstore\n- setting up acl for eventstore\n- adding test streams to eventstore\n- starting test container and running tests within that container\n- shutting down eventstore clusters",
    "static": true,
    "access": "public"
  },
  {
    "__docId__": 448,
    "kind": "testFile",
    "name": "test/1_unitTests/1_eventstore/checkOperationResult.test.ts",
    "content": "/* eslint-disable @typescript-eslint/no-angle-bracket-type-assertion */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport {TCPConnection} from '../../../src/eventstore/TCPConnection'\nimport * as assert from 'assert'\nimport {EventstoreSettings, setConnectionSettings} from '../../../src/eventstore/EventstoreSettings'\nimport * as model from '../../../src/protobuf/model'\n\ndescribe('checkOperationResult', (): void => {\n  const protobuf = model.eventstore.proto\n\n  class TestTCP extends TCPConnection {\n    public constructor(connectionConfiguration: EventstoreSettings) {\n      super(connectionConfiguration)\n    }\n\n    public rejectCommandPromise(id: string, err): void {\n      throw err\n    }\n\n    public test(correlationId: string, result: number, message: string = ''): void {\n      this.checkOperationResult(correlationId, result, message)\n    }\n  }\n\n  it('handles OperationResult.AccessDenied', (): void => {\n    const testClass = new TestTCP(setConnectionSettings({}))\n\n    try {\n      testClass.test('id', protobuf.OperationResult.AccessDenied)\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreAccessDeniedError')\n    }\n  })\n\n  it('handles OperationResult.CommitTimeout', (): void => {\n    const testClass = new TestTCP(setConnectionSettings({}))\n\n    try {\n      testClass.test('id', protobuf.OperationResult.CommitTimeout)\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreCommitTimeoutError')\n    }\n  })\n\n  it('handles OperationResult.ForwardTimeout', (): void => {\n    const testClass = new TestTCP(setConnectionSettings({}))\n\n    try {\n      testClass.test('id', protobuf.OperationResult.ForwardTimeout)\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreForwardTimeoutError')\n    }\n  })\n\n  it('handles OperationResult.InvalidTransaction', (): void => {\n    const testClass = new TestTCP(setConnectionSettings({}))\n\n    try {\n      testClass.test('id', protobuf.OperationResult.InvalidTransaction)\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreInvalidTransactionError')\n    }\n  })\n\n  it('handles OperationResult.PrepareTimeout', (): void => {\n    const testClass = new TestTCP(setConnectionSettings({}))\n\n    try {\n      testClass.test('id', protobuf.OperationResult.PrepareTimeout)\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstorePrepareTimeoutError')\n    }\n  })\n\n  it('handles OperationResult.StreamDeleted', (): void => {\n    const testClass = new TestTCP(setConnectionSettings({}))\n\n    try {\n      testClass.test('id', protobuf.OperationResult.StreamDeleted)\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreStreamDeletedError')\n    }\n  })\n\n  it('handles OperationResult.WrongExpectedVersion', (): void => {\n    const testClass = new TestTCP(setConnectionSettings({}))\n\n    try {\n      testClass.test('id', protobuf.OperationResult.WrongExpectedVersion)\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreWrongExpectedVersionError')\n    }\n  })\n\n  it('handles OperationResult.Unspecific', (): void => {\n    const testClass = new TestTCP(setConnectionSettings({}))\n\n    try {\n      testClass.test('id', 10)\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreUnspecificError')\n    }\n  })\n})\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/test/1_unitTests/1_eventstore/checkOperationResult.test.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 449,
    "kind": "test",
    "name": "describe0",
    "testId": 0,
    "memberof": "test/1_unitTests/1_eventstore/checkOperationResult.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/checkOperationResult.test.ts~describe0",
    "access": null,
    "description": "checkOperationResult",
    "lineNumber": 9
  },
  {
    "__docId__": 450,
    "kind": "test",
    "name": "it1",
    "testId": 1,
    "memberof": "test/1_unitTests/1_eventstore/checkOperationResult.test.ts~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/checkOperationResult.test.ts~describe0.it1",
    "access": null,
    "description": "handles OperationResult.AccessDenied",
    "lineNumber": 26
  },
  {
    "__docId__": 451,
    "kind": "test",
    "name": "it2",
    "testId": 2,
    "memberof": "test/1_unitTests/1_eventstore/checkOperationResult.test.ts~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/checkOperationResult.test.ts~describe0.it2",
    "access": null,
    "description": "handles OperationResult.CommitTimeout",
    "lineNumber": 37
  },
  {
    "__docId__": 452,
    "kind": "test",
    "name": "it3",
    "testId": 3,
    "memberof": "test/1_unitTests/1_eventstore/checkOperationResult.test.ts~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/checkOperationResult.test.ts~describe0.it3",
    "access": null,
    "description": "handles OperationResult.ForwardTimeout",
    "lineNumber": 48
  },
  {
    "__docId__": 453,
    "kind": "test",
    "name": "it4",
    "testId": 4,
    "memberof": "test/1_unitTests/1_eventstore/checkOperationResult.test.ts~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/checkOperationResult.test.ts~describe0.it4",
    "access": null,
    "description": "handles OperationResult.InvalidTransaction",
    "lineNumber": 59
  },
  {
    "__docId__": 454,
    "kind": "test",
    "name": "it5",
    "testId": 5,
    "memberof": "test/1_unitTests/1_eventstore/checkOperationResult.test.ts~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/checkOperationResult.test.ts~describe0.it5",
    "access": null,
    "description": "handles OperationResult.PrepareTimeout",
    "lineNumber": 70
  },
  {
    "__docId__": 455,
    "kind": "test",
    "name": "it6",
    "testId": 6,
    "memberof": "test/1_unitTests/1_eventstore/checkOperationResult.test.ts~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/checkOperationResult.test.ts~describe0.it6",
    "access": null,
    "description": "handles OperationResult.StreamDeleted",
    "lineNumber": 81
  },
  {
    "__docId__": 456,
    "kind": "test",
    "name": "it7",
    "testId": 7,
    "memberof": "test/1_unitTests/1_eventstore/checkOperationResult.test.ts~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/checkOperationResult.test.ts~describe0.it7",
    "access": null,
    "description": "handles OperationResult.WrongExpectedVersion",
    "lineNumber": 92
  },
  {
    "__docId__": 457,
    "kind": "test",
    "name": "it8",
    "testId": 8,
    "memberof": "test/1_unitTests/1_eventstore/checkOperationResult.test.ts~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/checkOperationResult.test.ts~describe0.it8",
    "access": null,
    "description": "handles OperationResult.Unspecific",
    "lineNumber": 103
  },
  {
    "__docId__": 458,
    "kind": "testFile",
    "name": "test/1_unitTests/1_eventstore/checkTimeout.test.ts",
    "content": "import * as assert from 'assert'\nimport {TCPConnection} from '../../../src/eventstore/TCPConnection'\nimport {setConnectionSettings} from '../../../src/eventstore/EventstoreSettings'\nimport uuid = require('uuid/v4')\nimport * as sinon from 'sinon'\n\ndescribe('checkTimeout', (): void => {\n  let sandbox\n\n  beforeEach(\n    (): void => {\n      sandbox = sinon.createSandbox()\n    }\n  )\n\n  afterEach(\n    (): void => {\n      sandbox.reset()\n    }\n  )\n\n  class TestClass extends TCPConnection {\n    public constructor() {\n      super(\n        setConnectionSettings({\n          port: 0,\n          host: '',\n          operationTimeout: 100,\n          operationTimeoutCheckPeriod: 100,\n          connectTimeout: 1\n        })\n      )\n      this.state = 2\n    }\n\n    public addRequest(uuid: string, resolve: Function, reject: Function, sendTime: number): void {\n      this.pendingRequests.set(uuid, {resolve, reject, sendTime})\n    }\n\n    public checkTimeout(): void {\n      super.checkTimeout()\n    }\n  }\n\n  it('throws timed out promises', async (): Promise<void> => {\n    const testClass = new TestClass()\n    const prom = new Promise(\n      (resolve, reject): void => {\n        testClass.addRequest(uuid(), resolve, reject, Date.now() - 5000)\n      }\n    )\n    testClass.checkTimeout()\n    try {\n      await prom\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreTimeoutError')\n    }\n  })\n\n  it('logs errors on timeout', async (): Promise<void> => {\n    sandbox.stub(TestClass.prototype, 'rejectCommandPromise').throws(new Error())\n\n    const testClass = new TestClass()\n    const prom = new Promise(\n      (resolve, reject): void => {\n        testClass.addRequest(uuid(), resolve, reject, Date.now() - 5000)\n      }\n    )\n\n    try {\n      testClass.checkTimeout()\n      assert.ok('does not throw')\n    } catch (err) {\n      assert.fail(err)\n    }\n  })\n})\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/test/1_unitTests/1_eventstore/checkTimeout.test.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 459,
    "kind": "test",
    "name": "describe9",
    "testId": 9,
    "memberof": "test/1_unitTests/1_eventstore/checkTimeout.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/checkTimeout.test.ts~describe9",
    "access": null,
    "description": "checkTimeout",
    "lineNumber": 7
  },
  {
    "__docId__": 460,
    "kind": "test",
    "name": "it10",
    "testId": 10,
    "memberof": "test/1_unitTests/1_eventstore/checkTimeout.test.ts~describe9",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/checkTimeout.test.ts~describe9.it10",
    "access": null,
    "description": "throws timed out promises",
    "lineNumber": 45
  },
  {
    "__docId__": 461,
    "kind": "test",
    "name": "it11",
    "testId": 11,
    "memberof": "test/1_unitTests/1_eventstore/checkTimeout.test.ts~describe9",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/checkTimeout.test.ts~describe9.it11",
    "access": null,
    "description": "logs errors on timeout",
    "lineNumber": 61
  },
  {
    "__docId__": 462,
    "kind": "testFile",
    "name": "test/1_unitTests/1_eventstore/disconnect.test.ts",
    "content": "import * as assert from 'assert'\nimport {TCPConnection} from '../../../src/eventstore/TCPConnection'\nimport {setConnectionSettings} from '../../../src/eventstore/EventstoreSettings'\nimport uuid = require('uuid/v4')\n\ndescribe('disconnect', (): void => {\n  class TestClass extends TCPConnection {\n    public constructor() {\n      super(\n        setConnectionSettings({\n          port: 0,\n          host: '',\n          operationTimeout: 100,\n          operationTimeoutCheckPeriod: 100,\n          connectTimeout: 1\n        })\n      )\n      this.state = 2\n    }\n\n    public addRequest(uuid: string, resolve: Function, reject: Function, sendTime: number): void {\n      this.pendingRequests.set(uuid, {resolve, reject, sendTime})\n    }\n  }\n\n  it('throws on empty port or host', async (): Promise<void> => {\n    const testClass = new TestClass()\n    const prom = new Promise(\n      (resolve, reject): void => {\n        testClass.addRequest(uuid(), resolve, reject, Date.now())\n      }\n    )\n    const d = testClass.disconnect()\n    try {\n      await prom\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreConnectionError')\n    }\n    await d\n  })\n})\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/test/1_unitTests/1_eventstore/disconnect.test.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 463,
    "kind": "test",
    "name": "describe12",
    "testId": 12,
    "memberof": "test/1_unitTests/1_eventstore/disconnect.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/disconnect.test.ts~describe12",
    "access": null,
    "description": "disconnect",
    "lineNumber": 6
  },
  {
    "__docId__": 464,
    "kind": "test",
    "name": "it13",
    "testId": 13,
    "memberof": "test/1_unitTests/1_eventstore/disconnect.test.ts~describe12",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/disconnect.test.ts~describe12.it13",
    "access": null,
    "description": "throws on empty port or host",
    "lineNumber": 26
  },
  {
    "__docId__": 465,
    "kind": "testFile",
    "name": "test/1_unitTests/1_eventstore/getConnectionInfo.test.ts",
    "content": "import {\n  getIpListFromDns,\n  fetchgossipJson,\n  getIpAndPort\n} from '../../../src/eventstore/getConnectInfo'\nimport * as assert from 'assert'\nimport * as bunyan from 'bunyan'\nimport {setConnectionSettings} from '../../../src/eventstore/EventstoreSettings'\n\ndescribe('Gossip connection info', (): void => {\n  const log = bunyan.createLogger({name: 'unittest'})\n\n  it('returns empty array on dns error', async (): Promise<void> => {\n    const result = await getIpListFromDns('unknown', log)\n    assert.strictEqual(JSON.stringify(result), JSON.stringify([]))\n  })\n\n  it('returns null on error', async (): Promise<void> => {\n    const result = await fetchgossipJson('unknown', 80, true, 100, log)\n    assert.strictEqual(result, null)\n  })\n\n  it('returns same settings', async (): Promise<void> => {\n    const originalSettings = setConnectionSettings({\n      uri: '',\n      host: '',\n      port: 0,\n      gossipSeeds: [],\n      clusterDns: ''\n    })\n    const result = await getIpAndPort({...originalSettings}, log)\n    assert.strictEqual(JSON.stringify(result), JSON.stringify(originalSettings))\n  })\n})\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/test/1_unitTests/1_eventstore/getConnectionInfo.test.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 466,
    "kind": "test",
    "name": "describe14",
    "testId": 14,
    "memberof": "test/1_unitTests/1_eventstore/getConnectionInfo.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/getConnectionInfo.test.ts~describe14",
    "access": null,
    "description": "Gossip connection info",
    "lineNumber": 10
  },
  {
    "__docId__": 467,
    "kind": "test",
    "name": "it15",
    "testId": 15,
    "memberof": "test/1_unitTests/1_eventstore/getConnectionInfo.test.ts~describe14",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/getConnectionInfo.test.ts~describe14.it15",
    "access": null,
    "description": "returns empty array on dns error",
    "lineNumber": 13
  },
  {
    "__docId__": 468,
    "kind": "test",
    "name": "it16",
    "testId": 16,
    "memberof": "test/1_unitTests/1_eventstore/getConnectionInfo.test.ts~describe14",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/getConnectionInfo.test.ts~describe14.it16",
    "access": null,
    "description": "returns null on error",
    "lineNumber": 18
  },
  {
    "__docId__": 469,
    "kind": "test",
    "name": "it17",
    "testId": 17,
    "memberof": "test/1_unitTests/1_eventstore/getConnectionInfo.test.ts~describe14",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/getConnectionInfo.test.ts~describe14.it17",
    "access": null,
    "description": "returns same settings",
    "lineNumber": 23
  },
  {
    "__docId__": 470,
    "kind": "testFile",
    "name": "test/1_unitTests/1_eventstore/handleReadAllEventsCompleted.test.ts",
    "content": "/* eslint-disable @typescript-eslint/no-angle-bracket-type-assertion */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport {TCPConnection} from '../../../src/eventstore/TCPConnection'\nimport * as assert from 'assert'\nimport {EventstoreSettings, setConnectionSettings} from '../../../src/eventstore/EventstoreSettings'\nimport * as model from '../../../src/protobuf/model'\n\ndescribe('handleReadAllEventsCompleted', (): void => {\n  const protobuf = model.eventstore.proto\n\n  class TestTCP extends TCPConnection {\n    public constructor(connectionConfiguration: EventstoreSettings) {\n      super(connectionConfiguration)\n    }\n\n    public rejectCommandPromise(id: string, err): void {\n      throw err\n    }\n\n    public test(id: string, b: Buffer): void {\n      this.handleReadAllEventsCompleted(id, b)\n    }\n  }\n\n  it('handles ReadEventResult.AccessDenied', (): void => {\n    const testClass = new TestTCP(setConnectionSettings({}))\n\n    const testBuffer = Buffer.from(\n      protobuf.ReadAllEventsCompleted.encode({\n        commitPosition: 0,\n        preparePosition: 0,\n        events: [],\n        nextCommitPosition: 0,\n        nextPreparePosition: 0,\n        result: protobuf.ReadAllEventsCompleted.ReadAllResult.AccessDenied\n      }).finish()\n    )\n\n    try {\n      testClass.test('id', testBuffer)\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreAccessDeniedError')\n    }\n  })\n\n  it('handles ReadEventResult.NotModified', (): void => {\n    const testClass = new TestTCP(setConnectionSettings({}))\n\n    const testBuffer = Buffer.from(\n      protobuf.ReadAllEventsCompleted.encode({\n        commitPosition: 0,\n        preparePosition: 0,\n        events: [],\n        nextCommitPosition: 0,\n        nextPreparePosition: 0,\n        result: protobuf.ReadAllEventsCompleted.ReadAllResult.NotModified\n      }).finish()\n    )\n\n    try {\n      testClass.test('id', testBuffer)\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreNotModifiedError')\n    }\n  })\n\n  it('handles ReadEventResult.UnspecificError', (): void => {\n    const testClass = new TestTCP(setConnectionSettings({}))\n\n    const testBuffer = Buffer.from(\n      protobuf.ReadAllEventsCompleted.encode({\n        commitPosition: 0,\n        preparePosition: 0,\n        events: [],\n        nextCommitPosition: 0,\n        nextPreparePosition: 0,\n        result: protobuf.ReadAllEventsCompleted.ReadAllResult.Error,\n        error: 'some error'\n      }).finish()\n    )\n\n    try {\n      testClass.test('id', testBuffer)\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreUnspecificError')\n    }\n  })\n})\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/test/1_unitTests/1_eventstore/handleReadAllEventsCompleted.test.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 471,
    "kind": "test",
    "name": "describe18",
    "testId": 18,
    "memberof": "test/1_unitTests/1_eventstore/handleReadAllEventsCompleted.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/handleReadAllEventsCompleted.test.ts~describe18",
    "access": null,
    "description": "handleReadAllEventsCompleted",
    "lineNumber": 9
  },
  {
    "__docId__": 472,
    "kind": "test",
    "name": "it19",
    "testId": 19,
    "memberof": "test/1_unitTests/1_eventstore/handleReadAllEventsCompleted.test.ts~describe18",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/handleReadAllEventsCompleted.test.ts~describe18.it19",
    "access": null,
    "description": "handles ReadEventResult.AccessDenied",
    "lineNumber": 26
  },
  {
    "__docId__": 473,
    "kind": "test",
    "name": "it20",
    "testId": 20,
    "memberof": "test/1_unitTests/1_eventstore/handleReadAllEventsCompleted.test.ts~describe18",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/handleReadAllEventsCompleted.test.ts~describe18.it20",
    "access": null,
    "description": "handles ReadEventResult.NotModified",
    "lineNumber": 48
  },
  {
    "__docId__": 474,
    "kind": "test",
    "name": "it21",
    "testId": 21,
    "memberof": "test/1_unitTests/1_eventstore/handleReadAllEventsCompleted.test.ts~describe18",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/handleReadAllEventsCompleted.test.ts~describe18.it21",
    "access": null,
    "description": "handles ReadEventResult.UnspecificError",
    "lineNumber": 70
  },
  {
    "__docId__": 475,
    "kind": "testFile",
    "name": "test/1_unitTests/1_eventstore/handleReadEventCompleted.test.ts",
    "content": "/* eslint-disable @typescript-eslint/no-angle-bracket-type-assertion */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport {TCPConnection} from '../../../src/eventstore/TCPConnection'\nimport * as assert from 'assert'\nimport {EventstoreSettings, setConnectionSettings} from '../../../src/eventstore/EventstoreSettings'\nimport * as model from '../../../src/protobuf/model'\n\ndescribe('handleReadEventCompleted', (): void => {\n  const protobuf = model.eventstore.proto\n\n  class TestTCP extends TCPConnection {\n    public constructor(connectionConfiguration: EventstoreSettings) {\n      super(connectionConfiguration)\n    }\n\n    public rejectCommandPromise(id: string, err): void {\n      throw err\n    }\n\n    public test(id: string, b: Buffer): void {\n      this.handleReadEventCompleted(id, b)\n    }\n  }\n\n  it('handles ReadEventResult.NotFound', (): void => {\n    const testClass = new TestTCP(setConnectionSettings({}))\n\n    const testBuffer = Buffer.from(\n      protobuf.ReadEventCompleted.encode({\n        event: protobuf.ResolvedEvent.fromObject({\n          event: null,\n          link: null,\n          commitPosition: 0,\n          preparePosition: 0\n        }),\n        result: protobuf.ReadEventCompleted.ReadEventResult.NotFound\n      }).finish()\n    )\n\n    try {\n      testClass.test('id', testBuffer)\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreNotFoundError')\n    }\n  })\n\n  it('handles ReadEventResult.NoStream', (): void => {\n    const testClass = new TestTCP(setConnectionSettings({}))\n\n    const testBuffer = Buffer.from(\n      protobuf.ReadEventCompleted.encode({\n        event: protobuf.ResolvedEvent.fromObject({\n          event: null,\n          link: null,\n          commitPosition: 0,\n          preparePosition: 0\n        }),\n        result: protobuf.ReadEventCompleted.ReadEventResult.NoStream\n      }).finish()\n    )\n\n    try {\n      testClass.test('id', testBuffer)\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreNoStreamError')\n    }\n  })\n\n  it('handles ReadEventResult.StreamDeleted', (): void => {\n    const testClass = new TestTCP(setConnectionSettings({}))\n\n    const testBuffer = Buffer.from(\n      protobuf.ReadEventCompleted.encode({\n        event: protobuf.ResolvedEvent.fromObject({\n          event: null,\n          link: null,\n          commitPosition: 0,\n          preparePosition: 0\n        }),\n        result: protobuf.ReadEventCompleted.ReadEventResult.StreamDeleted\n      }).finish()\n    )\n\n    try {\n      testClass.test('id', testBuffer)\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreStreamDeletedError')\n    }\n  })\n})\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/test/1_unitTests/1_eventstore/handleReadEventCompleted.test.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 476,
    "kind": "test",
    "name": "describe22",
    "testId": 22,
    "memberof": "test/1_unitTests/1_eventstore/handleReadEventCompleted.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/handleReadEventCompleted.test.ts~describe22",
    "access": null,
    "description": "handleReadEventCompleted",
    "lineNumber": 9
  },
  {
    "__docId__": 477,
    "kind": "test",
    "name": "it23",
    "testId": 23,
    "memberof": "test/1_unitTests/1_eventstore/handleReadEventCompleted.test.ts~describe22",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/handleReadEventCompleted.test.ts~describe22.it23",
    "access": null,
    "description": "handles ReadEventResult.NotFound",
    "lineNumber": 26
  },
  {
    "__docId__": 478,
    "kind": "test",
    "name": "it24",
    "testId": 24,
    "memberof": "test/1_unitTests/1_eventstore/handleReadEventCompleted.test.ts~describe22",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/handleReadEventCompleted.test.ts~describe22.it24",
    "access": null,
    "description": "handles ReadEventResult.NoStream",
    "lineNumber": 49
  },
  {
    "__docId__": 479,
    "kind": "test",
    "name": "it25",
    "testId": 25,
    "memberof": "test/1_unitTests/1_eventstore/handleReadEventCompleted.test.ts~describe22",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/handleReadEventCompleted.test.ts~describe22.it25",
    "access": null,
    "description": "handles ReadEventResult.StreamDeleted",
    "lineNumber": 72
  },
  {
    "__docId__": 480,
    "kind": "testFile",
    "name": "test/1_unitTests/1_eventstore/handleReadStreamEventsCompleted.test.ts",
    "content": "/* eslint-disable @typescript-eslint/no-angle-bracket-type-assertion */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport {TCPConnection} from '../../../src/eventstore/TCPConnection'\nimport * as assert from 'assert'\nimport {EventstoreSettings, setConnectionSettings} from '../../../src/eventstore/EventstoreSettings'\nimport * as model from '../../../src/protobuf/model'\n\ndescribe('handleReadStreamEventsCompleted', (): void => {\n  const protobuf = model.eventstore.proto\n\n  class TestTCP extends TCPConnection {\n    public constructor(connectionConfiguration: EventstoreSettings) {\n      super(connectionConfiguration)\n    }\n\n    public rejectCommandPromise(id: string, err): void {\n      throw err\n    }\n\n    public test(id: string, b: Buffer): void {\n      this.handleReadStreamEventsCompleted(id, b)\n    }\n  }\n\n  it('handles ReadStreamResult.NoStream', (): void => {\n    const testClass = new TestTCP(setConnectionSettings({}))\n\n    const testBuffer = Buffer.from(\n      protobuf.ReadStreamEventsCompleted.encode({\n        events: null,\n        nextEventNumber: 0,\n        lastEventNumber: 0,\n        isEndOfStream: true,\n        lastCommitPosition: 0,\n        result: protobuf.ReadStreamEventsCompleted.ReadStreamResult.NoStream\n      }).finish()\n    )\n\n    try {\n      testClass.test('id', testBuffer)\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreNoStreamError')\n    }\n  })\n\n  it('handles ReadStreamResult.NotModified', (): void => {\n    const testClass = new TestTCP(setConnectionSettings({}))\n\n    const testBuffer = Buffer.from(\n      protobuf.ReadStreamEventsCompleted.encode({\n        events: null,\n        nextEventNumber: 0,\n        lastEventNumber: 0,\n        isEndOfStream: true,\n        lastCommitPosition: 0,\n        result: protobuf.ReadStreamEventsCompleted.ReadStreamResult.NotModified\n      }).finish()\n    )\n\n    try {\n      testClass.test('id', testBuffer)\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreNotModifiedError')\n    }\n  })\n\n  it('handles ReadStreamResult.StreamDeleted', (): void => {\n    const testClass = new TestTCP(setConnectionSettings({}))\n\n    const testBuffer = Buffer.from(\n      protobuf.ReadStreamEventsCompleted.encode({\n        events: null,\n        nextEventNumber: 0,\n        lastEventNumber: 0,\n        isEndOfStream: true,\n        lastCommitPosition: 0,\n        result: protobuf.ReadStreamEventsCompleted.ReadStreamResult.StreamDeleted\n      }).finish()\n    )\n\n    try {\n      testClass.test('id', testBuffer)\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreStreamDeletedError')\n    }\n  })\n\n  it('handles ReadStreamResult.AccessDenied', (): void => {\n    const testClass = new TestTCP(setConnectionSettings({}))\n\n    const testBuffer = Buffer.from(\n      protobuf.ReadStreamEventsCompleted.encode({\n        events: null,\n        nextEventNumber: 0,\n        lastEventNumber: 0,\n        isEndOfStream: true,\n        lastCommitPosition: 0,\n        result: protobuf.ReadStreamEventsCompleted.ReadStreamResult.AccessDenied\n      }).finish()\n    )\n\n    try {\n      testClass.test('id', testBuffer)\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreAccessDeniedError')\n    }\n  })\n})\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/test/1_unitTests/1_eventstore/handleReadStreamEventsCompleted.test.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 481,
    "kind": "test",
    "name": "describe26",
    "testId": 26,
    "memberof": "test/1_unitTests/1_eventstore/handleReadStreamEventsCompleted.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/handleReadStreamEventsCompleted.test.ts~describe26",
    "access": null,
    "description": "handleReadStreamEventsCompleted",
    "lineNumber": 9
  },
  {
    "__docId__": 482,
    "kind": "test",
    "name": "it27",
    "testId": 27,
    "memberof": "test/1_unitTests/1_eventstore/handleReadStreamEventsCompleted.test.ts~describe26",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/handleReadStreamEventsCompleted.test.ts~describe26.it27",
    "access": null,
    "description": "handles ReadStreamResult.NoStream",
    "lineNumber": 26
  },
  {
    "__docId__": 483,
    "kind": "test",
    "name": "it28",
    "testId": 28,
    "memberof": "test/1_unitTests/1_eventstore/handleReadStreamEventsCompleted.test.ts~describe26",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/handleReadStreamEventsCompleted.test.ts~describe26.it28",
    "access": null,
    "description": "handles ReadStreamResult.NotModified",
    "lineNumber": 48
  },
  {
    "__docId__": 484,
    "kind": "test",
    "name": "it29",
    "testId": 29,
    "memberof": "test/1_unitTests/1_eventstore/handleReadStreamEventsCompleted.test.ts~describe26",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/handleReadStreamEventsCompleted.test.ts~describe26.it29",
    "access": null,
    "description": "handles ReadStreamResult.StreamDeleted",
    "lineNumber": 70
  },
  {
    "__docId__": 485,
    "kind": "test",
    "name": "it30",
    "testId": 30,
    "memberof": "test/1_unitTests/1_eventstore/handleReadStreamEventsCompleted.test.ts~describe26",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/handleReadStreamEventsCompleted.test.ts~describe26.it30",
    "access": null,
    "description": "handles ReadStreamResult.AccessDenied",
    "lineNumber": 92
  },
  {
    "__docId__": 486,
    "kind": "testFile",
    "name": "test/1_unitTests/1_eventstore/handleResponseData.test.ts",
    "content": "import * as assert from 'assert'\nimport {TCPConnection} from '../../../src/eventstore/TCPConnection'\nimport {setConnectionSettings} from '../../../src/eventstore/EventstoreSettings'\n\ndescribe('TCPConnection', (): void => {\n  class TestClass extends TCPConnection {\n    public constructor() {\n      super(\n        setConnectionSettings({\n          port: 0,\n          host: '',\n          operationTimeout: 100,\n          operationTimeoutCheckPeriod: 100,\n          connectTimeout: 1,\n          maxQueueSize: 2\n        })\n      )\n      this.state = 2\n    }\n\n    public handleMultiPacketResponseData(buffer: Buffer): Buffer | null {\n      return super.handleMultiPacketResponseData(buffer)\n    }\n\n    public handleNewResponseData(buffer: Buffer): Buffer | null {\n      return super.handleNewResponseData(buffer)\n    }\n\n    public handleSingleResponseData(buffer: Buffer): void {\n      return super.handleSingleResponseData(buffer)\n    }\n  }\n\n  describe('handleMultiPacketResponseData', (): void => {\n    it('returns null when param is null', async (): Promise<void> => {\n      const testClass = new TestClass()\n      const result = testClass.handleMultiPacketResponseData(null)\n      assert.strictEqual(result, null)\n    })\n  })\n\n  describe('handleNewResponseData', (): void => {\n    it('throws on invalid command length', async (): Promise<void> => {\n      const testClass = new TestClass()\n      let buf = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0])\n      try {\n        testClass.handleNewResponseData(buf)\n        assert.fail('has not thrown')\n      } catch (err) {\n        assert.strictEqual(err.name, 'EventstoreProtocolError')\n      }\n    })\n  })\n\n  describe('handleSingleResponseData', (): void => {\n    it('throws on invalid command length', async (): Promise<void> => {\n      const testClass = new TestClass()\n      let buf = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0])\n      try {\n        testClass.handleSingleResponseData(buf)\n        assert.fail('has not thrown')\n      } catch (err) {\n        assert.strictEqual(err.name, 'EventstoreProtocolError')\n      }\n    })\n  })\n})\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/test/1_unitTests/1_eventstore/handleResponseData.test.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 487,
    "kind": "test",
    "name": "describe31",
    "testId": 31,
    "memberof": "test/1_unitTests/1_eventstore/handleResponseData.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/handleResponseData.test.ts~describe31",
    "access": null,
    "description": "TCPConnection",
    "lineNumber": 5
  },
  {
    "__docId__": 488,
    "kind": "test",
    "name": "describe32",
    "testId": 32,
    "memberof": "test/1_unitTests/1_eventstore/handleResponseData.test.ts~describe31",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/handleResponseData.test.ts~describe31.describe32",
    "access": null,
    "description": "handleMultiPacketResponseData",
    "lineNumber": 34
  },
  {
    "__docId__": 489,
    "kind": "test",
    "name": "it33",
    "testId": 33,
    "memberof": "test/1_unitTests/1_eventstore/handleResponseData.test.ts~describe31.describe32",
    "testDepth": 2,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/handleResponseData.test.ts~describe31.describe32.it33",
    "access": null,
    "description": "returns null when param is null",
    "lineNumber": 35
  },
  {
    "__docId__": 490,
    "kind": "test",
    "name": "describe34",
    "testId": 34,
    "memberof": "test/1_unitTests/1_eventstore/handleResponseData.test.ts~describe31",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/handleResponseData.test.ts~describe31.describe34",
    "access": null,
    "description": "handleNewResponseData",
    "lineNumber": 42
  },
  {
    "__docId__": 491,
    "kind": "test",
    "name": "it35",
    "testId": 35,
    "memberof": "test/1_unitTests/1_eventstore/handleResponseData.test.ts~describe31.describe34",
    "testDepth": 2,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/handleResponseData.test.ts~describe31.describe34.it35",
    "access": null,
    "description": "throws on invalid command length",
    "lineNumber": 43
  },
  {
    "__docId__": 492,
    "kind": "test",
    "name": "describe36",
    "testId": 36,
    "memberof": "test/1_unitTests/1_eventstore/handleResponseData.test.ts~describe31",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/handleResponseData.test.ts~describe31.describe36",
    "access": null,
    "description": "handleSingleResponseData",
    "lineNumber": 55
  },
  {
    "__docId__": 493,
    "kind": "test",
    "name": "it37",
    "testId": 37,
    "memberof": "test/1_unitTests/1_eventstore/handleResponseData.test.ts~describe31.describe36",
    "testDepth": 2,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/handleResponseData.test.ts~describe31.describe36.it37",
    "access": null,
    "description": "throws on invalid command length",
    "lineNumber": 56
  },
  {
    "__docId__": 494,
    "kind": "testFile",
    "name": "test/1_unitTests/1_eventstore/position.test.ts",
    "content": "import {Position} from '../../../src/eventstore'\nimport * as assert from 'assert'\nimport Long = require('long')\n\ndescribe('Test position class', (): void => {\n  it('creates a new instance from numbers', (): void => {\n    const newPosition = new Position(0, 0)\n    assert.strictEqual(newPosition.commitPosition.compare(0), 0)\n    assert.strictEqual(newPosition.preparePosition.compare(0), 0)\n  })\n\n  it('creates a new instance from Long', (): void => {\n    const newPosition = new Position(Long.fromValue(0), Long.fromValue(0))\n    assert.strictEqual(newPosition.commitPosition.compare(0), 0)\n    assert.strictEqual(newPosition.preparePosition.compare(0), 0)\n  })\n})\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/test/1_unitTests/1_eventstore/position.test.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 495,
    "kind": "test",
    "name": "describe38",
    "testId": 38,
    "memberof": "test/1_unitTests/1_eventstore/position.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/position.test.ts~describe38",
    "access": null,
    "description": "Test position class",
    "lineNumber": 5
  },
  {
    "__docId__": 496,
    "kind": "test",
    "name": "it39",
    "testId": 39,
    "memberof": "test/1_unitTests/1_eventstore/position.test.ts~describe38",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/position.test.ts~describe38.it39",
    "access": null,
    "description": "creates a new instance from numbers",
    "lineNumber": 6
  },
  {
    "__docId__": 497,
    "kind": "test",
    "name": "it40",
    "testId": 40,
    "memberof": "test/1_unitTests/1_eventstore/position.test.ts~describe38",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/position.test.ts~describe38.it40",
    "access": null,
    "description": "creates a new instance from Long",
    "lineNumber": 12
  },
  {
    "__docId__": 498,
    "kind": "testFile",
    "name": "test/1_unitTests/1_eventstore/sendCommand.test.ts",
    "content": "import * as assert from 'assert'\nimport {TCPConnection} from '../../../src/eventstore/TCPConnection'\nimport {setConnectionSettings} from '../../../src/eventstore/EventstoreSettings'\nimport uuid = require('uuid/v4')\n\ndescribe('sendCommand', (): void => {\n  class TestClass extends TCPConnection {\n    public constructor() {\n      super(\n        setConnectionSettings({\n          port: 0,\n          host: '',\n          operationTimeout: 100,\n          operationTimeoutCheckPeriod: 100,\n          connectTimeout: 1,\n          maxQueueSize: 2\n        })\n      )\n      this.state = 2\n    }\n\n    public addRequest(uuid: string, resolve: Function, reject: Function, sendTime: number): void {\n      this.pendingRequests.set(uuid, {resolve, reject, sendTime})\n    }\n  }\n\n  it('throws on maximum ', async (): Promise<void> => {\n    const testClass = new TestClass()\n    new Promise(\n      (resolve, reject): void => {\n        testClass.addRequest(uuid(), resolve, reject, Date.now())\n      }\n    )\n    new Promise(\n      (resolve, reject): void => {\n        testClass.addRequest(uuid(), resolve, reject, Date.now())\n      }\n    )\n    try {\n      await new Promise(\n        (resolve, reject): void => {\n          testClass.sendCommand(uuid(), 0x03, Buffer.from(''), null, {resolve, reject})\n        }\n      )\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreConnectionError')\n    }\n  })\n\n  it('throws on socket error', async (): Promise<void> => {\n    const testClass = new TestClass()\n    try {\n      await new Promise(\n        (resolve, reject): void => {\n          testClass.sendCommand(uuid(), 0x03, Buffer.from(''), null, {resolve, reject})\n        }\n      )\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreConnectionError')\n    }\n  })\n})\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/test/1_unitTests/1_eventstore/sendCommand.test.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 499,
    "kind": "test",
    "name": "describe41",
    "testId": 41,
    "memberof": "test/1_unitTests/1_eventstore/sendCommand.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/sendCommand.test.ts~describe41",
    "access": null,
    "description": "sendCommand",
    "lineNumber": 6
  },
  {
    "__docId__": 500,
    "kind": "test",
    "name": "it42",
    "testId": 42,
    "memberof": "test/1_unitTests/1_eventstore/sendCommand.test.ts~describe41",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/sendCommand.test.ts~describe41.it42",
    "access": null,
    "description": "throws on maximum ",
    "lineNumber": 27
  },
  {
    "__docId__": 501,
    "kind": "test",
    "name": "it43",
    "testId": 43,
    "memberof": "test/1_unitTests/1_eventstore/sendCommand.test.ts~describe41",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/sendCommand.test.ts~describe41.it43",
    "access": null,
    "description": "throws on socket error",
    "lineNumber": 51
  },
  {
    "__docId__": 502,
    "kind": "testFile",
    "name": "test/1_unitTests/1_eventstore/tryToConnect.test.ts",
    "content": "import * as assert from 'assert'\nimport {TCPConnection} from '../../../src/eventstore/TCPConnection'\nimport {setConnectionSettings} from '../../../src/eventstore/EventstoreSettings'\n\ndescribe('tryToConnect', (): void => {\n  class TestClass extends TCPConnection {\n    public constructor() {\n      super(\n        setConnectionSettings({\n          port: 0,\n          host: '',\n          operationTimeout: 100,\n          operationTimeoutCheckPeriod: 100,\n          connectTimeout: 1\n        })\n      )\n    }\n\n    public async tryToConnect(): Promise<void> {\n      await super.tryToConnect()\n    }\n  }\n\n  it('throws on empty port or host', async (): Promise<void> => {\n    const testClass = new TestClass()\n    try {\n      await testClass.tryToConnect()\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreConnectionError')\n    }\n    await testClass.disconnect()\n  })\n})\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/test/1_unitTests/1_eventstore/tryToConnect.test.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 503,
    "kind": "test",
    "name": "describe44",
    "testId": 44,
    "memberof": "test/1_unitTests/1_eventstore/tryToConnect.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/tryToConnect.test.ts~describe44",
    "access": null,
    "description": "tryToConnect",
    "lineNumber": 5
  },
  {
    "__docId__": 504,
    "kind": "test",
    "name": "it45",
    "testId": 45,
    "memberof": "test/1_unitTests/1_eventstore/tryToConnect.test.ts~describe44",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/1_eventstore/tryToConnect.test.ts~describe44.it45",
    "access": null,
    "description": "throws on empty port or host",
    "lineNumber": 24
  },
  {
    "__docId__": 505,
    "kind": "testFile",
    "name": "test/1_unitTests/3_event/eventBase.test.ts",
    "content": "import {expect} from 'chai'\nimport {Event} from '../../../src'\nimport * as assert from 'assert'\nimport uuid = require('uuid/v4')\n\ninterface TestEventDataSchema {\n  someString: string\n  someNumber: number\n  someBoolean: boolean\n  someObject: {\n    moreText: string\n    otherNumber: number\n    otherBoolean: boolean\n  }\n}\n\ndescribe('Event class base tests', (): void => {\n  const testData: TestEventDataSchema = {\n    someString: 'some text',\n    someNumber: 100,\n    someBoolean: true,\n    someObject: {\n      moreText: 'something more',\n      otherNumber: 200,\n      otherBoolean: false\n    }\n  }\n\n  const testMetadata = {\n    $correlationId: uuid()\n  }\n\n  it('creates a event instance', (): void => {\n    const newEvent = new Event('EventWasHappened')\n    assert.strictEqual(JSON.stringify(newEvent.data), JSON.stringify({}))\n    expect(newEvent.data).to.be.exist\n    expect(newEvent.metadata).to.be.null\n    expect(newEvent.id).to.be.exist\n  })\n\n  it('creates a event instance with eventData', (): void => {\n    const newEvent = new Event('EventWasHappened', testData)\n    expect(newEvent.data).to.be.exist\n    assert.strictEqual(newEvent.data, testData)\n    expect(newEvent.metadata).to.be.null\n    expect(newEvent.id).to.be.exist\n  })\n\n  it('creates a event instance with eventData and metadata', (): void => {\n    const newEvent = new Event('EventWasHappened', testData, testMetadata)\n    expect(newEvent.data).to.be.exist\n    assert.strictEqual(newEvent.data, testData)\n    expect(newEvent.metadata).to.be.exist\n    assert.strictEqual(newEvent.metadata, testMetadata)\n    expect(newEvent.id).to.be.exist\n    assert.strictEqual(newEvent.correlationId, testMetadata.$correlationId)\n  })\n})\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/test/1_unitTests/3_event/eventBase.test.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 506,
    "kind": "test",
    "name": "describe46",
    "testId": 46,
    "memberof": "test/1_unitTests/3_event/eventBase.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/1_unitTests/3_event/eventBase.test.ts~describe46",
    "access": null,
    "description": "Event class base tests",
    "lineNumber": 17
  },
  {
    "__docId__": 507,
    "kind": "test",
    "name": "it47",
    "testId": 47,
    "memberof": "test/1_unitTests/3_event/eventBase.test.ts~describe46",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/3_event/eventBase.test.ts~describe46.it47",
    "access": null,
    "description": "creates a event instance",
    "lineNumber": 33
  },
  {
    "__docId__": 508,
    "kind": "test",
    "name": "it48",
    "testId": 48,
    "memberof": "test/1_unitTests/3_event/eventBase.test.ts~describe46",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/3_event/eventBase.test.ts~describe46.it48",
    "access": null,
    "description": "creates a event instance with eventData",
    "lineNumber": 41
  },
  {
    "__docId__": 509,
    "kind": "test",
    "name": "it49",
    "testId": 49,
    "memberof": "test/1_unitTests/3_event/eventBase.test.ts~describe46",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/3_event/eventBase.test.ts~describe46.it49",
    "access": null,
    "description": "creates a event instance with eventData and metadata",
    "lineNumber": 49
  },
  {
    "__docId__": 510,
    "kind": "testFile",
    "name": "test/1_unitTests/3_event/existingEvent.test.ts",
    "content": "import {Event} from '../../../src'\nimport * as assert from 'assert'\nimport uuid = require('uuid/v4')\nimport {uuidToBuffer} from '../../../src/protobuf/uuidBufferConvert'\n\ninterface TestEventDataSchema {\n  someString: string\n  someNumber: number\n  someBoolean: boolean\n  someObject: {\n    moreText: string\n    otherNumber: number\n    otherBoolean: boolean\n  }\n}\n\ndescribe('Existing event instance tests', (): void => {\n  const testData: TestEventDataSchema = {\n    someString: 'some text',\n    someNumber: 100,\n    someBoolean: true,\n    someObject: {\n      moreText: 'something more',\n      otherNumber: 200,\n      otherBoolean: false\n    }\n  }\n\n  const testMetadata = {\n    $correlationId: uuid()\n  }\n\n  it('returns false on existing event', (): void => {\n    const existingEvent = new Event('EventWasHappened', {...testData}, {...testMetadata})\n    existingEvent.freeze()\n    assert.strictEqual(existingEvent.isNew(), false)\n  })\n\n  it('throws on changing name', (): void => {\n    const existingEvent = new Event('EventWasHappened', {...testData}, {...testMetadata})\n    existingEvent.freeze()\n    const newName = 'EventRenamed'\n    try {\n      existingEvent.name = newName\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreOperationError')\n    }\n  })\n\n  it('throws on changing eventId', (): void => {\n    const existingEvent = new Event('EventWasHappened', {...testData}, {...testMetadata})\n    existingEvent.freeze()\n    const newId = uuid()\n    try {\n      existingEvent.id = newId\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreOperationError')\n    }\n  })\n\n  it('throws on changing eventData', (): void => {\n    const existingEvent = new Event('EventWasHappened', {...testData}, {...testMetadata})\n    existingEvent.freeze()\n    const newData = {...testData, ...{someString: 'I was changed'}}\n    try {\n      existingEvent.data = newData\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreOperationError')\n    }\n  })\n\n  it('throws on changing eventMetadata', (): void => {\n    const existingEvent = new Event('EventWasHappened', {...testData}, {...testMetadata})\n    existingEvent.freeze()\n    const newMetadata = {somethingNew: uuid()}\n    try {\n      existingEvent.metadata = newMetadata\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreOperationError')\n    }\n  })\n\n  it('throws on changing eventCorrelationId', (): void => {\n    const existingEvent = new Event('EventWasHappened', {...testData}, {...testMetadata})\n    existingEvent.freeze()\n    const newCorrelationId = uuid()\n    try {\n      existingEvent.correlationId = newCorrelationId\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreOperationError')\n    }\n  })\n})\n\ndescribe('event from raw', (): void => {\n  const rawEventId = uuid()\n  const rawEventStreamId = 'stream-' + uuid()\n  const rawCorrelationId = uuid()\n  const rawEventData = {\n    someField: 'someValue',\n    someNumber: 100\n  }\n  const rawEventMetadata = {\n    $correlationId: rawCorrelationId\n  }\n\n  const rawEventWithMeta = {\n    eventType: 'SomethingWasHappened',\n    eventStreamId: rawEventStreamId,\n    eventNumber: 1,\n    eventId: uuidToBuffer(rawEventId),\n    dataContentType: 1,\n    metadataContentType: 1,\n    data: Buffer.from(JSON.stringify(rawEventData)),\n    metadata: Buffer.from(JSON.stringify(rawEventMetadata)),\n    created: Date.now(),\n    createdEpoch: Date.now()\n  }\n\n  const rawEventWithoutMeta = {\n    eventType: 'SomethingWasHappened',\n    eventStreamId: rawEventStreamId,\n    eventNumber: 1,\n    eventId: uuidToBuffer(rawEventId),\n    dataContentType: 1,\n    metadataContentType: 1,\n    data: Buffer.from(JSON.stringify(rawEventData)),\n    metadata: null,\n    created: null,\n    createdEpoch: null\n  }\n\n  it('returns event instance with full metadata', (): void => {\n    const newEvent = Event.fromRaw(rawEventWithMeta)\n    assert.strictEqual(newEvent.name, 'SomethingWasHappened')\n    assert.strictEqual(newEvent.streamId, rawEventStreamId)\n    assert.strictEqual(newEvent.data.toString(), rawEventData.toString())\n    assert.strictEqual(newEvent.metadata.toString(), rawEventMetadata.toString())\n    assert.strictEqual(newEvent.correlationId, rawEventMetadata.$correlationId)\n  })\n\n  it('returns event instance without metadata', (): void => {\n    const newEvent = Event.fromRaw(rawEventWithoutMeta)\n    assert.strictEqual(newEvent.name, 'SomethingWasHappened')\n    assert.strictEqual(newEvent.streamId, rawEventStreamId)\n    assert.strictEqual(newEvent.data.toString(), rawEventData.toString())\n    assert.strictEqual(newEvent.metadata, null)\n    assert.strictEqual(newEvent.correlationId, null)\n  })\n\n  it('returns event instance without created information', (): void => {\n    const raw = {...rawEventWithMeta}\n    delete raw.created\n    delete raw.createdEpoch\n    const newEvent = Event.fromRaw(rawEventWithMeta)\n    assert.strictEqual(newEvent.name, 'SomethingWasHappened')\n    assert.strictEqual(newEvent.streamId, rawEventStreamId)\n    assert.strictEqual(newEvent.data.toString(), rawEventData.toString())\n    assert.strictEqual(newEvent.metadata.toString(), rawEventMetadata.toString())\n    assert.strictEqual(newEvent.correlationId, rawEventMetadata.$correlationId)\n  })\n\n  it('sets metadata on setting correlationId', (): void => {\n    const newEvent = new Event('SomethingWasHappened')\n    newEvent.correlationId = rawEventMetadata.$correlationId\n    const expected = {\n      $correlationId: rawEventMetadata.$correlationId\n    }\n    assert.strictEqual(newEvent.metadata.toString(), expected.toString())\n  })\n\n  it('deletes correlationId also from metadata', (): void => {\n    const newEvent = new Event(\n      'SomethingWasHappened',\n      {},\n      {$correlationId: rawEventMetadata.$correlationId}\n    )\n    newEvent.correlationId = null\n    const expected = {}\n    assert.strictEqual(newEvent.metadata.toString(), expected.toString())\n  })\n\n  it('deletes correlationId', (): void => {\n    const newEvent = new Event('SomethingWasHappened', {}, {})\n    newEvent.correlationId = null\n    const expected = {}\n    assert.strictEqual(newEvent.metadata.toString(), expected.toString())\n  })\n\n  it('returns null for correlationId if not set', (): void => {\n    const newEvent = new Event('SomethingWasHappened', {}, {})\n    newEvent.correlationId = null\n    assert.strictEqual(newEvent.correlationId, null)\n  })\n\n  it('throw on missing raw event or link', (): void => {\n    try {\n      Event.fromRaw(null)\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreProtocolError')\n    }\n  })\n})\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/test/1_unitTests/3_event/existingEvent.test.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 511,
    "kind": "test",
    "name": "describe50",
    "testId": 50,
    "memberof": "test/1_unitTests/3_event/existingEvent.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/1_unitTests/3_event/existingEvent.test.ts~describe50",
    "access": null,
    "description": "Existing event instance tests",
    "lineNumber": 17
  },
  {
    "__docId__": 512,
    "kind": "test",
    "name": "it51",
    "testId": 51,
    "memberof": "test/1_unitTests/3_event/existingEvent.test.ts~describe50",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/3_event/existingEvent.test.ts~describe50.it51",
    "access": null,
    "description": "returns false on existing event",
    "lineNumber": 33
  },
  {
    "__docId__": 513,
    "kind": "test",
    "name": "it52",
    "testId": 52,
    "memberof": "test/1_unitTests/3_event/existingEvent.test.ts~describe50",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/3_event/existingEvent.test.ts~describe50.it52",
    "access": null,
    "description": "throws on changing name",
    "lineNumber": 39
  },
  {
    "__docId__": 514,
    "kind": "test",
    "name": "it53",
    "testId": 53,
    "memberof": "test/1_unitTests/3_event/existingEvent.test.ts~describe50",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/3_event/existingEvent.test.ts~describe50.it53",
    "access": null,
    "description": "throws on changing eventId",
    "lineNumber": 51
  },
  {
    "__docId__": 515,
    "kind": "test",
    "name": "it54",
    "testId": 54,
    "memberof": "test/1_unitTests/3_event/existingEvent.test.ts~describe50",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/3_event/existingEvent.test.ts~describe50.it54",
    "access": null,
    "description": "throws on changing eventData",
    "lineNumber": 63
  },
  {
    "__docId__": 516,
    "kind": "test",
    "name": "it55",
    "testId": 55,
    "memberof": "test/1_unitTests/3_event/existingEvent.test.ts~describe50",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/3_event/existingEvent.test.ts~describe50.it55",
    "access": null,
    "description": "throws on changing eventMetadata",
    "lineNumber": 75
  },
  {
    "__docId__": 517,
    "kind": "test",
    "name": "it56",
    "testId": 56,
    "memberof": "test/1_unitTests/3_event/existingEvent.test.ts~describe50",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/3_event/existingEvent.test.ts~describe50.it56",
    "access": null,
    "description": "throws on changing eventCorrelationId",
    "lineNumber": 87
  },
  {
    "__docId__": 518,
    "kind": "test",
    "name": "describe57",
    "testId": 57,
    "memberof": "test/1_unitTests/3_event/existingEvent.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/1_unitTests/3_event/existingEvent.test.ts~describe57",
    "access": null,
    "description": "event from raw",
    "lineNumber": 100
  },
  {
    "__docId__": 519,
    "kind": "test",
    "name": "it58",
    "testId": 58,
    "memberof": "test/1_unitTests/3_event/existingEvent.test.ts~describe57",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/3_event/existingEvent.test.ts~describe57.it58",
    "access": null,
    "description": "returns event instance with full metadata",
    "lineNumber": 138
  },
  {
    "__docId__": 520,
    "kind": "test",
    "name": "it59",
    "testId": 59,
    "memberof": "test/1_unitTests/3_event/existingEvent.test.ts~describe57",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/3_event/existingEvent.test.ts~describe57.it59",
    "access": null,
    "description": "returns event instance without metadata",
    "lineNumber": 147
  },
  {
    "__docId__": 521,
    "kind": "test",
    "name": "it60",
    "testId": 60,
    "memberof": "test/1_unitTests/3_event/existingEvent.test.ts~describe57",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/3_event/existingEvent.test.ts~describe57.it60",
    "access": null,
    "description": "returns event instance without created information",
    "lineNumber": 156
  },
  {
    "__docId__": 522,
    "kind": "test",
    "name": "it61",
    "testId": 61,
    "memberof": "test/1_unitTests/3_event/existingEvent.test.ts~describe57",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/3_event/existingEvent.test.ts~describe57.it61",
    "access": null,
    "description": "sets metadata on setting correlationId",
    "lineNumber": 168
  },
  {
    "__docId__": 523,
    "kind": "test",
    "name": "it62",
    "testId": 62,
    "memberof": "test/1_unitTests/3_event/existingEvent.test.ts~describe57",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/3_event/existingEvent.test.ts~describe57.it62",
    "access": null,
    "description": "deletes correlationId also from metadata",
    "lineNumber": 177
  },
  {
    "__docId__": 524,
    "kind": "test",
    "name": "it63",
    "testId": 63,
    "memberof": "test/1_unitTests/3_event/existingEvent.test.ts~describe57",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/3_event/existingEvent.test.ts~describe57.it63",
    "access": null,
    "description": "deletes correlationId",
    "lineNumber": 188
  },
  {
    "__docId__": 525,
    "kind": "test",
    "name": "it64",
    "testId": 64,
    "memberof": "test/1_unitTests/3_event/existingEvent.test.ts~describe57",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/3_event/existingEvent.test.ts~describe57.it64",
    "access": null,
    "description": "returns null for correlationId if not set",
    "lineNumber": 195
  },
  {
    "__docId__": 526,
    "kind": "test",
    "name": "it65",
    "testId": 65,
    "memberof": "test/1_unitTests/3_event/existingEvent.test.ts~describe57",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/3_event/existingEvent.test.ts~describe57.it65",
    "access": null,
    "description": "throw on missing raw event or link",
    "lineNumber": 201
  },
  {
    "__docId__": 527,
    "kind": "testFile",
    "name": "test/1_unitTests/3_event/newEvent.test.ts",
    "content": "import {expect} from 'chai'\nimport {Event} from '../../../src'\nimport * as assert from 'assert'\nimport uuid = require('uuid/v4')\n\ninterface TestEventDataSchema {\n  someString: string\n  someNumber: number\n  someBoolean: boolean\n  someObject: {\n    moreText: string\n    otherNumber: number\n    otherBoolean: boolean\n  }\n}\n\ndescribe('New event instance tests', (): void => {\n  const testData: TestEventDataSchema = {\n    someString: 'some text',\n    someNumber: 100,\n    someBoolean: true,\n    someObject: {\n      moreText: 'something more',\n      otherNumber: 200,\n      otherBoolean: false\n    }\n  }\n\n  const testMetadata = {\n    $correlationId: uuid()\n  }\n\n  it('returns true on new event', (): void => {\n    const newEvent = new Event('EventWasHappened', {...testData}, {...testMetadata})\n    assert.strictEqual(newEvent.isNew(), true)\n  })\n\n  it('can change name', (): void => {\n    const newEvent = new Event('EventWasHappened', {...testData}, {...testMetadata})\n    const newName = 'EventRenamed'\n    newEvent.name = newName\n    expect(newEvent.name).not.to.be.equal('EventWasHappened')\n    expect(newEvent.name).to.be.equal(newName)\n  })\n\n  it('can change eventId', (): void => {\n    const newEvent = new Event('EventWasHappened', {...testData}, {...testMetadata})\n    const oldId = newEvent.id\n    const newId = uuid()\n    newEvent.id = newId\n    expect(newEvent.id).not.to.be.equal(oldId)\n    expect(newEvent.id).to.be.equal(newId)\n  })\n\n  it('can change eventData', (): void => {\n    const newEvent = new Event('EventWasHappened', {...testData}, {...testMetadata})\n    const newData = {...testData, ...{someString: 'I was changed'}}\n    newEvent.data = newData\n\n    expect(JSON.stringify(newEvent.data)).not.to.be.equal(JSON.stringify(testData))\n    assert.strictEqual(JSON.stringify(newEvent.data), JSON.stringify(newData))\n  })\n\n  it('converts json string to eventData', (): void => {\n    const newEvent = new Event('EventWasHappened', {...testData}, {...testMetadata})\n    const newData = `{\"someString\":\"I was changed\"}`\n    newEvent.data = newData\n\n    assert.strictEqual(JSON.stringify(newEvent.data), newData)\n  })\n\n  it('can change eventMetadata', (): void => {\n    const newEvent = new Event('EventWasHappened', {...testData}, {...testMetadata})\n    const newMetadata = {somethingNew: uuid()}\n    newEvent.metadata = newMetadata\n\n    expect(JSON.stringify(newEvent.metadata)).not.to.be.equal(JSON.stringify(testMetadata))\n    assert.strictEqual(JSON.stringify(newEvent.metadata), JSON.stringify(newMetadata))\n  })\n\n  it('converts json string to eventMetadata', (): void => {\n    const newEvent = new Event('EventWasHappened', {...testData}, {...testMetadata})\n    const newMetadata = `{\"somethingNew\":\"${uuid()}\"}`\n    newEvent.metadata = newMetadata\n\n    assert.strictEqual(JSON.stringify(newEvent.metadata), newMetadata)\n  })\n\n  it('can change eventCorrelationId', (): void => {\n    const newEvent = new Event('EventWasHappened', {...testData}, {...testMetadata})\n    const newCorrelationId = uuid()\n    newEvent.correlationId = newCorrelationId\n\n    if (typeof newEvent.metadata !== 'string') {\n      expect(newEvent.metadata.$correlationId).not.to.be.equal(testMetadata.$correlationId)\n      expect(newEvent.metadata.$correlationId).to.be.equal(newCorrelationId)\n    } else {\n      assert.fail('metadata is string instead of object')\n    }\n\n    expect(newEvent.correlationId).to.be.equal(newCorrelationId)\n    const n = {...testMetadata, ...{$correlationId: newCorrelationId}}\n    assert.strictEqual(JSON.stringify(newEvent.metadata), JSON.stringify(n))\n  })\n\n  it('returns model.eventstore.proto.NewEvent instance', (): void => {\n    const newEvent = new Event('EventWasHappened', {...testData}, {...testMetadata})\n    const result = newEvent.toRaw()\n    assert.strictEqual(result.constructor.name, 'NewEvent')\n  })\n})\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/test/1_unitTests/3_event/newEvent.test.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 528,
    "kind": "test",
    "name": "describe66",
    "testId": 66,
    "memberof": "test/1_unitTests/3_event/newEvent.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/1_unitTests/3_event/newEvent.test.ts~describe66",
    "access": null,
    "description": "New event instance tests",
    "lineNumber": 17
  },
  {
    "__docId__": 529,
    "kind": "test",
    "name": "it67",
    "testId": 67,
    "memberof": "test/1_unitTests/3_event/newEvent.test.ts~describe66",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/3_event/newEvent.test.ts~describe66.it67",
    "access": null,
    "description": "returns true on new event",
    "lineNumber": 33
  },
  {
    "__docId__": 530,
    "kind": "test",
    "name": "it68",
    "testId": 68,
    "memberof": "test/1_unitTests/3_event/newEvent.test.ts~describe66",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/3_event/newEvent.test.ts~describe66.it68",
    "access": null,
    "description": "can change name",
    "lineNumber": 38
  },
  {
    "__docId__": 531,
    "kind": "test",
    "name": "it69",
    "testId": 69,
    "memberof": "test/1_unitTests/3_event/newEvent.test.ts~describe66",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/3_event/newEvent.test.ts~describe66.it69",
    "access": null,
    "description": "can change eventId",
    "lineNumber": 46
  },
  {
    "__docId__": 532,
    "kind": "test",
    "name": "it70",
    "testId": 70,
    "memberof": "test/1_unitTests/3_event/newEvent.test.ts~describe66",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/3_event/newEvent.test.ts~describe66.it70",
    "access": null,
    "description": "can change eventData",
    "lineNumber": 55
  },
  {
    "__docId__": 533,
    "kind": "test",
    "name": "it71",
    "testId": 71,
    "memberof": "test/1_unitTests/3_event/newEvent.test.ts~describe66",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/3_event/newEvent.test.ts~describe66.it71",
    "access": null,
    "description": "converts json string to eventData",
    "lineNumber": 64
  },
  {
    "__docId__": 534,
    "kind": "test",
    "name": "it72",
    "testId": 72,
    "memberof": "test/1_unitTests/3_event/newEvent.test.ts~describe66",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/3_event/newEvent.test.ts~describe66.it72",
    "access": null,
    "description": "can change eventMetadata",
    "lineNumber": 72
  },
  {
    "__docId__": 535,
    "kind": "test",
    "name": "it73",
    "testId": 73,
    "memberof": "test/1_unitTests/3_event/newEvent.test.ts~describe66",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/3_event/newEvent.test.ts~describe66.it73",
    "access": null,
    "description": "converts json string to eventMetadata",
    "lineNumber": 81
  },
  {
    "__docId__": 536,
    "kind": "test",
    "name": "it74",
    "testId": 74,
    "memberof": "test/1_unitTests/3_event/newEvent.test.ts~describe66",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/3_event/newEvent.test.ts~describe66.it74",
    "access": null,
    "description": "can change eventCorrelationId",
    "lineNumber": 89
  },
  {
    "__docId__": 537,
    "kind": "test",
    "name": "it75",
    "testId": 75,
    "memberof": "test/1_unitTests/3_event/newEvent.test.ts~describe66",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/3_event/newEvent.test.ts~describe66.it75",
    "access": null,
    "description": "returns model.eventstore.proto.NewEvent instance",
    "lineNumber": 106
  },
  {
    "__docId__": 538,
    "kind": "testFile",
    "name": "test/1_unitTests/5_errors/eventstoreError.test.ts",
    "content": "import * as esError from '../../../src/errors'\nimport * as assert from 'assert'\n\ndescribe('Eventstore error class', (): void => {\n  it('creates an error instance', (): void => {\n    const err = new esError.EventstoreError('some error')\n    assert.strictEqual(err.name, 'EventstoreError')\n    assert.strictEqual(err.message, 'some error')\n  })\n\n  it('can have a causing error instance', (): void => {\n    const causedBy = new Error('initial error')\n    const err = new esError.EventstoreError('some error', 'NamedError', causedBy)\n    assert.strictEqual(err.name, 'NamedError')\n    assert.strictEqual(err.message, 'some error')\n    assert.strictEqual(JSON.stringify(err.rootCause), JSON.stringify(causedBy))\n  })\n})\n\ndescribe('Eventstore error types', (): void => {\n  const errorList = Object.keys(esError)\n    .map(\n      (key): string | null => {\n        return key.match(/new(.*Error)/) ? key.slice(3) : null\n      }\n    )\n    .filter((key): boolean => key != null)\n\n  errorList.forEach(\n    (errorName): void => {\n      it(`creates a ${errorName}`, (): void => {\n        const err = esError['new' + errorName]('some error')\n        assert.strictEqual(err.name, `Eventstore${errorName}`)\n      })\n\n      it(`creates a ${errorName} with causing error reference`, (): void => {\n        const causedBy = new Error('initial error')\n        const err = esError['new' + errorName]('some error', causedBy)\n        assert.strictEqual(err.name, `Eventstore${errorName}`)\n      })\n    }\n  )\n\n  const errorsWithDefaultMsg = [\n    'BadRequestError',\n    'NotAuthenticatedError',\n    'UnspecificError',\n    'ImplementationError',\n    'DoesNotExistError',\n    'AlreadyExistError',\n    'TimeoutError',\n    'OperationError'\n  ]\n\n  errorsWithDefaultMsg.forEach(\n    (errorName): void => {\n      it(`creates a ${errorName} without specified message`, (): void => {\n        const err = esError['new' + errorName]()\n        assert.strictEqual(err.name, `Eventstore${errorName}`)\n      })\n    }\n  )\n})\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/test/1_unitTests/5_errors/eventstoreError.test.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 539,
    "kind": "test",
    "name": "describe76",
    "testId": 76,
    "memberof": "test/1_unitTests/5_errors/eventstoreError.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/1_unitTests/5_errors/eventstoreError.test.ts~describe76",
    "access": null,
    "description": "Eventstore error class",
    "lineNumber": 4
  },
  {
    "__docId__": 540,
    "kind": "test",
    "name": "it77",
    "testId": 77,
    "memberof": "test/1_unitTests/5_errors/eventstoreError.test.ts~describe76",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/5_errors/eventstoreError.test.ts~describe76.it77",
    "access": null,
    "description": "creates an error instance",
    "lineNumber": 5
  },
  {
    "__docId__": 541,
    "kind": "test",
    "name": "it78",
    "testId": 78,
    "memberof": "test/1_unitTests/5_errors/eventstoreError.test.ts~describe76",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/5_errors/eventstoreError.test.ts~describe76.it78",
    "access": null,
    "description": "can have a causing error instance",
    "lineNumber": 11
  },
  {
    "__docId__": 542,
    "kind": "test",
    "name": "describe79",
    "testId": 79,
    "memberof": "test/1_unitTests/5_errors/eventstoreError.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/1_unitTests/5_errors/eventstoreError.test.ts~describe79",
    "access": null,
    "description": "Eventstore error types",
    "lineNumber": 20
  },
  {
    "__docId__": 543,
    "kind": "test",
    "name": "it80",
    "testId": 80,
    "memberof": "test/1_unitTests/5_errors/eventstoreError.test.ts~describe79",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/5_errors/eventstoreError.test.ts~describe79.it80",
    "access": null,
    "lineNumber": 31
  },
  {
    "__docId__": 544,
    "kind": "test",
    "name": "it81",
    "testId": 81,
    "memberof": "test/1_unitTests/5_errors/eventstoreError.test.ts~describe79",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/5_errors/eventstoreError.test.ts~describe79.it81",
    "access": null,
    "lineNumber": 36
  },
  {
    "__docId__": 545,
    "kind": "test",
    "name": "it82",
    "testId": 82,
    "memberof": "test/1_unitTests/5_errors/eventstoreError.test.ts~describe79",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/5_errors/eventstoreError.test.ts~describe79.it82",
    "access": null,
    "lineNumber": 57
  },
  {
    "__docId__": 546,
    "kind": "testFile",
    "name": "test/1_unitTests/6_misc/streamWalker.test.ts",
    "content": "/* eslint-disable @typescript-eslint/explicit-function-return-type */\nimport {Event} from '../../../src'\nimport {StreamWalker} from '../../../src/StreamWalker'\nimport * as assert from 'assert'\n\ndescribe('Async iterator test', (): void => {\n  const testData: Event[] = []\n\n  before(() => {\n    let count = 0\n    const eventNameList = [\n      'EventA',\n      'EventB',\n      'EventC',\n      'EventD',\n      'EventE',\n      'EventF',\n      'EventG',\n      'EventH',\n      'EventI',\n      'EventJ'\n    ]\n    for (let x = 0, xMax = 1000; x < xMax; x++) {\n      eventNameList.forEach((name) => {\n        testData.push(new Event(name, {count}))\n        count++\n      })\n    }\n  })\n\n  let generator = async function*() {\n    for (let x = 0, xMax = testData.length; x < xMax; x++) {\n      yield testData[x]\n    }\n  }\n\n  beforeEach(async () => {\n    generator = async function*() {\n      for (let x = 0, xMax = testData.length; x < xMax; x++) {\n        yield testData[x]\n      }\n    }\n  })\n\n  it('can iterate through', async (): Promise<void> => {\n    const walker = new StreamWalker(generator())\n\n    let checkCounter = 0\n    for await (const value of walker) {\n      assert.strictEqual(value.name, testData[checkCounter].name)\n      checkCounter++\n    }\n    assert.strictEqual(checkCounter, testData.length)\n  })\n\n  it('can filter events', async (): Promise<void> => {\n    const walker = new StreamWalker(generator())\n\n    let checkCounter = 0\n    for await (const value of walker.filter((event) => event.name != 'EventB')) {\n      assert.notEqual(value.name, 'EventB')\n      checkCounter++\n    }\n    assert.strictEqual(checkCounter, testData.length - 1000)\n  })\n\n  it('can reduce events to single value', async (): Promise<void> => {\n    const walker = new StreamWalker(generator())\n    const result = await walker.reduce((accumulator: number) => {\n      accumulator++\n      return accumulator\n    }, 0)\n    assert.strictEqual(result, testData.length)\n  })\n\n  it('can transform to array', async (): Promise<void> => {\n    const walker = new StreamWalker(generator())\n    const result = await walker.toArray()\n    assert.strictEqual(JSON.stringify(result), JSON.stringify(testData))\n  })\n\n  it('can test all entries and return global result true', async (): Promise<void> => {\n    const walker = new StreamWalker(generator())\n    const result = await walker.every((event) => event.name.startsWith('Event'))\n    assert.strictEqual(result, true)\n  })\n\n  it('can test all entries and return global result true', async (): Promise<void> => {\n    const walker = new StreamWalker(generator())\n    const result = await walker.every((event) => event.name.startsWith('EventA'))\n    assert.strictEqual(result, false)\n  })\n\n  it('can combine filter and forEach', async (): Promise<void> => {\n    const walker = new StreamWalker(generator())\n\n    let checkCounter = 0\n    await walker\n      .filter((event) => event.name != 'EventB')\n      .forEach((event) => {\n        assert.notEqual(event.name, 'EventB')\n        checkCounter++\n      })\n\n    assert.strictEqual(checkCounter, testData.length - 1000)\n  })\n\n  it('can combine filter, map and to array', async (): Promise<void> => {\n    const walker = new StreamWalker(generator())\n\n    const result = await walker\n      .filter((event) => event.name != 'EventB')\n      .map((event) => {\n        event.name = 'NewName'\n        return event\n      })\n      .toArray()\n    assert.strictEqual(result.length, testData.length - 1000)\n    assert.strictEqual(\n      result.every((event: Event) => {\n        return event.name === 'NewName'\n      }),\n      true\n    )\n  })\n\n  it('throws on none function at filter', async () => {\n    const walker = new StreamWalker(generator())\n\n    try {\n      await walker.filter(null)\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreImplementationError')\n    }\n  })\n\n  it('throws on none function at map', async () => {\n    const walker = new StreamWalker(generator())\n\n    try {\n      await walker.map(null)\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreImplementationError')\n    }\n  })\n\n  it('throws on none function at forEach', async () => {\n    const walker = new StreamWalker(generator())\n\n    try {\n      await walker.forEach(null)\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreImplementationError')\n    }\n  })\n\n  it('throws on none function at reduce', async () => {\n    const walker = new StreamWalker(generator())\n\n    try {\n      await walker.reduce(null)\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreImplementationError')\n    }\n  })\n\n  it('throws on none function at every', async () => {\n    const walker = new StreamWalker(generator())\n\n    try {\n      await walker.every(null)\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreImplementationError')\n    }\n  })\n})\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/test/1_unitTests/6_misc/streamWalker.test.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 547,
    "kind": "test",
    "name": "describe83",
    "testId": 83,
    "memberof": "test/1_unitTests/6_misc/streamWalker.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/1_unitTests/6_misc/streamWalker.test.ts~describe83",
    "access": null,
    "description": "Async iterator test",
    "lineNumber": 6
  },
  {
    "__docId__": 548,
    "kind": "test",
    "name": "it84",
    "testId": 84,
    "memberof": "test/1_unitTests/6_misc/streamWalker.test.ts~describe83",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/6_misc/streamWalker.test.ts~describe83.it84",
    "access": null,
    "description": "can iterate through",
    "lineNumber": 45
  },
  {
    "__docId__": 549,
    "kind": "test",
    "name": "it85",
    "testId": 85,
    "memberof": "test/1_unitTests/6_misc/streamWalker.test.ts~describe83",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/6_misc/streamWalker.test.ts~describe83.it85",
    "access": null,
    "description": "can filter events",
    "lineNumber": 56
  },
  {
    "__docId__": 550,
    "kind": "test",
    "name": "it86",
    "testId": 86,
    "memberof": "test/1_unitTests/6_misc/streamWalker.test.ts~describe83",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/6_misc/streamWalker.test.ts~describe83.it86",
    "access": null,
    "description": "can reduce events to single value",
    "lineNumber": 67
  },
  {
    "__docId__": 551,
    "kind": "test",
    "name": "it87",
    "testId": 87,
    "memberof": "test/1_unitTests/6_misc/streamWalker.test.ts~describe83",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/6_misc/streamWalker.test.ts~describe83.it87",
    "access": null,
    "description": "can transform to array",
    "lineNumber": 76
  },
  {
    "__docId__": 552,
    "kind": "test",
    "name": "it88",
    "testId": 88,
    "memberof": "test/1_unitTests/6_misc/streamWalker.test.ts~describe83",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/6_misc/streamWalker.test.ts~describe83.it88",
    "access": null,
    "description": "can test all entries and return global result true",
    "lineNumber": 82
  },
  {
    "__docId__": 553,
    "kind": "test",
    "name": "it89",
    "testId": 89,
    "memberof": "test/1_unitTests/6_misc/streamWalker.test.ts~describe83",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/6_misc/streamWalker.test.ts~describe83.it89",
    "access": null,
    "description": "can test all entries and return global result true",
    "lineNumber": 88
  },
  {
    "__docId__": 554,
    "kind": "test",
    "name": "it90",
    "testId": 90,
    "memberof": "test/1_unitTests/6_misc/streamWalker.test.ts~describe83",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/6_misc/streamWalker.test.ts~describe83.it90",
    "access": null,
    "description": "can combine filter and forEach",
    "lineNumber": 94
  },
  {
    "__docId__": 555,
    "kind": "test",
    "name": "it91",
    "testId": 91,
    "memberof": "test/1_unitTests/6_misc/streamWalker.test.ts~describe83",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/6_misc/streamWalker.test.ts~describe83.it91",
    "access": null,
    "description": "can combine filter, map and to array",
    "lineNumber": 108
  },
  {
    "__docId__": 556,
    "kind": "test",
    "name": "it92",
    "testId": 92,
    "memberof": "test/1_unitTests/6_misc/streamWalker.test.ts~describe83",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/6_misc/streamWalker.test.ts~describe83.it92",
    "access": null,
    "description": "throws on none function at filter",
    "lineNumber": 127
  },
  {
    "__docId__": 557,
    "kind": "test",
    "name": "it93",
    "testId": 93,
    "memberof": "test/1_unitTests/6_misc/streamWalker.test.ts~describe83",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/6_misc/streamWalker.test.ts~describe83.it93",
    "access": null,
    "description": "throws on none function at map",
    "lineNumber": 138
  },
  {
    "__docId__": 558,
    "kind": "test",
    "name": "it94",
    "testId": 94,
    "memberof": "test/1_unitTests/6_misc/streamWalker.test.ts~describe83",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/6_misc/streamWalker.test.ts~describe83.it94",
    "access": null,
    "description": "throws on none function at forEach",
    "lineNumber": 149
  },
  {
    "__docId__": 559,
    "kind": "test",
    "name": "it95",
    "testId": 95,
    "memberof": "test/1_unitTests/6_misc/streamWalker.test.ts~describe83",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/6_misc/streamWalker.test.ts~describe83.it95",
    "access": null,
    "description": "throws on none function at reduce",
    "lineNumber": 160
  },
  {
    "__docId__": 560,
    "kind": "test",
    "name": "it96",
    "testId": 96,
    "memberof": "test/1_unitTests/6_misc/streamWalker.test.ts~describe83",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/6_misc/streamWalker.test.ts~describe83.it96",
    "access": null,
    "description": "throws on none function at every",
    "lineNumber": 171
  },
  {
    "__docId__": 561,
    "kind": "testFile",
    "name": "test/1_unitTests/6_misc/uuidBufferConvert.test.ts",
    "content": "import {uuidToBuffer, uuidFromBuffer} from '../../../src'\nimport * as assert from 'assert'\nimport uuid = require('uuid/v4')\n\ndescribe('uuid to buffer', (): void => {\n  const testId = uuid()\n\n  it('converts a uuid to formated buffer', (): void => {\n    const result = uuidToBuffer(testId)\n    assert.strictEqual(result.toString(), Buffer.from(testId.replace(/-/g, ''), 'hex').toString())\n  })\n\n  it('returns a buffer for id=null', (): void => {\n    const result = uuidToBuffer(null)\n    assert.strictEqual(result.toString(), Buffer.alloc(16).toString())\n  })\n\n  it('throws on uuid size', (): void => {\n    try {\n      const result = uuidToBuffer('00000000-0000-0000-0000-00000000000')\n      assert.fail(result.toString())\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreProtocolError')\n    }\n  })\n\n  it('throws on invalid uuid format', (): void => {\n    try {\n      const result = uuidToBuffer('000000000000000000000000000000000000')\n      assert.fail(result.toString())\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreProtocolError')\n    }\n  })\n})\n\ndescribe('buffer to uuid', (): void => {\n  const testId = uuid()\n  const testBuffer = Buffer.from(testId.replace(/-/g, ''), 'hex')\n\n  it('converts buffer to uuid', (): void => {\n    const result = uuidFromBuffer(testBuffer)\n    assert.strictEqual(result, testId)\n  })\n\n  it('converts buffer to uuid', (): void => {\n    const result = uuidFromBuffer(Buffer.alloc(16))\n    assert.strictEqual(result, '')\n  })\n\n  it('throws on invalid buffer size', (): void => {\n    const invalidBuffer = Buffer.alloc(17, 'hex')\n    try {\n      const result = uuidFromBuffer(invalidBuffer)\n      assert.fail(result)\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreProtocolError')\n    }\n  })\n})\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/test/1_unitTests/6_misc/uuidBufferConvert.test.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 562,
    "kind": "test",
    "name": "describe97",
    "testId": 97,
    "memberof": "test/1_unitTests/6_misc/uuidBufferConvert.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/1_unitTests/6_misc/uuidBufferConvert.test.ts~describe97",
    "access": null,
    "description": "uuid to buffer",
    "lineNumber": 5
  },
  {
    "__docId__": 563,
    "kind": "test",
    "name": "it98",
    "testId": 98,
    "memberof": "test/1_unitTests/6_misc/uuidBufferConvert.test.ts~describe97",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/6_misc/uuidBufferConvert.test.ts~describe97.it98",
    "access": null,
    "description": "converts a uuid to formated buffer",
    "lineNumber": 8
  },
  {
    "__docId__": 564,
    "kind": "test",
    "name": "it99",
    "testId": 99,
    "memberof": "test/1_unitTests/6_misc/uuidBufferConvert.test.ts~describe97",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/6_misc/uuidBufferConvert.test.ts~describe97.it99",
    "access": null,
    "description": "returns a buffer for id=null",
    "lineNumber": 13
  },
  {
    "__docId__": 565,
    "kind": "test",
    "name": "it100",
    "testId": 100,
    "memberof": "test/1_unitTests/6_misc/uuidBufferConvert.test.ts~describe97",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/6_misc/uuidBufferConvert.test.ts~describe97.it100",
    "access": null,
    "description": "throws on uuid size",
    "lineNumber": 18
  },
  {
    "__docId__": 566,
    "kind": "test",
    "name": "it101",
    "testId": 101,
    "memberof": "test/1_unitTests/6_misc/uuidBufferConvert.test.ts~describe97",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/6_misc/uuidBufferConvert.test.ts~describe97.it101",
    "access": null,
    "description": "throws on invalid uuid format",
    "lineNumber": 27
  },
  {
    "__docId__": 567,
    "kind": "test",
    "name": "describe102",
    "testId": 102,
    "memberof": "test/1_unitTests/6_misc/uuidBufferConvert.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/1_unitTests/6_misc/uuidBufferConvert.test.ts~describe102",
    "access": null,
    "description": "buffer to uuid",
    "lineNumber": 37
  },
  {
    "__docId__": 568,
    "kind": "test",
    "name": "it103",
    "testId": 103,
    "memberof": "test/1_unitTests/6_misc/uuidBufferConvert.test.ts~describe102",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/6_misc/uuidBufferConvert.test.ts~describe102.it103",
    "access": null,
    "description": "converts buffer to uuid",
    "lineNumber": 41
  },
  {
    "__docId__": 569,
    "kind": "test",
    "name": "it104",
    "testId": 104,
    "memberof": "test/1_unitTests/6_misc/uuidBufferConvert.test.ts~describe102",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/6_misc/uuidBufferConvert.test.ts~describe102.it104",
    "access": null,
    "description": "converts buffer to uuid",
    "lineNumber": 46
  },
  {
    "__docId__": 570,
    "kind": "test",
    "name": "it105",
    "testId": 105,
    "memberof": "test/1_unitTests/6_misc/uuidBufferConvert.test.ts~describe102",
    "testDepth": 1,
    "static": true,
    "longname": "test/1_unitTests/6_misc/uuidBufferConvert.test.ts~describe102.it105",
    "access": null,
    "description": "throws on invalid buffer size",
    "lineNumber": 51
  },
  {
    "__docId__": 571,
    "kind": "testFile",
    "name": "test/2_integrationTests/1_eventstore/1_connection.test.ts",
    "content": "import {expect} from 'chai'\nimport {Eventstore} from '../../../src'\nimport * as assert from 'assert'\nimport * as bunyan from 'bunyan'\nimport * as fs from 'fs'\nimport {setConnectionSettings} from '../../../src/eventstore/EventstoreSettings'\n\ndescribe('Connection test', (): void => {\n  it('creates an instance without config', async (): Promise<void> => {\n    const es = new Eventstore()\n    expect(es.isConnected).not.to.true\n  })\n\n  it('creates an instance with eventstore settings object', async (): Promise<void> => {\n    const es = new Eventstore(setConnectionSettings({}))\n    expect(es.isConnected).not.to.true\n  })\n\n  it('returns false if not connected', async (): Promise<void> => {\n    const es = new Eventstore({\n      uri: 'tcp://restrictedUser:restrictedOnlyUserPassword@cluster1.escluster.net:1113'\n    })\n    expect(es.isConnected).not.to.true\n  })\n\n  it('does nothing if not connected', async (): Promise<void> => {\n    const es = new Eventstore({\n      uri: 'tcp://restrictedUser:restrictedOnlyUserPassword@cluster1.escluster.net:1113'\n    })\n    await es.disconnect()\n    expect(true).to.be.true\n  })\n\n  it('set a logger', (): void => {\n    const es = new Eventstore({\n      uri: 'tcp://restrictedUser:restrictedOnlyUserPassword@cluster1.escluster.net:1113'\n    })\n    es.logger = bunyan.createLogger({name: 'unittest'})\n    expect(true).to.be.true\n  })\n\n  it('can connect to eventstore single node unsecure', async (): Promise<void> => {\n    const es = new Eventstore({\n      uri: 'tcp://restrictedUser:restrictedOnlyUserPassword@cluster1.escluster.net:1113'\n    })\n    try {\n      await es.connect()\n      assert.ok('connected')\n      await es.disconnect()\n      assert.ok('disconnects')\n    } catch (err) {\n      assert.fail(err)\n    }\n    expect(es.isConnected).not.to.true\n  })\n\n  it('can connect to eventstore single node to default port', async (): Promise<void> => {\n    const es = new Eventstore({\n      uri: 'tcp://restrictedUser:restrictedOnlyUserPassword@cluster1.escluster.net'\n    })\n    try {\n      await es.connect()\n      assert.ok('connected')\n      await es.disconnect()\n      assert.ok('disconnects')\n    } catch (err) {\n      assert.fail(err)\n    }\n    expect(es.isConnected).not.to.true\n  })\n\n  it('can connect to eventstore cluster unsecure', async (): Promise<void> => {\n    const es = new Eventstore({\n      uri: 'discover://restrictedUser:restrictedOnlyUserPassword@cluster1.escluster.net:2112'\n    })\n    try {\n      await es.connect()\n      assert.ok('connected')\n      await es.disconnect()\n      assert.ok('disconnects')\n    } catch (err) {\n      assert.fail(err)\n    }\n    expect(es.isConnected).not.to.true\n  })\n\n  it('can connect to eventstore cluster secure tcp', async (): Promise<void> => {\n    const es = new Eventstore({\n      uri: 'discover://restrictedUser:restrictedOnlyUserPassword@cluster1.escluster.net:2112',\n      useSSL: true\n    })\n    try {\n      await es.connect()\n      assert.ok('connected')\n      await es.disconnect()\n      assert.ok('disconnects')\n    } catch (err) {\n      assert.fail(err)\n    }\n    expect(es.isConnected).not.to.true\n  })\n\n  it('can ssl connect to eventstore with cert & strict validation', async (): Promise<void> => {\n    const es = new Eventstore({\n      uri: 'discover://restrictedUser:restrictedOnlyUserPassword@escluster.net:2112',\n      useSSL: true,\n      validateServer: true,\n      secureContext: {\n        ca: fs.readFileSync('./test/2_integrationTests/testSetup/rootCA.crt'),\n        key: fs.readFileSync('./test/2_integrationTests/testSetup/domain.key'),\n        cert: fs.readFileSync('./test/2_integrationTests/testSetup/domain.crt')\n      }\n    })\n    try {\n      await es.connect()\n      assert.ok('connected')\n      await es.disconnect()\n      assert.ok('disconnects')\n    } catch (err) {\n      assert.fail(err)\n    }\n    expect(es.isConnected).not.to.true\n  })\n\n  it('throws on invalid secure context', async (): Promise<void> => {\n    const es = new Eventstore({\n      uri: 'discover://restrictedUser:restrictedOnlyUserPassword@escluster.net:2112',\n      useSSL: true,\n      validateServer: true,\n      secureContext: {\n        ca: fs.readFileSync('./test/2_integrationTests/testSetup/rootCA.crt'),\n        key: fs.readFileSync('./test/2_integrationTests/testSetup/invalid.key'),\n        cert: fs.readFileSync('./test/2_integrationTests/testSetup/domain.crt')\n      }\n    })\n    try {\n      await es.connect()\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreConnectionError')\n      assert.ok('has thrown')\n    }\n    expect(es.isConnected).not.to.true\n  })\n\n  it('finds cluster node over dns (require master)', async (): Promise<void> => {\n    const es = new Eventstore({\n      uri: '',\n      clusterDns: 'escluster.net',\n      credentials: {\n        username: 'restrictedUser',\n        password: 'restrictedOnlyUserPassword'\n      }\n    })\n    try {\n      await es.connect()\n      assert.ok('connected')\n      await es.disconnect()\n      assert.ok('disconnects')\n    } catch (err) {\n      assert.fail(err)\n    }\n    expect(es.isConnected).not.to.true\n  })\n\n  it('finds cluster node over dns', async (): Promise<void> => {\n    const es = new Eventstore({\n      uri: '',\n      requireMaster: false,\n      clusterDns: 'escluster.net',\n      credentials: {\n        username: 'restrictedUser',\n        password: 'restrictedOnlyUserPassword'\n      }\n    })\n    try {\n      await es.connect()\n      assert.ok('connected')\n      await es.disconnect()\n      assert.ok('disconnects')\n    } catch (err) {\n      assert.fail(err)\n    }\n    expect(es.isConnected).not.to.true\n  })\n\n  it('finds cluster node from seed list', async (): Promise<void> => {\n    const es = new Eventstore({\n      uri: '',\n      gossipSeeds: ['172.22.0.2', '172.22.0.3', '172.22.0.4'],\n      credentials: {\n        username: 'restrictedUser',\n        password: 'restrictedOnlyUserPassword'\n      }\n    })\n    try {\n      await es.connect()\n      assert.ok('connected')\n      await es.disconnect()\n      assert.ok('disconnects')\n    } catch (err) {\n      assert.fail(err)\n    }\n    expect(es.isConnected).not.to.true\n  })\n\n  it('it throws on invalid credentials', async (): Promise<void> => {\n    const es = new Eventstore({\n      uri: 'tcp://invalidUser:wrongpassword@cluster1.escluster.net:1113',\n      clientId: 'ts-client-test'\n    })\n    try {\n      await es.connect()\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreNotAuthenticatedError')\n    }\n    expect(es.isConnected).not.to.true\n  })\n})\n\ndescribe('Basic connection test', (): void => {\n  const es = new Eventstore({\n    uri: 'discover://restrictedUser:restrictedOnlyUserPassword@cluster1.escluster.net:2112',\n    clientId: 'ts-client-test'\n  })\n  before(\n    async (): Promise<void> => {\n      await es.connect()\n    }\n  )\n\n  after(\n    async (): Promise<void> => {\n      await es.disconnect()\n    }\n  )\n\n  it('returns clientId - name of connection', (): void => {\n    expect(es.name).to.be.equal('ts-client-test')\n  })\n\n  it('can ping eventstore', async (): Promise<void> => {\n    try {\n      await es.ping()\n      assert.ok('get pong response from ping request')\n    } catch (err) {\n      assert.fail(err)\n    }\n  })\n})\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/test/2_integrationTests/1_eventstore/1_connection.test.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 572,
    "kind": "test",
    "name": "describe106",
    "testId": 106,
    "memberof": "test/2_integrationTests/1_eventstore/1_connection.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/1_connection.test.ts~describe106",
    "access": null,
    "description": "Connection test",
    "lineNumber": 8
  },
  {
    "__docId__": 573,
    "kind": "test",
    "name": "it107",
    "testId": 107,
    "memberof": "test/2_integrationTests/1_eventstore/1_connection.test.ts~describe106",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/1_connection.test.ts~describe106.it107",
    "access": null,
    "description": "creates an instance without config",
    "lineNumber": 9
  },
  {
    "__docId__": 574,
    "kind": "test",
    "name": "it108",
    "testId": 108,
    "memberof": "test/2_integrationTests/1_eventstore/1_connection.test.ts~describe106",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/1_connection.test.ts~describe106.it108",
    "access": null,
    "description": "creates an instance with eventstore settings object",
    "lineNumber": 14
  },
  {
    "__docId__": 575,
    "kind": "test",
    "name": "it109",
    "testId": 109,
    "memberof": "test/2_integrationTests/1_eventstore/1_connection.test.ts~describe106",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/1_connection.test.ts~describe106.it109",
    "access": null,
    "description": "returns false if not connected",
    "lineNumber": 19
  },
  {
    "__docId__": 576,
    "kind": "test",
    "name": "it110",
    "testId": 110,
    "memberof": "test/2_integrationTests/1_eventstore/1_connection.test.ts~describe106",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/1_connection.test.ts~describe106.it110",
    "access": null,
    "description": "does nothing if not connected",
    "lineNumber": 26
  },
  {
    "__docId__": 577,
    "kind": "test",
    "name": "it111",
    "testId": 111,
    "memberof": "test/2_integrationTests/1_eventstore/1_connection.test.ts~describe106",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/1_connection.test.ts~describe106.it111",
    "access": null,
    "description": "set a logger",
    "lineNumber": 34
  },
  {
    "__docId__": 578,
    "kind": "test",
    "name": "it112",
    "testId": 112,
    "memberof": "test/2_integrationTests/1_eventstore/1_connection.test.ts~describe106",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/1_connection.test.ts~describe106.it112",
    "access": null,
    "description": "can connect to eventstore single node unsecure",
    "lineNumber": 42
  },
  {
    "__docId__": 579,
    "kind": "test",
    "name": "it113",
    "testId": 113,
    "memberof": "test/2_integrationTests/1_eventstore/1_connection.test.ts~describe106",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/1_connection.test.ts~describe106.it113",
    "access": null,
    "description": "can connect to eventstore single node to default port",
    "lineNumber": 57
  },
  {
    "__docId__": 580,
    "kind": "test",
    "name": "it114",
    "testId": 114,
    "memberof": "test/2_integrationTests/1_eventstore/1_connection.test.ts~describe106",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/1_connection.test.ts~describe106.it114",
    "access": null,
    "description": "can connect to eventstore cluster unsecure",
    "lineNumber": 72
  },
  {
    "__docId__": 581,
    "kind": "test",
    "name": "it115",
    "testId": 115,
    "memberof": "test/2_integrationTests/1_eventstore/1_connection.test.ts~describe106",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/1_connection.test.ts~describe106.it115",
    "access": null,
    "description": "can connect to eventstore cluster secure tcp",
    "lineNumber": 87
  },
  {
    "__docId__": 582,
    "kind": "test",
    "name": "it116",
    "testId": 116,
    "memberof": "test/2_integrationTests/1_eventstore/1_connection.test.ts~describe106",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/1_connection.test.ts~describe106.it116",
    "access": null,
    "description": "can ssl connect to eventstore with cert & strict validation",
    "lineNumber": 103
  },
  {
    "__docId__": 583,
    "kind": "test",
    "name": "it117",
    "testId": 117,
    "memberof": "test/2_integrationTests/1_eventstore/1_connection.test.ts~describe106",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/1_connection.test.ts~describe106.it117",
    "access": null,
    "description": "throws on invalid secure context",
    "lineNumber": 125
  },
  {
    "__docId__": 584,
    "kind": "test",
    "name": "it118",
    "testId": 118,
    "memberof": "test/2_integrationTests/1_eventstore/1_connection.test.ts~describe106",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/1_connection.test.ts~describe106.it118",
    "access": null,
    "description": "finds cluster node over dns (require master)",
    "lineNumber": 146
  },
  {
    "__docId__": 585,
    "kind": "test",
    "name": "it119",
    "testId": 119,
    "memberof": "test/2_integrationTests/1_eventstore/1_connection.test.ts~describe106",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/1_connection.test.ts~describe106.it119",
    "access": null,
    "description": "finds cluster node over dns",
    "lineNumber": 166
  },
  {
    "__docId__": 586,
    "kind": "test",
    "name": "it120",
    "testId": 120,
    "memberof": "test/2_integrationTests/1_eventstore/1_connection.test.ts~describe106",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/1_connection.test.ts~describe106.it120",
    "access": null,
    "description": "finds cluster node from seed list",
    "lineNumber": 187
  },
  {
    "__docId__": 587,
    "kind": "test",
    "name": "it121",
    "testId": 121,
    "memberof": "test/2_integrationTests/1_eventstore/1_connection.test.ts~describe106",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/1_connection.test.ts~describe106.it121",
    "access": null,
    "description": "it throws on invalid credentials",
    "lineNumber": 207
  },
  {
    "__docId__": 588,
    "kind": "test",
    "name": "describe122",
    "testId": 122,
    "memberof": "test/2_integrationTests/1_eventstore/1_connection.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/1_connection.test.ts~describe122",
    "access": null,
    "description": "Basic connection test",
    "lineNumber": 222
  },
  {
    "__docId__": 589,
    "kind": "test",
    "name": "it123",
    "testId": 123,
    "memberof": "test/2_integrationTests/1_eventstore/1_connection.test.ts~describe122",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/1_connection.test.ts~describe122.it123",
    "access": null,
    "description": "returns clientId - name of connection",
    "lineNumber": 239
  },
  {
    "__docId__": 590,
    "kind": "test",
    "name": "it124",
    "testId": 124,
    "memberof": "test/2_integrationTests/1_eventstore/1_connection.test.ts~describe122",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/1_connection.test.ts~describe122.it124",
    "access": null,
    "description": "can ping eventstore",
    "lineNumber": 243
  },
  {
    "__docId__": 591,
    "kind": "testFile",
    "name": "test/2_integrationTests/1_eventstore/2_readAllEvents.test.ts",
    "content": "import * as assert from 'assert'\nimport {Eventstore, Position} from '../../../src'\n\ndescribe('Read all events', (): void => {\n  const es = new Eventstore({\n    uri: 'discover://restrictedUser:restrictedOnlyUserPassword@cluster1.escluster.net:2112',\n    clientId: 'ts-client-test',\n    useSSL: true\n  })\n  before(\n    async (): Promise<void> => {\n      await es.connect()\n    }\n  )\n\n  after(\n    async (): Promise<void> => {\n      await es.disconnect()\n    }\n  )\n\n  it('reads a slice from all events forward', async (): Promise<void> => {\n    let slice\n    try {\n      slice = await es.readSliceForward(Position.Start, 100, true, true, {\n        username: 'admin',\n        password: 'changeit'\n      })\n      assert.ok('ok')\n    } catch (err) {\n      assert.fail(err)\n    }\n\n    assert.notStrictEqual(slice, undefined)\n  })\n\n  it('reads a slice from all events backward', async (): Promise<void> => {\n    let slice\n    try {\n      slice = await es.readSliceBackward(Position.End, 100, true, true, {\n        username: 'admin',\n        password: 'changeit'\n      })\n      assert.ok('ok')\n    } catch (err) {\n      assert.fail(err)\n    }\n\n    assert.notStrictEqual(slice, undefined)\n  })\n\n  it('throws on access denied (forward)', async (): Promise<void> => {\n    try {\n      await es.readSliceForward(Position.Start)\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.ok('has thrown')\n      assert.strictEqual(err.name, 'EventstoreAccessDeniedError')\n    }\n  })\n\n  it('throws on access denied (backward)', async (): Promise<void> => {\n    try {\n      await es.readSliceBackward(Position.End)\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.ok('has thrown')\n      assert.strictEqual(err.name, 'EventstoreAccessDeniedError')\n    }\n  })\n})\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/test/2_integrationTests/1_eventstore/2_readAllEvents.test.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 592,
    "kind": "test",
    "name": "describe125",
    "testId": 125,
    "memberof": "test/2_integrationTests/1_eventstore/2_readAllEvents.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/2_readAllEvents.test.ts~describe125",
    "access": null,
    "description": "Read all events",
    "lineNumber": 4
  },
  {
    "__docId__": 593,
    "kind": "test",
    "name": "it126",
    "testId": 126,
    "memberof": "test/2_integrationTests/1_eventstore/2_readAllEvents.test.ts~describe125",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/2_readAllEvents.test.ts~describe125.it126",
    "access": null,
    "description": "reads a slice from all events forward",
    "lineNumber": 22
  },
  {
    "__docId__": 594,
    "kind": "test",
    "name": "it127",
    "testId": 127,
    "memberof": "test/2_integrationTests/1_eventstore/2_readAllEvents.test.ts~describe125",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/2_readAllEvents.test.ts~describe125.it127",
    "access": null,
    "description": "reads a slice from all events backward",
    "lineNumber": 37
  },
  {
    "__docId__": 595,
    "kind": "test",
    "name": "it128",
    "testId": 128,
    "memberof": "test/2_integrationTests/1_eventstore/2_readAllEvents.test.ts~describe125",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/2_readAllEvents.test.ts~describe125.it128",
    "access": null,
    "description": "throws on access denied (forward)",
    "lineNumber": 52
  },
  {
    "__docId__": 596,
    "kind": "test",
    "name": "it129",
    "testId": 129,
    "memberof": "test/2_integrationTests/1_eventstore/2_readAllEvents.test.ts~describe125",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/2_readAllEvents.test.ts~describe125.it129",
    "access": null,
    "description": "throws on access denied (backward)",
    "lineNumber": 62
  },
  {
    "__docId__": 597,
    "kind": "testFile",
    "name": "test/2_integrationTests/1_eventstore/3_walkAllEvents.test.ts",
    "content": "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport * as assert from 'assert'\nimport {Eventstore, Position} from '../../../src'\n\ndescribe('Read all events', (): void => {\n  const es = new Eventstore({\n    uri: 'discover://admin:changeit@cluster1.escluster.net:2112',\n    clientId: 'ts-client-test',\n    useSSL: true\n  })\n\n  let forwardResult: any[]\n  let backwardResult: any[]\n\n  before(\n    async (): Promise<void> => {\n      await es.connect()\n    }\n  )\n\n  after(\n    async (): Promise<void> => {\n      await es.disconnect()\n    }\n  )\n\n  it('reads all events forward', async (): Promise<void> => {\n    let slice\n    try {\n      slice = await es.walkAllForward()\n      forwardResult = await slice.toArray()\n\n      assert.ok('ok')\n    } catch (err) {\n      assert.fail(err)\n    }\n\n    assert.strictEqual(forwardResult.length > 10000, true)\n  })\n\n  it('reads all events backward', async (): Promise<void> => {\n    let slice\n    try {\n      slice = await es.walkAllBackward()\n      backwardResult = await slice.toArray()\n\n      assert.ok('ok')\n    } catch (err) {\n      assert.fail(err)\n    }\n\n    assert.strictEqual(backwardResult.length > 10000, true)\n  })\n\n  it('matches end/start entries', (): void => {\n    assert.strictEqual(forwardResult[0].eventId, backwardResult[backwardResult.length - 1].eventId)\n    assert.strictEqual(\n      forwardResult[forwardResult.length - 1].eventId,\n      backwardResult[backwardResult.length - forwardResult.length].eventId\n    )\n  })\n\n  it('reads all links forward', async (): Promise<void> => {\n    let slice\n    try {\n      slice = await es.walkAllForward(Position.Start, false)\n      forwardResult = await slice.toArray()\n\n      assert.ok('ok')\n    } catch (err) {\n      assert.fail(err)\n    }\n\n    assert.strictEqual(forwardResult.length > 10000, true)\n  })\n\n  it('reads all links backward', async (): Promise<void> => {\n    let slice\n    try {\n      slice = await es.walkAllBackward(Position.End, false)\n      backwardResult = await slice.toArray()\n\n      assert.ok('ok')\n    } catch (err) {\n      assert.fail(err)\n    }\n\n    assert.strictEqual(backwardResult.length > 10000, true)\n  })\n})\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/test/2_integrationTests/1_eventstore/3_walkAllEvents.test.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 598,
    "kind": "test",
    "name": "describe130",
    "testId": 130,
    "memberof": "test/2_integrationTests/1_eventstore/3_walkAllEvents.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/3_walkAllEvents.test.ts~describe130",
    "access": null,
    "description": "Read all events",
    "lineNumber": 5
  },
  {
    "__docId__": 599,
    "kind": "test",
    "name": "it131",
    "testId": 131,
    "memberof": "test/2_integrationTests/1_eventstore/3_walkAllEvents.test.ts~describe130",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/3_walkAllEvents.test.ts~describe130.it131",
    "access": null,
    "description": "reads all events forward",
    "lineNumber": 27
  },
  {
    "__docId__": 600,
    "kind": "test",
    "name": "it132",
    "testId": 132,
    "memberof": "test/2_integrationTests/1_eventstore/3_walkAllEvents.test.ts~describe130",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/3_walkAllEvents.test.ts~describe130.it132",
    "access": null,
    "description": "reads all events backward",
    "lineNumber": 41
  },
  {
    "__docId__": 601,
    "kind": "test",
    "name": "it133",
    "testId": 133,
    "memberof": "test/2_integrationTests/1_eventstore/3_walkAllEvents.test.ts~describe130",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/3_walkAllEvents.test.ts~describe130.it133",
    "access": null,
    "description": "matches end/start entries",
    "lineNumber": 55
  },
  {
    "__docId__": 602,
    "kind": "test",
    "name": "it134",
    "testId": 134,
    "memberof": "test/2_integrationTests/1_eventstore/3_walkAllEvents.test.ts~describe130",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/3_walkAllEvents.test.ts~describe130.it134",
    "access": null,
    "description": "reads all links forward",
    "lineNumber": 63
  },
  {
    "__docId__": 603,
    "kind": "test",
    "name": "it135",
    "testId": 135,
    "memberof": "test/2_integrationTests/1_eventstore/3_walkAllEvents.test.ts~describe130",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/3_walkAllEvents.test.ts~describe130.it135",
    "access": null,
    "description": "reads all links backward",
    "lineNumber": 77
  },
  {
    "__docId__": 604,
    "kind": "testFile",
    "name": "test/2_integrationTests/1_eventstore/streamNamesByCategory.test.ts",
    "content": "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport * as assert from 'assert'\nimport {Eventstore} from '../../../src'\n\ndescribe('get stream names by category', (): void => {\n  const es = new Eventstore({\n    uri: 'discover://admin:changeit@cluster1.escluster.net:2112',\n    clientId: 'ts-client-test',\n    useSSL: true\n  })\n\n  const streamList = [\n    'projectiontest-56e774fc-6dc6-49f5-bd6f-e9733aa61dfa',\n    'projectiontest-7b5aedec-f3b2-44cf-b3d7-9c8b9b947ecd',\n    'projectiontest-98cb75de-3a70-49ac-b4fd-e96ae542452c'\n  ]\n\n  before(\n    async (): Promise<void> => {\n      await es.connect()\n    }\n  )\n\n  after(\n    async (): Promise<void> => {\n      await es.disconnect()\n    }\n  )\n\n  it('returns all stream names for category', async (): Promise<void> => {\n    let walker\n    try {\n      walker = await es.streamNamesByCategory('projectiontest')\n      const result = await walker.toArray()\n      assert.ok('ok')\n      assert.strictEqual(result.length, 3)\n      result.forEach(\n        (stream): void => {\n          assert.strictEqual(streamList.includes(stream.data), true)\n        }\n      )\n    } catch (err) {\n      assert.fail(err)\n    }\n  })\n})\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/test/2_integrationTests/1_eventstore/streamNamesByCategory.test.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 605,
    "kind": "test",
    "name": "describe136",
    "testId": 136,
    "memberof": "test/2_integrationTests/1_eventstore/streamNamesByCategory.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/streamNamesByCategory.test.ts~describe136",
    "access": null,
    "description": "get stream names by category",
    "lineNumber": 5
  },
  {
    "__docId__": 606,
    "kind": "test",
    "name": "it137",
    "testId": 137,
    "memberof": "test/2_integrationTests/1_eventstore/streamNamesByCategory.test.ts~describe136",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/streamNamesByCategory.test.ts~describe136.it137",
    "access": null,
    "description": "returns all stream names for category",
    "lineNumber": 30
  },
  {
    "__docId__": 607,
    "kind": "testFile",
    "name": "test/2_integrationTests/1_eventstore/walkEventsByCorrelationId.test.ts",
    "content": "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport * as assert from 'assert'\nimport {Eventstore} from '../../../src'\n\ndescribe('walkEventsByCorrelationId', (): void => {\n  const es = new Eventstore({\n    uri: 'discover://admin:changeit@cluster1.escluster.net:2112',\n    clientId: 'ts-client-test',\n    useSSL: true\n  })\n\n  const validateIdArray = [\n    '6072f9ce-1235-44ec-998d-7f4869dafaa4',\n    '1227f490-9921-498d-a6fc-3d14195a40eb',\n    '66fbbc77-6e6f-4d16-a208-871efdb4a4bb',\n    'd8ae42b1-6ffb-494e-a40c-d463a73f03e4'\n  ]\n\n  before(\n    async (): Promise<void> => {\n      await es.connect()\n    }\n  )\n\n  after(\n    async (): Promise<void> => {\n      await es.disconnect()\n    }\n  )\n\n  it('returns all resolved events for given uuid', async (): Promise<void> => {\n    let walker\n    try {\n      walker = await es.walkEventsByCorrelationId('b9599c37-ce20-415a-bbb5-6d8a1da97cec')\n      const result = await walker.toArray()\n      assert.ok('ok')\n      assert.strictEqual(result.length, 4)\n      assert.strictEqual(result[0].name, 'CommandEvent')\n      assert.strictEqual(result[1].name, 'CausedEvent1')\n      assert.strictEqual(result[2].name, 'CausedEvent2')\n      assert.strictEqual(result[3].name, 'CausedEvent3')\n    } catch (err) {\n      assert.fail(err)\n    }\n  })\n\n  it('returns all linked events for given uuid', async (): Promise<void> => {\n    let walker\n    try {\n      walker = await es.walkEventsByCorrelationId('b9599c37-ce20-415a-bbb5-6d8a1da97cec', 0, false)\n      const result = await walker.toArray()\n      assert.ok('ok')\n      assert.strictEqual(result.length, 4)\n      assert.strictEqual(result[1].metadata.$causedBy, validateIdArray[1])\n      assert.strictEqual(result[2].metadata.$causedBy, validateIdArray[2])\n      assert.strictEqual(result[3].metadata.$causedBy, validateIdArray[3])\n    } catch (err) {\n      assert.fail(err)\n    }\n  })\n})\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/test/2_integrationTests/1_eventstore/walkEventsByCorrelationId.test.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 608,
    "kind": "test",
    "name": "describe138",
    "testId": 138,
    "memberof": "test/2_integrationTests/1_eventstore/walkEventsByCorrelationId.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/walkEventsByCorrelationId.test.ts~describe138",
    "access": null,
    "description": "walkEventsByCorrelationId",
    "lineNumber": 5
  },
  {
    "__docId__": 609,
    "kind": "test",
    "name": "it139",
    "testId": 139,
    "memberof": "test/2_integrationTests/1_eventstore/walkEventsByCorrelationId.test.ts~describe138",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/walkEventsByCorrelationId.test.ts~describe138.it139",
    "access": null,
    "description": "returns all resolved events for given uuid",
    "lineNumber": 31
  },
  {
    "__docId__": 610,
    "kind": "test",
    "name": "it140",
    "testId": 140,
    "memberof": "test/2_integrationTests/1_eventstore/walkEventsByCorrelationId.test.ts~describe138",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/walkEventsByCorrelationId.test.ts~describe138.it140",
    "access": null,
    "description": "returns all linked events for given uuid",
    "lineNumber": 47
  },
  {
    "__docId__": 611,
    "kind": "testFile",
    "name": "test/2_integrationTests/1_eventstore/walkEventsByStreamCategory.test.ts",
    "content": "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport * as assert from 'assert'\nimport {Eventstore} from '../../../src'\n\ndescribe('walkEventsByStreamCategory', (): void => {\n  const es = new Eventstore({\n    uri: 'discover://admin:changeit@cluster1.escluster.net:2112',\n    clientId: 'ts-client-test',\n    useSSL: true\n  })\n\n  const validateIdArray = [\n    '0ce2988f-bbe9-43f9-b35f-7ebdc1089ce5',\n    'be4f0224-2758-4a1e-9ad4-85aac4924cd2',\n    'fb98f517-3252-4261-87cd-bc14800b3e83',\n    '8939b5f2-9ac2-43e3-963a-c5d06ce84d02',\n    '683199bf-4627-440e-9efe-4b2696891bb5',\n    'abcfd640-2f74-4ada-b974-229ad724644d',\n    '4b726266-d2fe-4340-bb01-a14125b45c22',\n    'b6acc084-ec0b-4c3d-8b54-b5e3e73ac8e5',\n    '2318605d-534c-44c7-97ad-394ecb99d9a0',\n    'e6dd040c-2c59-492d-a66a-d50a50e1a198',\n    '2db02d39-f2fb-40eb-a1e5-1d6bb9c6118d',\n    '3c42ee7e-3fc8-4959-baf9-4b4ce13c3f0b'\n  ]\n\n  before(\n    async (): Promise<void> => {\n      await es.connect()\n    }\n  )\n\n  after(\n    async (): Promise<void> => {\n      await es.disconnect()\n    }\n  )\n\n  it('returns all resolved events for category', async (): Promise<void> => {\n    let walker\n    try {\n      walker = await es.walkEventsByStreamCategory('projectiontest')\n      const result = await walker.toArray()\n      assert.ok('ok')\n      assert.strictEqual(result.length, 12)\n      result.forEach(\n        (event): void => {\n          assert.strictEqual(event.name === 'LookUpEvent1' || event.name === 'LookUpEvent2', true)\n        }\n      )\n    } catch (err) {\n      assert.fail(err)\n    }\n  })\n\n  it('returns all linked events for category', async (): Promise<void> => {\n    let walker\n    try {\n      walker = await es.walkEventsByStreamCategory('projectiontest', 0, false)\n      const result = await walker.toArray()\n      assert.ok('ok')\n      assert.strictEqual(result.length, 12)\n      result.forEach(\n        (event): void => {\n          assert.strictEqual(validateIdArray.includes(event.metadata.$causedBy), true)\n        }\n      )\n    } catch (err) {\n      assert.fail(err)\n    }\n  })\n})\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/test/2_integrationTests/1_eventstore/walkEventsByStreamCategory.test.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 612,
    "kind": "test",
    "name": "describe141",
    "testId": 141,
    "memberof": "test/2_integrationTests/1_eventstore/walkEventsByStreamCategory.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/walkEventsByStreamCategory.test.ts~describe141",
    "access": null,
    "description": "walkEventsByStreamCategory",
    "lineNumber": 5
  },
  {
    "__docId__": 613,
    "kind": "test",
    "name": "it142",
    "testId": 142,
    "memberof": "test/2_integrationTests/1_eventstore/walkEventsByStreamCategory.test.ts~describe141",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/walkEventsByStreamCategory.test.ts~describe141.it142",
    "access": null,
    "description": "returns all resolved events for category",
    "lineNumber": 39
  },
  {
    "__docId__": 614,
    "kind": "test",
    "name": "it143",
    "testId": 143,
    "memberof": "test/2_integrationTests/1_eventstore/walkEventsByStreamCategory.test.ts~describe141",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/walkEventsByStreamCategory.test.ts~describe141.it143",
    "access": null,
    "description": "returns all linked events for category",
    "lineNumber": 56
  },
  {
    "__docId__": 615,
    "kind": "testFile",
    "name": "test/2_integrationTests/1_eventstore/walkEventsByType.test.ts",
    "content": "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport * as assert from 'assert'\nimport {Eventstore} from '../../../src'\n\ndescribe('walkEventsByType', (): void => {\n  const es = new Eventstore({\n    uri: 'discover://admin:changeit@cluster1.escluster.net:2112',\n    clientId: 'ts-client-test',\n    useSSL: true\n  })\n\n  const LookUpEvent1 = [\n    '0ce2988f-bbe9-43f9-b35f-7ebdc1089ce5',\n    'fb98f517-3252-4261-87cd-bc14800b3e83',\n    '683199bf-4627-440e-9efe-4b2696891bb5',\n    '4b726266-d2fe-4340-bb01-a14125b45c22',\n    '2318605d-534c-44c7-97ad-394ecb99d9a0',\n    '2db02d39-f2fb-40eb-a1e5-1d6bb9c6118d'\n  ]\n\n  const LookUpEvent2 = [\n    'be4f0224-2758-4a1e-9ad4-85aac4924cd2',\n    '8939b5f2-9ac2-43e3-963a-c5d06ce84d02',\n    'abcfd640-2f74-4ada-b974-229ad724644d',\n    'b6acc084-ec0b-4c3d-8b54-b5e3e73ac8e5',\n    'e6dd040c-2c59-492d-a66a-d50a50e1a198',\n    '3c42ee7e-3fc8-4959-baf9-4b4ce13c3f0b'\n  ]\n\n  before(\n    async (): Promise<void> => {\n      await es.connect()\n    }\n  )\n\n  after(\n    async (): Promise<void> => {\n      await es.disconnect()\n    }\n  )\n\n  it('returns all resolved events of type LookUpEvent1', async (): Promise<void> => {\n    let walker\n    try {\n      walker = await es.walkEventsByType('LookUpEvent1')\n      const result = await walker.toArray()\n      assert.ok('ok')\n      assert.strictEqual(result.length, 6)\n      result.forEach(\n        (event): void => {\n          assert.strictEqual(event.name === 'LookUpEvent1', true)\n        }\n      )\n    } catch (err) {\n      assert.fail(err)\n    }\n  })\n\n  it('returns all resolved events of type LookUpEvent2', async (): Promise<void> => {\n    let walker\n    try {\n      walker = await es.walkEventsByType('LookUpEvent2')\n      const result = await walker.toArray()\n      assert.ok('ok')\n      assert.strictEqual(result.length, 6)\n      result.forEach(\n        (event): void => {\n          assert.strictEqual(event.name === 'LookUpEvent2', true)\n        }\n      )\n    } catch (err) {\n      assert.fail(err)\n    }\n  })\n\n  it('returns all linked events of type LookUpEvent1', async (): Promise<void> => {\n    let walker\n    try {\n      walker = await es.walkEventsByType('LookUpEvent1', 0, false)\n      const result = await walker.toArray()\n      assert.ok('ok')\n      assert.strictEqual(result.length, 6)\n      result.forEach(\n        (event): void => {\n          assert.strictEqual(LookUpEvent1.includes(event.metadata.$causedBy), true)\n        }\n      )\n    } catch (err) {\n      assert.fail(err)\n    }\n  })\n\n  it('returns all linked events of type LookUpEvent2', async (): Promise<void> => {\n    let walker\n    try {\n      walker = await es.walkEventsByType('LookUpEvent2', 0, false)\n      const result = await walker.toArray()\n      assert.ok('ok')\n      assert.strictEqual(result.length, 6)\n      result.forEach(\n        (event): void => {\n          assert.strictEqual(LookUpEvent2.includes(event.metadata.$causedBy), true)\n        }\n      )\n    } catch (err) {\n      assert.fail(err)\n    }\n  })\n})\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/test/2_integrationTests/1_eventstore/walkEventsByType.test.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 616,
    "kind": "test",
    "name": "describe144",
    "testId": 144,
    "memberof": "test/2_integrationTests/1_eventstore/walkEventsByType.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/walkEventsByType.test.ts~describe144",
    "access": null,
    "description": "walkEventsByType",
    "lineNumber": 5
  },
  {
    "__docId__": 617,
    "kind": "test",
    "name": "it145",
    "testId": 145,
    "memberof": "test/2_integrationTests/1_eventstore/walkEventsByType.test.ts~describe144",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/walkEventsByType.test.ts~describe144.it145",
    "access": null,
    "description": "returns all resolved events of type LookUpEvent1",
    "lineNumber": 42
  },
  {
    "__docId__": 618,
    "kind": "test",
    "name": "it146",
    "testId": 146,
    "memberof": "test/2_integrationTests/1_eventstore/walkEventsByType.test.ts~describe144",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/walkEventsByType.test.ts~describe144.it146",
    "access": null,
    "description": "returns all resolved events of type LookUpEvent2",
    "lineNumber": 59
  },
  {
    "__docId__": 619,
    "kind": "test",
    "name": "it147",
    "testId": 147,
    "memberof": "test/2_integrationTests/1_eventstore/walkEventsByType.test.ts~describe144",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/walkEventsByType.test.ts~describe144.it147",
    "access": null,
    "description": "returns all linked events of type LookUpEvent1",
    "lineNumber": 76
  },
  {
    "__docId__": 620,
    "kind": "test",
    "name": "it148",
    "testId": 148,
    "memberof": "test/2_integrationTests/1_eventstore/walkEventsByType.test.ts~describe144",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/1_eventstore/walkEventsByType.test.ts~describe144.it148",
    "access": null,
    "description": "returns all linked events of type LookUpEvent2",
    "lineNumber": 93
  },
  {
    "__docId__": 621,
    "kind": "testFile",
    "name": "test/2_integrationTests/2_stream/1_stream.test.ts",
    "content": "import {expect} from 'chai'\nimport {Eventstore} from '../../../src'\n\ndescribe('Stream tests', (): void => {\n  const es = new Eventstore({\n    uri: 'discover://restrictedUser:restrictedOnlyUserPassword@cluster1.escluster.net:2112',\n    clientId: 'ts-client-test',\n    useSSL: true\n  })\n  before(\n    async (): Promise<void> => {\n      await es.connect()\n    }\n  )\n\n  after(\n    async (): Promise<void> => {\n      await es.disconnect()\n    }\n  )\n\n  describe('Basic tests', async (): Promise<void> => {\n    it('returns a stream name', (): void => {\n      const stream = es.stream('hola')\n      expect(stream.name).not.to.be.undefined\n      expect(stream.name).not.to.be.null\n    })\n\n    it('returns a stream instance for function stream', (): void => {\n      const stream = es.stream('hola')\n      expect(stream).not.to.be.undefined\n      expect(stream).not.to.be.null\n    })\n\n    it('returns a stream instance for function fromStream', (): void => {\n      const stream = es.fromStream('hola')\n      expect(stream).not.to.be.undefined\n      expect(stream).not.to.be.null\n    })\n\n    it('returns a stream instance for function atStream', (): void => {\n      const stream = es.fromStream('hola')\n      expect(stream).not.to.be.undefined\n      expect(stream).not.to.be.null\n    })\n\n    it('returns same stream on requiresMaster', (): void => {\n      const stream = es.stream('hola')\n      const result = stream.requiresMaster()\n      expect(stream).to.be.equal(result)\n    })\n\n    it('returns same stream on withCredentials', (): void => {\n      const stream = es.stream('hola')\n      const result = stream.withCredentials({username: 'otheruser', password: 'otherpassword'})\n      expect(stream).to.be.equal(result)\n    })\n\n    it('returns same stream on resolveAllLinks', (): void => {\n      const stream = es.stream('hola')\n      const result = stream.resolveAllLinks()\n      expect(stream).to.be.equal(result)\n    })\n\n    it('can soft delete a stream', async (): Promise<void> => {\n      await es.stream('streamtosoftdelete-773f2fc6-ed4b-4f37-9b5b-4d737b181ac3').softDelete()\n    })\n\n    it('can soft delete a stream on master node', async (): Promise<void> => {\n      await es\n        .stream('streamtosoftdeletemaster-5784a6cc-0559-45b1-8432-31535707c140')\n        .requiresMaster()\n        .softDelete()\n    })\n\n    it('can hard delete a stream', async (): Promise<void> => {\n      await es.stream('streamtoharddelete-1d772e21-f670-4493-8d72-cb9ab1d03edb').hardDelete()\n    })\n\n    it('throws on delete metastream', async (): Promise<void> => {\n      try {\n        await es.stream('$$streamtosoftdelete').softDelete()\n      } catch (err) {\n        expect(err.name).to.be.equal('EventstoreBadRequestError')\n      }\n    })\n  })\n})\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/test/2_integrationTests/2_stream/1_stream.test.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 622,
    "kind": "test",
    "name": "describe149",
    "testId": 149,
    "memberof": "test/2_integrationTests/2_stream/1_stream.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/2_integrationTests/2_stream/1_stream.test.ts~describe149",
    "access": null,
    "description": "Stream tests",
    "lineNumber": 4
  },
  {
    "__docId__": 623,
    "kind": "test",
    "name": "describe150",
    "testId": 150,
    "memberof": "test/2_integrationTests/2_stream/1_stream.test.ts~describe149",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/2_stream/1_stream.test.ts~describe149.describe150",
    "access": null,
    "description": "Basic tests",
    "lineNumber": 22
  },
  {
    "__docId__": 624,
    "kind": "test",
    "name": "it151",
    "testId": 151,
    "memberof": "test/2_integrationTests/2_stream/1_stream.test.ts~describe149.describe150",
    "testDepth": 2,
    "static": true,
    "longname": "test/2_integrationTests/2_stream/1_stream.test.ts~describe149.describe150.it151",
    "access": null,
    "description": "returns a stream name",
    "lineNumber": 23
  },
  {
    "__docId__": 625,
    "kind": "test",
    "name": "it152",
    "testId": 152,
    "memberof": "test/2_integrationTests/2_stream/1_stream.test.ts~describe149.describe150",
    "testDepth": 2,
    "static": true,
    "longname": "test/2_integrationTests/2_stream/1_stream.test.ts~describe149.describe150.it152",
    "access": null,
    "description": "returns a stream instance for function stream",
    "lineNumber": 29
  },
  {
    "__docId__": 626,
    "kind": "test",
    "name": "it153",
    "testId": 153,
    "memberof": "test/2_integrationTests/2_stream/1_stream.test.ts~describe149.describe150",
    "testDepth": 2,
    "static": true,
    "longname": "test/2_integrationTests/2_stream/1_stream.test.ts~describe149.describe150.it153",
    "access": null,
    "description": "returns a stream instance for function fromStream",
    "lineNumber": 35
  },
  {
    "__docId__": 627,
    "kind": "test",
    "name": "it154",
    "testId": 154,
    "memberof": "test/2_integrationTests/2_stream/1_stream.test.ts~describe149.describe150",
    "testDepth": 2,
    "static": true,
    "longname": "test/2_integrationTests/2_stream/1_stream.test.ts~describe149.describe150.it154",
    "access": null,
    "description": "returns a stream instance for function atStream",
    "lineNumber": 41
  },
  {
    "__docId__": 628,
    "kind": "test",
    "name": "it155",
    "testId": 155,
    "memberof": "test/2_integrationTests/2_stream/1_stream.test.ts~describe149.describe150",
    "testDepth": 2,
    "static": true,
    "longname": "test/2_integrationTests/2_stream/1_stream.test.ts~describe149.describe150.it155",
    "access": null,
    "description": "returns same stream on requiresMaster",
    "lineNumber": 47
  },
  {
    "__docId__": 629,
    "kind": "test",
    "name": "it156",
    "testId": 156,
    "memberof": "test/2_integrationTests/2_stream/1_stream.test.ts~describe149.describe150",
    "testDepth": 2,
    "static": true,
    "longname": "test/2_integrationTests/2_stream/1_stream.test.ts~describe149.describe150.it156",
    "access": null,
    "description": "returns same stream on withCredentials",
    "lineNumber": 53
  },
  {
    "__docId__": 630,
    "kind": "test",
    "name": "it157",
    "testId": 157,
    "memberof": "test/2_integrationTests/2_stream/1_stream.test.ts~describe149.describe150",
    "testDepth": 2,
    "static": true,
    "longname": "test/2_integrationTests/2_stream/1_stream.test.ts~describe149.describe150.it157",
    "access": null,
    "description": "returns same stream on resolveAllLinks",
    "lineNumber": 59
  },
  {
    "__docId__": 631,
    "kind": "test",
    "name": "it158",
    "testId": 158,
    "memberof": "test/2_integrationTests/2_stream/1_stream.test.ts~describe149.describe150",
    "testDepth": 2,
    "static": true,
    "longname": "test/2_integrationTests/2_stream/1_stream.test.ts~describe149.describe150.it158",
    "access": null,
    "description": "can soft delete a stream",
    "lineNumber": 65
  },
  {
    "__docId__": 632,
    "kind": "test",
    "name": "it159",
    "testId": 159,
    "memberof": "test/2_integrationTests/2_stream/1_stream.test.ts~describe149.describe150",
    "testDepth": 2,
    "static": true,
    "longname": "test/2_integrationTests/2_stream/1_stream.test.ts~describe149.describe150.it159",
    "access": null,
    "description": "can soft delete a stream on master node",
    "lineNumber": 69
  },
  {
    "__docId__": 633,
    "kind": "test",
    "name": "it160",
    "testId": 160,
    "memberof": "test/2_integrationTests/2_stream/1_stream.test.ts~describe149.describe150",
    "testDepth": 2,
    "static": true,
    "longname": "test/2_integrationTests/2_stream/1_stream.test.ts~describe149.describe150.it160",
    "access": null,
    "description": "can hard delete a stream",
    "lineNumber": 76
  },
  {
    "__docId__": 634,
    "kind": "test",
    "name": "it161",
    "testId": 161,
    "memberof": "test/2_integrationTests/2_stream/1_stream.test.ts~describe149.describe150",
    "testDepth": 2,
    "static": true,
    "longname": "test/2_integrationTests/2_stream/1_stream.test.ts~describe149.describe150.it161",
    "access": null,
    "description": "throws on delete metastream",
    "lineNumber": 80
  },
  {
    "__docId__": 635,
    "kind": "testFile",
    "name": "test/2_integrationTests/2_stream/2_streamMetadata.test.ts",
    "content": "import {Eventstore} from '../../../src'\nimport * as assert from 'assert'\n\ndescribe('Stream tests', (): void => {\n  const es = new Eventstore({\n    uri: 'discover://restrictedUser:restrictedOnlyUserPassword@cluster1.escluster.net:2112',\n    clientId: 'ts-client-test',\n    useSSL: true\n  })\n  before(\n    async (): Promise<void> => {\n      await es.connect()\n    }\n  )\n\n  after(\n    async (): Promise<void> => {\n      await es.disconnect()\n    }\n  )\n\n  describe('Get stream metadata', async (): Promise<void> => {\n    it('returns null for existing stream with no metadata', async (): Promise<void> => {\n      const metadata = await es\n        .stream('teneventsstream-ad44caa8-d701-48f2-ac1e-2ec147ff1df5')\n        .getMetadata()\n      assert.strictEqual(metadata, null)\n    })\n\n    it('reads metadata for stream on master node', async (): Promise<void> => {\n      const metadata = await es\n        .stream('teneventsstream-ad44caa8-d701-48f2-ac1e-2ec147ff1df5')\n        .requiresMaster()\n        .getMetadata()\n      assert.strictEqual(metadata, null)\n    })\n\n    it('returns null for not existing stream', async (): Promise<void> => {\n      const metadata = await es.stream('notexistingstream').getMetadata()\n      assert.strictEqual(metadata, null)\n    })\n\n    it('throws on metadata stream', async (): Promise<void> => {\n      try {\n        await es.stream('$$teneventsstream-ad44caa8-d701-48f2-ac1e-2ec147ff1df5').getMetadata()\n        assert.fail('has not thrown')\n      } catch (err) {\n        assert.strictEqual(err.name, 'EventstoreBadRequestError')\n      }\n    })\n\n    it('throws on invalid access rights', async (): Promise<void> => {\n      try {\n        await es\n          .stream('$teneventsstream-ad44caa8-d701-48f2-ac1e-2ec147ff1df5')\n          .withCredentials({username: 'invalid', password: 'wrong'})\n          .getMetadata()\n        assert.fail('has not thrown')\n      } catch (err) {\n        assert.strictEqual(err.name, 'EventstoreNotAuthenticatedError')\n      }\n    })\n  })\n\n  describe('Set stream metadata', async (): Promise<void> => {\n    it('writes stream metadata', async (): Promise<void> => {\n      const testData = {foo: 'bar'}\n      try {\n        await es\n          .stream('teneventsstream-ad44caa8-d701-48f2-ac1e-2ec147ff1df5')\n          .setMetadata(testData)\n        assert.ok('has written')\n        const result = await es\n          .stream('teneventsstream-ad44caa8-d701-48f2-ac1e-2ec147ff1df5')\n          .getMetadata()\n        assert.strictEqual(JSON.stringify(result), JSON.stringify(testData))\n      } catch (err) {\n        assert.fail(err)\n      }\n    })\n\n    it('writes stream metadata (require master)', async (): Promise<void> => {\n      try {\n        await es\n          .stream('teneventsstream-ad44caa8-d701-48f2-ac1e-2ec147ff1df5')\n          .requiresMaster()\n          .setMetadata({foo: 'bar'})\n        assert.ok('has written')\n      } catch (err) {\n        assert.fail(err)\n      }\n    })\n\n    it('throws on metadata stream', async (): Promise<void> => {\n      try {\n        await es\n          .stream('$$teneventsstream-ad44caa8-d701-48f2-ac1e-2ec147ff1df5')\n          .setMetadata({foo: 'bar'})\n        assert.fail('has not thrown')\n      } catch (err) {\n        assert.strictEqual(err.name, 'EventstoreBadRequestError')\n      }\n    })\n  })\n})\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/test/2_integrationTests/2_stream/2_streamMetadata.test.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 636,
    "kind": "test",
    "name": "describe162",
    "testId": 162,
    "memberof": "test/2_integrationTests/2_stream/2_streamMetadata.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/2_integrationTests/2_stream/2_streamMetadata.test.ts~describe162",
    "access": null,
    "description": "Stream tests",
    "lineNumber": 4
  },
  {
    "__docId__": 637,
    "kind": "test",
    "name": "describe163",
    "testId": 163,
    "memberof": "test/2_integrationTests/2_stream/2_streamMetadata.test.ts~describe162",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/2_stream/2_streamMetadata.test.ts~describe162.describe163",
    "access": null,
    "description": "Get stream metadata",
    "lineNumber": 22
  },
  {
    "__docId__": 638,
    "kind": "test",
    "name": "it164",
    "testId": 164,
    "memberof": "test/2_integrationTests/2_stream/2_streamMetadata.test.ts~describe162.describe163",
    "testDepth": 2,
    "static": true,
    "longname": "test/2_integrationTests/2_stream/2_streamMetadata.test.ts~describe162.describe163.it164",
    "access": null,
    "description": "returns null for existing stream with no metadata",
    "lineNumber": 23
  },
  {
    "__docId__": 639,
    "kind": "test",
    "name": "it165",
    "testId": 165,
    "memberof": "test/2_integrationTests/2_stream/2_streamMetadata.test.ts~describe162.describe163",
    "testDepth": 2,
    "static": true,
    "longname": "test/2_integrationTests/2_stream/2_streamMetadata.test.ts~describe162.describe163.it165",
    "access": null,
    "description": "reads metadata for stream on master node",
    "lineNumber": 30
  },
  {
    "__docId__": 640,
    "kind": "test",
    "name": "it166",
    "testId": 166,
    "memberof": "test/2_integrationTests/2_stream/2_streamMetadata.test.ts~describe162.describe163",
    "testDepth": 2,
    "static": true,
    "longname": "test/2_integrationTests/2_stream/2_streamMetadata.test.ts~describe162.describe163.it166",
    "access": null,
    "description": "returns null for not existing stream",
    "lineNumber": 38
  },
  {
    "__docId__": 641,
    "kind": "test",
    "name": "it167",
    "testId": 167,
    "memberof": "test/2_integrationTests/2_stream/2_streamMetadata.test.ts~describe162.describe163",
    "testDepth": 2,
    "static": true,
    "longname": "test/2_integrationTests/2_stream/2_streamMetadata.test.ts~describe162.describe163.it167",
    "access": null,
    "description": "throws on metadata stream",
    "lineNumber": 43
  },
  {
    "__docId__": 642,
    "kind": "test",
    "name": "it168",
    "testId": 168,
    "memberof": "test/2_integrationTests/2_stream/2_streamMetadata.test.ts~describe162.describe163",
    "testDepth": 2,
    "static": true,
    "longname": "test/2_integrationTests/2_stream/2_streamMetadata.test.ts~describe162.describe163.it168",
    "access": null,
    "description": "throws on invalid access rights",
    "lineNumber": 52
  },
  {
    "__docId__": 643,
    "kind": "test",
    "name": "describe169",
    "testId": 169,
    "memberof": "test/2_integrationTests/2_stream/2_streamMetadata.test.ts~describe162",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/2_stream/2_streamMetadata.test.ts~describe162.describe169",
    "access": null,
    "description": "Set stream metadata",
    "lineNumber": 65
  },
  {
    "__docId__": 644,
    "kind": "test",
    "name": "it170",
    "testId": 170,
    "memberof": "test/2_integrationTests/2_stream/2_streamMetadata.test.ts~describe162.describe169",
    "testDepth": 2,
    "static": true,
    "longname": "test/2_integrationTests/2_stream/2_streamMetadata.test.ts~describe162.describe169.it170",
    "access": null,
    "description": "writes stream metadata",
    "lineNumber": 66
  },
  {
    "__docId__": 645,
    "kind": "test",
    "name": "it171",
    "testId": 171,
    "memberof": "test/2_integrationTests/2_stream/2_streamMetadata.test.ts~describe162.describe169",
    "testDepth": 2,
    "static": true,
    "longname": "test/2_integrationTests/2_stream/2_streamMetadata.test.ts~describe162.describe169.it171",
    "access": null,
    "description": "writes stream metadata (require master)",
    "lineNumber": 82
  },
  {
    "__docId__": 646,
    "kind": "test",
    "name": "it172",
    "testId": 172,
    "memberof": "test/2_integrationTests/2_stream/2_streamMetadata.test.ts~describe162.describe169",
    "testDepth": 2,
    "static": true,
    "longname": "test/2_integrationTests/2_stream/2_streamMetadata.test.ts~describe162.describe169.it172",
    "access": null,
    "description": "throws on metadata stream",
    "lineNumber": 94
  },
  {
    "__docId__": 647,
    "kind": "testFile",
    "name": "test/2_integrationTests/2_stream/3_readStreamBasic.test.ts",
    "content": "import * as assert from 'assert'\nimport {Eventstore} from '../../../src'\ndescribe('Read stream basic tests', (): void => {\n  const es = new Eventstore({\n    uri: 'discover://restrictedUser:restrictedOnlyUserPassword@cluster1.escluster.net:2112',\n    clientId: 'ts-client-test',\n    useSSL: true\n  })\n  before(\n    async (): Promise<void> => {\n      await es.connect()\n    }\n  )\n\n  after(\n    async (): Promise<void> => {\n      await es.disconnect()\n    }\n  )\n\n  describe('Read one event', async (): Promise<void> => {\n    it('returns a event by given eventNumber', async (): Promise<void> => {\n      const event = await es\n        .stream('teneventsstream-ad44caa8-d701-48f2-ac1e-2ec147ff1df5')\n        .getEventByNumber(0, true)\n      const data: {count?: number} = event.data\n\n      assert.strictEqual(event.name, 'EventTypeOne')\n      assert.notEqual(event.data, null)\n      assert.strictEqual(data.count, 1)\n    })\n\n    it('returns a event by given eventNumber from master', async (): Promise<void> => {\n      const event = await es\n        .stream('teneventsstream-ad44caa8-d701-48f2-ac1e-2ec147ff1df5')\n        .requiresMaster()\n        .getEventByNumber(0, true)\n      const data: {count?: number} = event.data\n\n      assert.strictEqual(event.name, 'EventTypeOne')\n      assert.notEqual(event.data, null)\n      assert.strictEqual(data.count, 1)\n    })\n\n    it('returns first event of stream', async (): Promise<void> => {\n      const event = await es\n        .stream('teneventsstream-ad44caa8-d701-48f2-ac1e-2ec147ff1df5')\n        .getFirstEvent()\n      const data: {count?: number} = event.data\n\n      assert.strictEqual(event.name, 'EventTypeOne')\n      assert.notEqual(event.data, null)\n      assert.strictEqual(data.count, 1)\n    })\n\n    it('returns last event of stream', async (): Promise<void> => {\n      const event = await es\n        .stream('teneventsstream-ad44caa8-d701-48f2-ac1e-2ec147ff1df5')\n        .getLastEvent()\n      const data: {count?: number} = event.data\n\n      assert.strictEqual(event.name, 'EventTypeTwo')\n      assert.notEqual(event.data, null)\n      assert.strictEqual(data.count, 10)\n    })\n  })\n})\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/test/2_integrationTests/2_stream/3_readStreamBasic.test.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 648,
    "kind": "test",
    "name": "describe173",
    "testId": 173,
    "memberof": "test/2_integrationTests/2_stream/3_readStreamBasic.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/2_integrationTests/2_stream/3_readStreamBasic.test.ts~describe173",
    "access": null,
    "description": "Read stream basic tests",
    "lineNumber": 3
  },
  {
    "__docId__": 649,
    "kind": "test",
    "name": "describe174",
    "testId": 174,
    "memberof": "test/2_integrationTests/2_stream/3_readStreamBasic.test.ts~describe173",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/2_stream/3_readStreamBasic.test.ts~describe173.describe174",
    "access": null,
    "description": "Read one event",
    "lineNumber": 21
  },
  {
    "__docId__": 650,
    "kind": "test",
    "name": "it175",
    "testId": 175,
    "memberof": "test/2_integrationTests/2_stream/3_readStreamBasic.test.ts~describe173.describe174",
    "testDepth": 2,
    "static": true,
    "longname": "test/2_integrationTests/2_stream/3_readStreamBasic.test.ts~describe173.describe174.it175",
    "access": null,
    "description": "returns a event by given eventNumber",
    "lineNumber": 22
  },
  {
    "__docId__": 651,
    "kind": "test",
    "name": "it176",
    "testId": 176,
    "memberof": "test/2_integrationTests/2_stream/3_readStreamBasic.test.ts~describe173.describe174",
    "testDepth": 2,
    "static": true,
    "longname": "test/2_integrationTests/2_stream/3_readStreamBasic.test.ts~describe173.describe174.it176",
    "access": null,
    "description": "returns a event by given eventNumber from master",
    "lineNumber": 33
  },
  {
    "__docId__": 652,
    "kind": "test",
    "name": "it177",
    "testId": 177,
    "memberof": "test/2_integrationTests/2_stream/3_readStreamBasic.test.ts~describe173.describe174",
    "testDepth": 2,
    "static": true,
    "longname": "test/2_integrationTests/2_stream/3_readStreamBasic.test.ts~describe173.describe174.it177",
    "access": null,
    "description": "returns first event of stream",
    "lineNumber": 45
  },
  {
    "__docId__": 653,
    "kind": "test",
    "name": "it178",
    "testId": 178,
    "memberof": "test/2_integrationTests/2_stream/3_readStreamBasic.test.ts~describe173.describe174",
    "testDepth": 2,
    "static": true,
    "longname": "test/2_integrationTests/2_stream/3_readStreamBasic.test.ts~describe173.describe174.it178",
    "access": null,
    "description": "returns last event of stream",
    "lineNumber": 56
  },
  {
    "__docId__": 654,
    "kind": "testFile",
    "name": "test/2_integrationTests/2_stream/4_readStreamWalk.test.ts",
    "content": "import * as assert from 'assert'\nimport {Eventstore} from '../../../src'\ndescribe('Walk stream tests', (): void => {\n  const es = new Eventstore({\n    uri: 'discover://restrictedUser:restrictedOnlyUserPassword@cluster1.escluster.net:2112',\n    clientId: 'ts-client-test',\n    useSSL: true\n  })\n  before(\n    async (): Promise<void> => {\n      await es.connect()\n    }\n  )\n\n  after(\n    async (): Promise<void> => {\n      await es.disconnect()\n    }\n  )\n\n  it('can walk to stream forward', async (): Promise<void> => {\n    const walker = await es\n      .stream('tenthousandstream-f73cff95-564b-4da4-8072-4d761db6cd34')\n      .walkStreamForward()\n\n    let checkCounter = 0\n    for await (const value of walker) {\n      assert.strictEqual(value.data.count, checkCounter)\n      checkCounter++\n    }\n    assert.strictEqual(checkCounter, 10001)\n  })\n\n  it('can walk to stream backward', async (): Promise<void> => {\n    const walker = await es\n      .stream('tenthousandstream-f73cff95-564b-4da4-8072-4d761db6cd34')\n      .walkStreamBackward()\n\n    let checkCounter = 10001\n    for await (const value of walker) {\n      checkCounter--\n      assert.strictEqual(value.data.count, checkCounter)\n    }\n    assert.strictEqual(checkCounter, 0)\n  })\n})\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/test/2_integrationTests/2_stream/4_readStreamWalk.test.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 655,
    "kind": "test",
    "name": "describe179",
    "testId": 179,
    "memberof": "test/2_integrationTests/2_stream/4_readStreamWalk.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/2_integrationTests/2_stream/4_readStreamWalk.test.ts~describe179",
    "access": null,
    "description": "Walk stream tests",
    "lineNumber": 3
  },
  {
    "__docId__": 656,
    "kind": "test",
    "name": "it180",
    "testId": 180,
    "memberof": "test/2_integrationTests/2_stream/4_readStreamWalk.test.ts~describe179",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/2_stream/4_readStreamWalk.test.ts~describe179.it180",
    "access": null,
    "description": "can walk to stream forward",
    "lineNumber": 21
  },
  {
    "__docId__": 657,
    "kind": "test",
    "name": "it181",
    "testId": 181,
    "memberof": "test/2_integrationTests/2_stream/4_readStreamWalk.test.ts~describe179",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/2_stream/4_readStreamWalk.test.ts~describe179.it181",
    "access": null,
    "description": "can walk to stream backward",
    "lineNumber": 34
  },
  {
    "__docId__": 658,
    "kind": "testFile",
    "name": "test/2_integrationTests/3_event/1_appendEvent.test.ts",
    "content": "import {expect} from 'chai'\nimport {Eventstore, Event, ExpectedVersion} from '../../../src'\nimport * as assert from 'assert'\n\ndescribe('Event emit tests', (): void => {\n  const es = new Eventstore({\n    uri: 'discover://restrictedUser:restrictedOnlyUserPassword@cluster1.escluster.net:2112',\n    clientId: 'ts-client-test',\n    useSSL: true\n  })\n  before(\n    async (): Promise<void> => {\n      await es.connect()\n    }\n  )\n\n  after(\n    async (): Promise<void> => {\n      await es.disconnect()\n    }\n  )\n\n  it('appends single new event', async (): Promise<void> => {\n    const eventData = {some: 'fancy', data: 1}\n    const metaData = {meta: 'data', foo: 2}\n    const newEvent = new Event('SingleEventWritten', eventData, metaData)\n    const stream = await es.stream('testemitstream')\n    try {\n      await stream.append(newEvent)\n      expect(newEvent.isNew()).to.be.false\n      const confirm = await stream.getFirstEvent()\n      expect(JSON.stringify(confirm.data)).to.be.equal(JSON.stringify(eventData))\n      expect(JSON.stringify(confirm.metadata)).to.be.equal(JSON.stringify(metaData))\n    } catch (err) {\n      assert.fail(err)\n    }\n  })\n\n  it('appends single new event with require master', async (): Promise<void> => {\n    const newEvent = new Event('SingleEventWritten')\n    const stream = await es.stream('testemitstreamMaster')\n    try {\n      await stream.append(newEvent, ExpectedVersion.Any, true)\n      expect(newEvent.isNew()).to.be.false\n    } catch (err) {\n      assert.fail(err)\n    }\n  })\n\n  it('appends single new event with require master', async (): Promise<void> => {\n    const newEvent = new Event('SingleEventWritten')\n    const stream = await es.stream('testemitstreamMaster')\n    try {\n      await stream.requiresMaster().append(newEvent, ExpectedVersion.Any, true)\n      expect(newEvent.isNew()).to.be.false\n    } catch (err) {\n      assert.fail(err)\n    }\n  })\n\n  it('appends single new event without require master', async (): Promise<void> => {\n    const newEvent = new Event('SingleEventWritten')\n    const stream = await es.stream('testemitstreamMaster')\n    try {\n      await stream.append(newEvent, ExpectedVersion.Any, false)\n      expect(newEvent.isNew()).to.be.false\n    } catch (err) {\n      assert.fail(err)\n    }\n  })\n\n  it('appends multiple new event', async (): Promise<void> => {\n    const newEvents = [\n      new Event('FirstEventWritten'),\n      new Event('NextEventWritten'),\n      new Event('LastEventWritten')\n    ]\n    const stream = await es.stream('testemitstream')\n    try {\n      await stream.append(newEvents)\n      expect(newEvents[0].isNew()).to.be.false\n      expect(newEvents[1].isNew()).to.be.false\n      expect(newEvents[2].isNew()).to.be.false\n    } catch (err) {\n      assert.fail(err)\n    }\n  })\n\n  it('throws when emitting events already stored in eventstore', async (): Promise<void> => {\n    const newEvents = [\n      new Event('FirstEventWritten'),\n      new Event('NextEventWritten'),\n      new Event('LastEventWritten')\n    ]\n    const stream = await es.stream('testemitstream')\n    try {\n      await stream.append(newEvents)\n      expect(newEvents[0].isNew()).to.be.false\n      expect(newEvents[1].isNew()).to.be.false\n      expect(newEvents[2].isNew()).to.be.false\n    } catch (err) {\n      assert.fail(err)\n    }\n    try {\n      await stream.append(newEvents)\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.ok(err)\n      expect(err.name).to.be.equal('EventstoreOperationError')\n    }\n  })\n})\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/test/2_integrationTests/3_event/1_appendEvent.test.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 659,
    "kind": "test",
    "name": "describe182",
    "testId": 182,
    "memberof": "test/2_integrationTests/3_event/1_appendEvent.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/2_integrationTests/3_event/1_appendEvent.test.ts~describe182",
    "access": null,
    "description": "Event emit tests",
    "lineNumber": 5
  },
  {
    "__docId__": 660,
    "kind": "test",
    "name": "it183",
    "testId": 183,
    "memberof": "test/2_integrationTests/3_event/1_appendEvent.test.ts~describe182",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/3_event/1_appendEvent.test.ts~describe182.it183",
    "access": null,
    "description": "appends single new event",
    "lineNumber": 23
  },
  {
    "__docId__": 661,
    "kind": "test",
    "name": "it184",
    "testId": 184,
    "memberof": "test/2_integrationTests/3_event/1_appendEvent.test.ts~describe182",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/3_event/1_appendEvent.test.ts~describe182.it184",
    "access": null,
    "description": "appends single new event with require master",
    "lineNumber": 39
  },
  {
    "__docId__": 662,
    "kind": "test",
    "name": "it185",
    "testId": 185,
    "memberof": "test/2_integrationTests/3_event/1_appendEvent.test.ts~describe182",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/3_event/1_appendEvent.test.ts~describe182.it185",
    "access": null,
    "description": "appends single new event with require master",
    "lineNumber": 50
  },
  {
    "__docId__": 663,
    "kind": "test",
    "name": "it186",
    "testId": 186,
    "memberof": "test/2_integrationTests/3_event/1_appendEvent.test.ts~describe182",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/3_event/1_appendEvent.test.ts~describe182.it186",
    "access": null,
    "description": "appends single new event without require master",
    "lineNumber": 61
  },
  {
    "__docId__": 664,
    "kind": "test",
    "name": "it187",
    "testId": 187,
    "memberof": "test/2_integrationTests/3_event/1_appendEvent.test.ts~describe182",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/3_event/1_appendEvent.test.ts~describe182.it187",
    "access": null,
    "description": "appends multiple new event",
    "lineNumber": 72
  },
  {
    "__docId__": 665,
    "kind": "test",
    "name": "it188",
    "testId": 188,
    "memberof": "test/2_integrationTests/3_event/1_appendEvent.test.ts~describe182",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/3_event/1_appendEvent.test.ts~describe182.it188",
    "access": null,
    "description": "throws when emitting events already stored in eventstore",
    "lineNumber": 89
  },
  {
    "__docId__": 666,
    "kind": "testFile",
    "name": "test/2_integrationTests/3_event/2_readEvent.test.ts",
    "content": "import {Eventstore, Event} from '../../../src'\nimport * as assert from 'assert'\nimport {JSONValue} from '../../../src/JSON'\n\ndescribe('Read events from stream', (): void => {\n  const es = new Eventstore({\n    uri: 'discover://restrictedUser:restrictedOnlyUserPassword@cluster1.escluster.net:2112',\n    clientId: 'ts-client-test',\n    useSSL: true\n  })\n  before(\n    async (): Promise<void> => {\n      await es.connect()\n    }\n  )\n\n  after(\n    async (): Promise<void> => {\n      await es.disconnect()\n    }\n  )\n\n  it('reads a slice forward', async (): Promise<void> => {\n    const stream = await es.stream('teneventsstream-ad44caa8-d701-48f2-ac1e-2ec147ff1df5')\n    const result = await stream.readSliceForward(0, 100, true)\n    assert.notStrictEqual(result, undefined)\n    assert.notStrictEqual(result, null)\n    assert.strictEqual(result.isEndOfStream, true)\n    assert.strictEqual(result.events.length, 10)\n    for (let x = 0, xMax = result.events.length; x < xMax; x++) {\n      const event = Event.fromRaw(result.events[x].event)\n      // eslint-disable-next-line @typescript-eslint/no-angle-bracket-type-assertion\n      const data: {[k: string]: JSONValue} = <{count: number}>event.data\n      assert.strictEqual(data.count, x + 1)\n    }\n  })\n\n  it('reads a slice backward', async (): Promise<void> => {\n    const stream = await es.stream('teneventsstream-ad44caa8-d701-48f2-ac1e-2ec147ff1df5')\n    const result = await stream.readSliceBackward(-1, 100, true)\n    assert.notStrictEqual(result, undefined)\n    assert.notStrictEqual(result, null)\n    assert.strictEqual(result.isEndOfStream, true)\n    assert.strictEqual(result.events.length, 10)\n    for (let x = result.events.length; x > 0; x--) {\n      const event = Event.fromRaw(result.events[x - 1].event)\n      // eslint-disable-next-line @typescript-eslint/no-angle-bracket-type-assertion\n      const data: {[k: string]: JSONValue} = <{count: number}>event.data\n      assert.strictEqual(data.count, 11 - x)\n    }\n  })\n})\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/test/2_integrationTests/3_event/2_readEvent.test.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 667,
    "kind": "test",
    "name": "describe189",
    "testId": 189,
    "memberof": "test/2_integrationTests/3_event/2_readEvent.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/2_integrationTests/3_event/2_readEvent.test.ts~describe189",
    "access": null,
    "description": "Read events from stream",
    "lineNumber": 5
  },
  {
    "__docId__": 668,
    "kind": "test",
    "name": "it190",
    "testId": 190,
    "memberof": "test/2_integrationTests/3_event/2_readEvent.test.ts~describe189",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/3_event/2_readEvent.test.ts~describe189.it190",
    "access": null,
    "description": "reads a slice forward",
    "lineNumber": 23
  },
  {
    "__docId__": 669,
    "kind": "test",
    "name": "it191",
    "testId": 191,
    "memberof": "test/2_integrationTests/3_event/2_readEvent.test.ts~describe189",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/3_event/2_readEvent.test.ts~describe189.it191",
    "access": null,
    "description": "reads a slice backward",
    "lineNumber": 38
  },
  {
    "__docId__": 670,
    "kind": "testFile",
    "name": "test/2_integrationTests/3_event/3_linkedEvent.test.ts",
    "content": "import {Eventstore, Event, Stream} from '../../../src'\nimport * as assert from 'assert'\nimport * as sinon from 'sinon'\n\ndescribe('Linked event', (): void => {\n  const es = new Eventstore({\n    uri: 'discover://restrictedUser:restrictedOnlyUserPassword@cluster1.escluster.net:2112',\n    clientId: 'ts-client-test',\n    useSSL: true\n  })\n  let sandbox = sinon.createSandbox()\n  before(\n    async (): Promise<void> => {\n      await es.connect()\n    }\n  )\n\n  after(\n    async (): Promise<void> => {\n      await es.disconnect()\n    }\n  )\n\n  afterEach(\n    (): void => {\n      sandbox.restore()\n    }\n  )\n\n  it('resolves linked event', async (): Promise<void> => {\n    const walker = await es.fromStream('$ce-teneventsstream').walkStreamForward(0, false)\n    await walker.forEach(\n      async (eventEntry): Promise<void> => {\n        assert.strictEqual(eventEntry.isLink(), true)\n        assert.strictEqual(typeof eventEntry.metadata, 'object')\n        const event = await es.resolveLink(eventEntry, true, {\n          username: 'restrictedUser',\n          password: 'restrictedOnlyUserPassword'\n        })\n        if (event) {\n          assert.strictEqual(event.isLink(), false)\n        }\n      }\n    )\n    assert.ok('ok')\n  })\n\n  it('returns same event if not link', async (): Promise<void> => {\n    const event = new Event('testEvent')\n    const resolvedEvent = await es.resolveLink(event)\n    assert.strictEqual(event, resolvedEvent)\n  })\n\n  it('throws NotFoundError', async (): Promise<void> => {\n    class TestClass extends Event {\n      public constructor() {\n        super('testEvent')\n      }\n\n      public get data(): string {\n        return '0@fakeStream'\n      }\n\n      public isLink(): boolean {\n        return true\n      }\n    }\n\n    sandbox.stub(Stream.prototype, 'getEventByNumber').resolves(null)\n    const event = new TestClass()\n\n    try {\n      await es.resolveLink(event)\n      assert.fail('has not thrown')\n    } catch (err) {\n      console.log(err)\n      assert.strictEqual(err.name, 'EventstoreNotFoundError')\n    }\n  })\n\n  it('throws ProtocolError', async (): Promise<void> => {\n    sandbox.stub(Stream.prototype, 'getEventByNumber').resolves({data: false})\n    sandbox.stub(Event.prototype, 'isLink').returns(true)\n    const event = new Event('testEvent')\n    try {\n      await es.resolveLink(event)\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreProtocolError')\n    }\n  })\n})\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/test/2_integrationTests/3_event/3_linkedEvent.test.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 671,
    "kind": "test",
    "name": "describe192",
    "testId": 192,
    "memberof": "test/2_integrationTests/3_event/3_linkedEvent.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/2_integrationTests/3_event/3_linkedEvent.test.ts~describe192",
    "access": null,
    "description": "Linked event",
    "lineNumber": 5
  },
  {
    "__docId__": 672,
    "kind": "test",
    "name": "it193",
    "testId": 193,
    "memberof": "test/2_integrationTests/3_event/3_linkedEvent.test.ts~describe192",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/3_event/3_linkedEvent.test.ts~describe192.it193",
    "access": null,
    "description": "resolves linked event",
    "lineNumber": 30
  },
  {
    "__docId__": 673,
    "kind": "test",
    "name": "it194",
    "testId": 194,
    "memberof": "test/2_integrationTests/3_event/3_linkedEvent.test.ts~describe192",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/3_event/3_linkedEvent.test.ts~describe192.it194",
    "access": null,
    "description": "returns same event if not link",
    "lineNumber": 48
  },
  {
    "__docId__": 674,
    "kind": "test",
    "name": "it195",
    "testId": 195,
    "memberof": "test/2_integrationTests/3_event/3_linkedEvent.test.ts~describe192",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/3_event/3_linkedEvent.test.ts~describe192.it195",
    "access": null,
    "description": "throws NotFoundError",
    "lineNumber": 54
  },
  {
    "__docId__": 675,
    "kind": "test",
    "name": "it196",
    "testId": 196,
    "memberof": "test/2_integrationTests/3_event/3_linkedEvent.test.ts~describe192",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/3_event/3_linkedEvent.test.ts~describe192.it196",
    "access": null,
    "description": "throws ProtocolError",
    "lineNumber": 81
  },
  {
    "__docId__": 676,
    "kind": "testFile",
    "name": "test/2_integrationTests/4_transaction/1_transaction.test.ts",
    "content": "import {Eventstore, Event} from '../../../src'\nimport * as assert from 'assert'\n\ndescribe('Transaction tests', (): void => {\n  const es = new Eventstore({\n    uri: 'discover://restrictedUser:restrictedOnlyUserPassword@cluster1.escluster.net:2112',\n    clientId: 'ts-client-test',\n    useSSL: true\n  })\n  before(\n    async (): Promise<void> => {\n      await es.connect()\n    }\n  )\n\n  after(\n    async (): Promise<void> => {\n      await es.disconnect()\n    }\n  )\n\n  it('creates a new transaction', async (): Promise<void> => {\n    const transaction = await es.atStream('transactionstarttest').startTransaction()\n    assert.notStrictEqual(transaction, null)\n    assert.notStrictEqual(transaction, undefined)\n    assert.notStrictEqual(transaction.id, null)\n    assert.notStrictEqual(transaction.id, undefined)\n    assert.strictEqual(transaction.name.startsWith('Transaction: '), true)\n  })\n\n  it('appends events to transaction', async (): Promise<void> => {\n    const singleEvent = new Event('SingleEventWritten')\n    const multiEvents = [\n      new Event('FirstEventWritten'),\n      new Event('NextEventWritten'),\n      new Event('LastEventWritten')\n    ]\n    const transaction = await es.atStream('transactionwritetest').startTransaction()\n    await transaction.append(singleEvent)\n    await transaction.append(multiEvents)\n    await transaction.commit()\n    assert.ok('has committed')\n    const firstEvent = await es.fromStream('transactionwritetest').getFirstEvent()\n    assert.strictEqual(firstEvent.id, singleEvent.id)\n    const lastEvent = await es.fromStream('transactionwritetest').getLastEvent()\n    assert.strictEqual(lastEvent.id, multiEvents[2].id)\n  })\n\n  it('appends events to transaction requiered master', async (): Promise<void> => {\n    const singleEvent = new Event('SingleEventWritten')\n    const multiEvents = [\n      new Event('FirstEventWritten'),\n      new Event('NextEventWritten'),\n      new Event('LastEventWritten')\n    ]\n    const transaction = await es\n      .atStream('transactionwritetestmaster')\n      .requiresMaster()\n      .startTransaction()\n    await transaction.append(singleEvent)\n    await transaction.append(multiEvents)\n    await transaction.commit()\n    assert.ok('has committed')\n    const firstEvent = await es.fromStream('transactionwritetestmaster').getFirstEvent()\n    assert.strictEqual(firstEvent.id, singleEvent.id)\n    const lastEvent = await es.fromStream('transactionwritetestmaster').getLastEvent()\n    assert.strictEqual(lastEvent.id, multiEvents[2].id)\n  })\n\n  it('it throws on re-commiting', async (): Promise<void> => {\n    const singleEvent = new Event('SingleEventWritten')\n    const transaction = await es.atStream('transactionwritetest').startTransaction()\n    await transaction.append(singleEvent)\n    await transaction.commit()\n    assert.ok('has committed')\n    try {\n      await transaction.commit()\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreInvalidTransactionError')\n    }\n  })\n\n  it('it throws on writing to already committed transactions', async (): Promise<void> => {\n    const singleEvent = new Event('SingleEventWritten')\n    const transaction = await es.atStream('transactionwritetest').startTransaction()\n    await transaction.append(singleEvent)\n    await transaction.commit()\n    assert.ok('has committed')\n    try {\n      await transaction.append(singleEvent)\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreInvalidTransactionError')\n    }\n  })\n\n  it('it throws on writing of already stored events', async (): Promise<void> => {\n    const singleEvent = await es.fromStream('transactionwritetest').getFirstEvent()\n    const transaction = await es.atStream('transactionwritetest').startTransaction()\n    try {\n      await transaction.append(singleEvent)\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreOperationError')\n    }\n  })\n\n  it('it throws on commiting roled back transactions', async (): Promise<void> => {\n    const singleEvent = new Event('SingleEventWritten')\n    const transaction = await es.atStream('transactionwritetest').startTransaction()\n    await transaction.append(singleEvent)\n    await transaction.roleBack()\n    try {\n      await transaction.commit()\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreInvalidTransactionError')\n    }\n  })\n\n  it('it throws on writing to roled back transactions', async (): Promise<void> => {\n    const singleEvent = new Event('SingleEventWritten')\n    const transaction = await es.atStream('transactionwritetest').startTransaction()\n    await transaction.append(singleEvent)\n    await transaction.roleBack()\n    try {\n      await transaction.append(singleEvent)\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreInvalidTransactionError')\n    }\n  })\n\n  it('it throws on invalid transaction', async (): Promise<void> => {\n    const singleEvent = new Event('testevent')\n    const transaction = await es.atStream('transactionwritetest').startTransaction(-1)\n    await transaction.append(singleEvent)\n    try {\n      await transaction.commit()\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreWrongExpectedVersionError')\n    }\n  })\n\n  it('it throws on metastreams', async (): Promise<void> => {\n    try {\n      await es.atStream('$$transactionwritetest').startTransaction()\n      assert.fail('has not thrown')\n    } catch (err) {\n      assert.strictEqual(err.name, 'EventstoreBadRequestError')\n    }\n  })\n})\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/test/2_integrationTests/4_transaction/1_transaction.test.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 677,
    "kind": "test",
    "name": "describe197",
    "testId": 197,
    "memberof": "test/2_integrationTests/4_transaction/1_transaction.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/2_integrationTests/4_transaction/1_transaction.test.ts~describe197",
    "access": null,
    "description": "Transaction tests",
    "lineNumber": 4
  },
  {
    "__docId__": 678,
    "kind": "test",
    "name": "it198",
    "testId": 198,
    "memberof": "test/2_integrationTests/4_transaction/1_transaction.test.ts~describe197",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/4_transaction/1_transaction.test.ts~describe197.it198",
    "access": null,
    "description": "creates a new transaction",
    "lineNumber": 22
  },
  {
    "__docId__": 679,
    "kind": "test",
    "name": "it199",
    "testId": 199,
    "memberof": "test/2_integrationTests/4_transaction/1_transaction.test.ts~describe197",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/4_transaction/1_transaction.test.ts~describe197.it199",
    "access": null,
    "description": "appends events to transaction",
    "lineNumber": 31
  },
  {
    "__docId__": 680,
    "kind": "test",
    "name": "it200",
    "testId": 200,
    "memberof": "test/2_integrationTests/4_transaction/1_transaction.test.ts~describe197",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/4_transaction/1_transaction.test.ts~describe197.it200",
    "access": null,
    "description": "appends events to transaction requiered master",
    "lineNumber": 49
  },
  {
    "__docId__": 681,
    "kind": "test",
    "name": "it201",
    "testId": 201,
    "memberof": "test/2_integrationTests/4_transaction/1_transaction.test.ts~describe197",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/4_transaction/1_transaction.test.ts~describe197.it201",
    "access": null,
    "description": "it throws on re-commiting",
    "lineNumber": 70
  },
  {
    "__docId__": 682,
    "kind": "test",
    "name": "it202",
    "testId": 202,
    "memberof": "test/2_integrationTests/4_transaction/1_transaction.test.ts~describe197",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/4_transaction/1_transaction.test.ts~describe197.it202",
    "access": null,
    "description": "it throws on writing to already committed transactions",
    "lineNumber": 84
  },
  {
    "__docId__": 683,
    "kind": "test",
    "name": "it203",
    "testId": 203,
    "memberof": "test/2_integrationTests/4_transaction/1_transaction.test.ts~describe197",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/4_transaction/1_transaction.test.ts~describe197.it203",
    "access": null,
    "description": "it throws on writing of already stored events",
    "lineNumber": 98
  },
  {
    "__docId__": 684,
    "kind": "test",
    "name": "it204",
    "testId": 204,
    "memberof": "test/2_integrationTests/4_transaction/1_transaction.test.ts~describe197",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/4_transaction/1_transaction.test.ts~describe197.it204",
    "access": null,
    "description": "it throws on commiting roled back transactions",
    "lineNumber": 109
  },
  {
    "__docId__": 685,
    "kind": "test",
    "name": "it205",
    "testId": 205,
    "memberof": "test/2_integrationTests/4_transaction/1_transaction.test.ts~describe197",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/4_transaction/1_transaction.test.ts~describe197.it205",
    "access": null,
    "description": "it throws on writing to roled back transactions",
    "lineNumber": 122
  },
  {
    "__docId__": 686,
    "kind": "test",
    "name": "it206",
    "testId": 206,
    "memberof": "test/2_integrationTests/4_transaction/1_transaction.test.ts~describe197",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/4_transaction/1_transaction.test.ts~describe197.it206",
    "access": null,
    "description": "it throws on invalid transaction",
    "lineNumber": 135
  },
  {
    "__docId__": 687,
    "kind": "test",
    "name": "it207",
    "testId": 207,
    "memberof": "test/2_integrationTests/4_transaction/1_transaction.test.ts~describe197",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/4_transaction/1_transaction.test.ts~describe197.it207",
    "access": null,
    "description": "it throws on metastreams",
    "lineNumber": 147
  },
  {
    "__docId__": 688,
    "kind": "testFile",
    "name": "test/2_integrationTests/5_subscription/persistentSubscription.test.ts",
    "content": "import {Eventstore, Event, SubscriptionStatus, NakAction} from '../../../src'\nimport * as assert from 'assert'\nimport {setPersistentSubscriptionConfig} from '../../../src/subscription'\n\ndescribe('Persistent subscription test', (): void => {\n  describe('with admin user rights', (): void => {\n    const es = new Eventstore({\n      uri: 'discover://admin:changeit@cluster1.escluster.net:2112',\n      clientId: 'ts-client-test'\n    })\n    before(\n      async (): Promise<void> => {\n        await es.connect()\n      }\n    )\n\n    after(\n      async (): Promise<void> => {\n        await es.disconnect()\n      }\n    )\n\n    it('creates a persistent subscription', async (): Promise<void> => {\n      const stream = es.stream('subscribestream')\n      try {\n        await stream\n          .withCredentials({username: 'admin', password: 'changeit'})\n          .createPersistentSubscription('persistentsubscription')\n      } catch (err) {\n        assert.fail(err)\n      }\n    })\n\n    it('updates a persistent subscription with object', async (): Promise<void> => {\n      const stream = es.stream('subscribestream')\n      try {\n        const subscription = stream\n          .withCredentials({username: 'admin', password: 'changeit'})\n          .getPersistentSubscription('persistentsubscription')\n        await subscription.update({resolveLinkTos: false})\n      } catch (err) {\n        assert.fail(err)\n      }\n    })\n\n    it('updates a persistent subscription with given subscription config and credentials', async (): Promise<\n      void\n    > => {\n      const stream = es.stream('subscribestream')\n      try {\n        const subscription = stream.getPersistentSubscription('persistentsubscription')\n        await subscription.update(setPersistentSubscriptionConfig({resolveLinkTos: true}), {\n          username: 'admin',\n          password: 'changeit'\n        })\n      } catch (err) {\n        assert.fail(err)\n      }\n    })\n\n    it('throws on creating persistent subscription with same names again', async (): Promise<\n      void\n    > => {\n      const stream = es.stream('subscribestream')\n      try {\n        await stream.createPersistentSubscription('persistentsubscription')\n        assert.fail('has not thrown')\n      } catch (err) {\n        assert.strictEqual(err.name, 'EventstoreAlreadyExistError')\n      }\n    })\n\n    it('deletes a persistent subscription', async (): Promise<void> => {\n      const stream = es.stream('subscribestream')\n      try {\n        const subscription = stream\n          .withCredentials({username: 'admin', password: 'changeit'})\n          .getPersistentSubscription('persistentsubscription')\n        await subscription.delete()\n      } catch (err) {\n        assert.fail(err)\n      }\n    })\n\n    it('throws on delete', async (): Promise<void> => {\n      const stream = es.stream('subscribestream')\n      try {\n        const subscription = stream\n          .withCredentials({username: 'admin', password: 'changeit'})\n          .getPersistentSubscription('unknown')\n        await subscription.delete()\n      } catch (err) {\n        assert.strictEqual(err.name, 'EventstoreDoesNotExistError')\n      }\n    })\n  })\n\n  describe('without admin user rights', (): void => {\n    const es = new Eventstore({\n      uri: 'discover://restrictedUser:restrictedOnlyUserPassword@cluster1.escluster.net:2112',\n      clientId: 'ts-client-test'\n    })\n    before(\n      async (): Promise<void> => {\n        await es.connect()\n        const stream = es\n          .stream('subscribestream')\n          .withCredentials({username: 'admin', password: 'changeit'})\n        await stream.createPersistentSubscription('persistentsubscription2')\n      }\n    )\n\n    after(\n      async (): Promise<void> => {\n        await es.disconnect()\n      }\n    )\n\n    it('throws on create', async (): Promise<void> => {\n      const stream = es.stream('subscribestream')\n      try {\n        await stream.createPersistentSubscription('persistentsubscription1')\n        assert.fail('has not thrown')\n      } catch (err) {\n        assert.strictEqual(err.name, 'EventstoreAccessDeniedError')\n      }\n    })\n\n    it('throws on update', async (): Promise<void> => {\n      const stream = es.stream('subscribestream')\n      try {\n        const subscription = stream.getPersistentSubscription('persistentsubscription2')\n        await subscription.update({resolveLinkTos: false})\n      } catch (err) {\n        assert.strictEqual(err.name, 'EventstoreAccessDeniedError')\n      }\n    })\n\n    it('throws on delete', async (): Promise<void> => {\n      const stream = es.stream('subscribestream')\n      try {\n        const subscription = stream.getPersistentSubscription('persistentsubscription2')\n        await subscription.delete()\n      } catch (err) {\n        assert.strictEqual(err.name, 'EventstoreAccessDeniedError')\n      }\n    })\n  })\n\n  describe('Persistent subscription get events', (): void => {\n    const es = new Eventstore({\n      uri: 'discover://restrictedUser:restrictedOnlyUserPassword@cluster1.escluster.net:2112',\n      clientId: 'ts-client-test'\n    })\n    before(\n      async (): Promise<void> => {\n        await es.connect()\n        const stream = es.stream('persistentsubscribestream3')\n        const newEvent = new Event('SomeEvent')\n        await stream.append(newEvent)\n        try {\n          await stream.createPersistentSubscription(\n            'persistentsubscription3',\n            {},\n            {username: 'admin', password: 'changeit'}\n          )\n        } catch (err) {\n          console.log(err)\n        }\n      }\n    )\n\n    after(\n      async (): Promise<void> => {\n        await es.disconnect()\n      }\n    )\n\n    it('can start a subscription on none empty stream', async (): Promise<void> => {\n      const stream = es.stream('persistentsubscribestream3')\n      const newEvent = new Event('SomeEvent')\n      await stream.append(newEvent)\n      let counter = 0\n      const subscription = stream.getPersistentSubscription('persistentsubscription3')\n\n      subscription.on(\n        'event',\n        (event): void => {\n          counter++\n          subscription.acknowledgeEvent(event)\n        }\n      )\n\n      await subscription.subscribe(10, {\n        username: 'restrictedUser',\n        password: 'restrictedOnlyUserPassword'\n      })\n\n      assert.strictEqual(\n        subscription.name,\n        `PersistentSubscription: persistentsubscribestream3 :: persistentsubscription3`\n      )\n      assert.strictEqual(subscription.state, SubscriptionStatus.connected)\n\n      await new Promise(\n        async (resolve): Promise<void> => {\n          await stream.append(new Event('SomeEvent'))\n          setTimeout(resolve, 1000)\n        }\n      )\n\n      assert.strictEqual(counter, 3)\n\n      await subscription.unsubscribe()\n\n      assert.strictEqual(subscription.state, SubscriptionStatus.disconnected)\n    })\n\n    it('can notAck single event', async (): Promise<void> => {\n      const stream = es.stream('persistentsubscribestream3')\n      const newEvent = new Event('SomeEvent444')\n      await stream.append(newEvent)\n      const subscription = stream.getPersistentSubscription('persistentsubscription3')\n      let counter = 0\n\n      subscription.on(\n        'event',\n        (event): void => {\n          counter++\n          assert.strictEqual(event.id, newEvent.id)\n          subscription.notAcknowledgeEvent(event, NakAction.Unknown)\n        }\n      )\n\n      await subscription.subscribe()\n\n      await new Promise(\n        async (resolve): Promise<void> => {\n          setTimeout(resolve, 1000)\n        }\n      )\n\n      await subscription.unsubscribe()\n\n      await new Promise(\n        async (resolve): Promise<void> => {\n          setTimeout(resolve, 1000)\n        }\n      )\n\n      assert.strictEqual(counter > 0, true)\n    })\n\n    it('notAck single event with unknown by default', async (): Promise<void> => {\n      const stream = es.stream('persistentsubscribestream3')\n      const newEvent = new Event('SomeEvent444')\n      await stream.append(newEvent)\n      const subscription = stream.getPersistentSubscription('persistentsubscription3')\n      let counter = 0\n\n      subscription.on(\n        'event',\n        (event): void => {\n          counter++\n          assert.strictEqual(event.id, newEvent.id)\n          subscription.notAcknowledgeEvent(event)\n        }\n      )\n\n      await subscription.subscribe()\n\n      await new Promise(\n        async (resolve): Promise<void> => {\n          setTimeout(resolve, 1000)\n        }\n      )\n\n      await subscription.unsubscribe()\n\n      await new Promise(\n        async (resolve): Promise<void> => {\n          setTimeout(resolve, 1000)\n        }\n      )\n\n      assert.strictEqual(counter > 0, true)\n    })\n\n    it('notAck events with unknown by default', async (): Promise<void> => {\n      const stream = es.stream('persistentsubscribestream3')\n      const newEvent = new Event('SomeEvent444')\n      await stream.append(newEvent)\n      const subscription = stream.getPersistentSubscription('persistentsubscription3')\n      let counter = 0\n\n      subscription.on(\n        'event',\n        (event): void => {\n          counter++\n          assert.strictEqual(event.id, newEvent.id)\n          subscription.notAcknowledgeEvents([event])\n        }\n      )\n\n      await subscription.subscribe()\n\n      await new Promise(\n        async (resolve): Promise<void> => {\n          setTimeout(resolve, 1000)\n        }\n      )\n\n      await subscription.unsubscribe()\n\n      await new Promise(\n        async (resolve): Promise<void> => {\n          setTimeout(resolve, 1000)\n        }\n      )\n\n      assert.strictEqual(counter > 0, true)\n    })\n  })\n})\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/test/2_integrationTests/5_subscription/persistentSubscription.test.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 689,
    "kind": "test",
    "name": "describe208",
    "testId": 208,
    "memberof": "test/2_integrationTests/5_subscription/persistentSubscription.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/2_integrationTests/5_subscription/persistentSubscription.test.ts~describe208",
    "access": null,
    "description": "Persistent subscription test",
    "lineNumber": 5
  },
  {
    "__docId__": 690,
    "kind": "test",
    "name": "describe209",
    "testId": 209,
    "memberof": "test/2_integrationTests/5_subscription/persistentSubscription.test.ts~describe208",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/5_subscription/persistentSubscription.test.ts~describe208.describe209",
    "access": null,
    "description": "with admin user rights",
    "lineNumber": 6
  },
  {
    "__docId__": 691,
    "kind": "test",
    "name": "it210",
    "testId": 210,
    "memberof": "test/2_integrationTests/5_subscription/persistentSubscription.test.ts~describe208.describe209",
    "testDepth": 2,
    "static": true,
    "longname": "test/2_integrationTests/5_subscription/persistentSubscription.test.ts~describe208.describe209.it210",
    "access": null,
    "description": "creates a persistent subscription",
    "lineNumber": 23
  },
  {
    "__docId__": 692,
    "kind": "test",
    "name": "it211",
    "testId": 211,
    "memberof": "test/2_integrationTests/5_subscription/persistentSubscription.test.ts~describe208.describe209",
    "testDepth": 2,
    "static": true,
    "longname": "test/2_integrationTests/5_subscription/persistentSubscription.test.ts~describe208.describe209.it211",
    "access": null,
    "description": "updates a persistent subscription with object",
    "lineNumber": 34
  },
  {
    "__docId__": 693,
    "kind": "test",
    "name": "it212",
    "testId": 212,
    "memberof": "test/2_integrationTests/5_subscription/persistentSubscription.test.ts~describe208.describe209",
    "testDepth": 2,
    "static": true,
    "longname": "test/2_integrationTests/5_subscription/persistentSubscription.test.ts~describe208.describe209.it212",
    "access": null,
    "description": "updates a persistent subscription with given subscription config and credentials",
    "lineNumber": 46
  },
  {
    "__docId__": 694,
    "kind": "test",
    "name": "it213",
    "testId": 213,
    "memberof": "test/2_integrationTests/5_subscription/persistentSubscription.test.ts~describe208.describe209",
    "testDepth": 2,
    "static": true,
    "longname": "test/2_integrationTests/5_subscription/persistentSubscription.test.ts~describe208.describe209.it213",
    "access": null,
    "description": "throws on creating persistent subscription with same names again",
    "lineNumber": 61
  },
  {
    "__docId__": 695,
    "kind": "test",
    "name": "it214",
    "testId": 214,
    "memberof": "test/2_integrationTests/5_subscription/persistentSubscription.test.ts~describe208.describe209",
    "testDepth": 2,
    "static": true,
    "longname": "test/2_integrationTests/5_subscription/persistentSubscription.test.ts~describe208.describe209.it214",
    "access": null,
    "description": "deletes a persistent subscription",
    "lineNumber": 73
  },
  {
    "__docId__": 696,
    "kind": "test",
    "name": "it215",
    "testId": 215,
    "memberof": "test/2_integrationTests/5_subscription/persistentSubscription.test.ts~describe208.describe209",
    "testDepth": 2,
    "static": true,
    "longname": "test/2_integrationTests/5_subscription/persistentSubscription.test.ts~describe208.describe209.it215",
    "access": null,
    "description": "throws on delete",
    "lineNumber": 85
  },
  {
    "__docId__": 697,
    "kind": "test",
    "name": "describe216",
    "testId": 216,
    "memberof": "test/2_integrationTests/5_subscription/persistentSubscription.test.ts~describe208",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/5_subscription/persistentSubscription.test.ts~describe208.describe216",
    "access": null,
    "description": "without admin user rights",
    "lineNumber": 98
  },
  {
    "__docId__": 698,
    "kind": "test",
    "name": "it217",
    "testId": 217,
    "memberof": "test/2_integrationTests/5_subscription/persistentSubscription.test.ts~describe208.describe216",
    "testDepth": 2,
    "static": true,
    "longname": "test/2_integrationTests/5_subscription/persistentSubscription.test.ts~describe208.describe216.it217",
    "access": null,
    "description": "throws on create",
    "lineNumber": 119
  },
  {
    "__docId__": 699,
    "kind": "test",
    "name": "it218",
    "testId": 218,
    "memberof": "test/2_integrationTests/5_subscription/persistentSubscription.test.ts~describe208.describe216",
    "testDepth": 2,
    "static": true,
    "longname": "test/2_integrationTests/5_subscription/persistentSubscription.test.ts~describe208.describe216.it218",
    "access": null,
    "description": "throws on update",
    "lineNumber": 129
  },
  {
    "__docId__": 700,
    "kind": "test",
    "name": "it219",
    "testId": 219,
    "memberof": "test/2_integrationTests/5_subscription/persistentSubscription.test.ts~describe208.describe216",
    "testDepth": 2,
    "static": true,
    "longname": "test/2_integrationTests/5_subscription/persistentSubscription.test.ts~describe208.describe216.it219",
    "access": null,
    "description": "throws on delete",
    "lineNumber": 139
  },
  {
    "__docId__": 701,
    "kind": "test",
    "name": "describe220",
    "testId": 220,
    "memberof": "test/2_integrationTests/5_subscription/persistentSubscription.test.ts~describe208",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/5_subscription/persistentSubscription.test.ts~describe208.describe220",
    "access": null,
    "description": "Persistent subscription get events",
    "lineNumber": 150
  },
  {
    "__docId__": 702,
    "kind": "test",
    "name": "it221",
    "testId": 221,
    "memberof": "test/2_integrationTests/5_subscription/persistentSubscription.test.ts~describe208.describe220",
    "testDepth": 2,
    "static": true,
    "longname": "test/2_integrationTests/5_subscription/persistentSubscription.test.ts~describe208.describe220.it221",
    "access": null,
    "description": "can start a subscription on none empty stream",
    "lineNumber": 179
  },
  {
    "__docId__": 703,
    "kind": "test",
    "name": "it222",
    "testId": 222,
    "memberof": "test/2_integrationTests/5_subscription/persistentSubscription.test.ts~describe208.describe220",
    "testDepth": 2,
    "static": true,
    "longname": "test/2_integrationTests/5_subscription/persistentSubscription.test.ts~describe208.describe220.it222",
    "access": null,
    "description": "can notAck single event",
    "lineNumber": 219
  },
  {
    "__docId__": 704,
    "kind": "test",
    "name": "it223",
    "testId": 223,
    "memberof": "test/2_integrationTests/5_subscription/persistentSubscription.test.ts~describe208.describe220",
    "testDepth": 2,
    "static": true,
    "longname": "test/2_integrationTests/5_subscription/persistentSubscription.test.ts~describe208.describe220.it223",
    "access": null,
    "description": "notAck single event with unknown by default",
    "lineNumber": 254
  },
  {
    "__docId__": 705,
    "kind": "test",
    "name": "it224",
    "testId": 224,
    "memberof": "test/2_integrationTests/5_subscription/persistentSubscription.test.ts~describe208.describe220",
    "testDepth": 2,
    "static": true,
    "longname": "test/2_integrationTests/5_subscription/persistentSubscription.test.ts~describe208.describe220.it224",
    "access": null,
    "description": "notAck events with unknown by default",
    "lineNumber": 289
  },
  {
    "__docId__": 706,
    "kind": "testFile",
    "name": "test/2_integrationTests/5_subscription/subscription.test.ts",
    "content": "import {Eventstore, Event} from '../../../src'\nimport * as assert from 'assert'\n\ndescribe('Stream subscription tests', (): void => {\n  const es = new Eventstore({\n    uri: 'discover://restrictedUser:restrictedOnlyUserPassword@cluster1.escluster.net:2112',\n    clientId: 'ts-client-test',\n    useSSL: true\n  })\n  before(\n    async (): Promise<void> => {\n      await es.connect()\n    }\n  )\n\n  after(\n    async (): Promise<void> => {\n      await es.disconnect()\n    }\n  )\n\n  it('subscribes and unsubscribes to a stream', async (): Promise<void> => {\n    const stream = await es.stream('subscribestream')\n    let subscription\n    try {\n      subscription = await stream.subscribe()\n      assert.strictEqual(subscription.isSubscribed, true)\n    } catch (err) {\n      assert.fail(err)\n    }\n    try {\n      await subscription.unsubscribe()\n      assert.strictEqual(subscription.isSubscribed, false)\n    } catch (err) {\n      assert.fail(err)\n    }\n  })\n\n  it('returns subscription name', async (): Promise<void> => {\n    const stream = await es.stream('subscribestream')\n    let subscription\n    try {\n      subscription = await stream.subscribe()\n      assert.strictEqual(subscription.isSubscribed, true)\n    } catch (err) {\n      assert.fail(err)\n    }\n    assert.notStrictEqual(subscription.name, null)\n    assert.notStrictEqual(subscription.name, undefined)\n    try {\n      await subscription.unsubscribe()\n      assert.strictEqual(subscription.isSubscribed, false)\n    } catch (err) {\n      assert.fail(err)\n    }\n  })\n\n  it('returns true for resolve links', async (): Promise<void> => {\n    const stream = await es.stream('subscribestream')\n    let subscription\n    try {\n      subscription = await stream.subscribe()\n      assert.strictEqual(subscription.isSubscribed, true)\n    } catch (err) {\n      assert.fail(err)\n    }\n    assert.strictEqual(subscription.getResolveLinkTos(), true)\n    try {\n      await subscription.unsubscribe()\n      assert.strictEqual(subscription.isSubscribed, false)\n    } catch (err) {\n      assert.fail(err)\n    }\n  })\n\n  it('returns false for not resolve links', async (): Promise<void> => {\n    const stream = await es.stream('subscribestream')\n    let subscription\n    try {\n      subscription = await stream.subscribe(false)\n      assert.strictEqual(subscription.isSubscribed, true)\n    } catch (err) {\n      assert.fail(err)\n    }\n    assert.strictEqual(subscription.getResolveLinkTos(), false)\n    try {\n      await subscription.unsubscribe()\n      assert.strictEqual(subscription.isSubscribed, false)\n    } catch (err) {\n      assert.fail(err)\n    }\n  })\n\n  it('logs on error', async (): Promise<void> => {\n    const stream = await es.stream('subscribestream')\n    let subscription\n    try {\n      subscription = await stream.subscribe()\n      assert.strictEqual(subscription.isSubscribed, true)\n      subscription.emit('error', new Error('Log some error'))\n    } catch (err) {\n      assert.fail(err)\n    }\n    try {\n      await subscription.unsubscribe()\n      assert.strictEqual(subscription.isSubscribed, false)\n    } catch (err) {\n      assert.fail(err)\n    }\n  })\n\n  it('receives events', async (): Promise<void> => {\n    const newEvent = new Event('SingleEventWritten')\n    const stream = await es.stream('subscribestream')\n    let subscription\n    try {\n      subscription = await stream.subscribe()\n      assert.strictEqual(subscription.isSubscribed, true)\n    } catch (err) {\n      assert.fail(err)\n    }\n\n    const result: {event: Event; commitPosition: Long; preparePosition: Long} = await Promise.race([\n      new Promise(\n        (resolve, reject): void => {\n          setTimeout(reject, 1000)\n        }\n      ),\n      new Promise(\n        async (resolve, reject): Promise<void> => {\n          const resolveFunction = (\n            event: Event,\n            commitPosition: Long,\n            preparePosition: Long\n          ): void => {\n            resolve({event, commitPosition, preparePosition})\n          }\n          subscription.on('event', resolveFunction)\n          try {\n            await stream.append(newEvent)\n          } catch (err) {\n            reject(err)\n          }\n        }\n      )\n    ])\n    assert.strictEqual(result.event.id, newEvent.id)\n    try {\n      await subscription.unsubscribe()\n      assert.strictEqual(subscription.isSubscribed, false)\n    } catch (err) {\n      assert.fail(err)\n    }\n  })\n})\n",
    "static": true,
    "longname": "/Users/sebastianwessel/Projekte/private_projects/eventstore-ts-client/test/2_integrationTests/5_subscription/subscription.test.ts",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 707,
    "kind": "test",
    "name": "describe225",
    "testId": 225,
    "memberof": "test/2_integrationTests/5_subscription/subscription.test.ts",
    "testDepth": 0,
    "static": true,
    "longname": "test/2_integrationTests/5_subscription/subscription.test.ts~describe225",
    "access": null,
    "description": "Stream subscription tests",
    "lineNumber": 4
  },
  {
    "__docId__": 708,
    "kind": "test",
    "name": "it226",
    "testId": 226,
    "memberof": "test/2_integrationTests/5_subscription/subscription.test.ts~describe225",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/5_subscription/subscription.test.ts~describe225.it226",
    "access": null,
    "description": "subscribes and unsubscribes to a stream",
    "lineNumber": 22
  },
  {
    "__docId__": 709,
    "kind": "test",
    "name": "it227",
    "testId": 227,
    "memberof": "test/2_integrationTests/5_subscription/subscription.test.ts~describe225",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/5_subscription/subscription.test.ts~describe225.it227",
    "access": null,
    "description": "returns subscription name",
    "lineNumber": 39
  },
  {
    "__docId__": 710,
    "kind": "test",
    "name": "it228",
    "testId": 228,
    "memberof": "test/2_integrationTests/5_subscription/subscription.test.ts~describe225",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/5_subscription/subscription.test.ts~describe225.it228",
    "access": null,
    "description": "returns true for resolve links",
    "lineNumber": 58
  },
  {
    "__docId__": 711,
    "kind": "test",
    "name": "it229",
    "testId": 229,
    "memberof": "test/2_integrationTests/5_subscription/subscription.test.ts~describe225",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/5_subscription/subscription.test.ts~describe225.it229",
    "access": null,
    "description": "returns false for not resolve links",
    "lineNumber": 76
  },
  {
    "__docId__": 712,
    "kind": "test",
    "name": "it230",
    "testId": 230,
    "memberof": "test/2_integrationTests/5_subscription/subscription.test.ts~describe225",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/5_subscription/subscription.test.ts~describe225.it230",
    "access": null,
    "description": "logs on error",
    "lineNumber": 94
  },
  {
    "__docId__": 713,
    "kind": "test",
    "name": "it231",
    "testId": 231,
    "memberof": "test/2_integrationTests/5_subscription/subscription.test.ts~describe225",
    "testDepth": 1,
    "static": true,
    "longname": "test/2_integrationTests/5_subscription/subscription.test.ts~describe225.it231",
    "access": null,
    "description": "receives events",
    "lineNumber": 112
  }
]